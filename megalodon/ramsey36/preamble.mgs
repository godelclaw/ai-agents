Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
Infix /\ 780 left := and.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
Infix \/ 785 left := or.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).
Infix <-> 805 := iff.

Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.
Infix = 502 := eq.
Infix <> 502 := neq.

Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.
Binder+ exists , := ex.

Parameter In:set->set->prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.
Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom prop_ext : forall p q:prop, iff p q -> p = q.

Parameter Empty : set.
Axiom EmptyAx : ~exists x:set, x :e Empty.
Axiom EmptyE : forall x:set, x :e Empty -> False.

Parameter Union : set->set.
Axiom UnionEq : forall X x, x :e Union X <-> exists Y, x :e Y /\ Y :e X.

Parameter Power : set->set.
Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.

Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.

Binder+ exists , := ex; and.

Axiom FalseE : False -> forall p:prop, p.
Axiom TrueI : True.
Axiom andI : forall (A B : prop), A -> B -> A /\ B.
Axiom andEL : forall (A B : prop), A /\ B -> A.
Axiom andER : forall (A B : prop), A /\ B -> B.
Axiom orIL : forall (A B : prop), A -> A \/ B.
Axiom orIR : forall (A B : prop), B -> A \/ B.
Axiom orE : forall (A B C:prop), (A -> C) -> (B -> C) -> A \/ B -> C.
Axiom iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
Axiom iffEL : forall A B:prop, (A <-> B) -> A -> B.
Axiom iffER : forall A B:prop, (A <-> B) -> B -> A.
Axiom xm : forall P:prop, P \/ ~P.
Axiom dneg : forall P:prop, ~~P -> P.
Axiom neq_i_sym: forall x y, x <> y -> y <> x.

Section PropN.
Variable P1 P2 P3:prop.
Axiom and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
Axiom or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
Variable P4:prop.
Axiom and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
Axiom or4E : P1 \/ P2 \/ P3 \/ P4 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> p).
Variable P5:prop.
Axiom and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
Axiom or5I1 : P1 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I2 : P2 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I3 : P3 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I4 : P4 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I5 : P5 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5E : P1 \/ P2 \/ P3 \/ P4 \/ P5 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> (P5 -> p) -> p).
Variable P6:prop.
Axiom and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
Axiom or6E : P1 \/ P2 \/ P3 \/ P4 \/ P5 \/ P6 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> (P5 -> p) -> (P6 -> p) -> p).
End PropN.

Parameter UPair : set -> set -> set.
Notation SetEnum2 UPair.
Axiom UPairE : forall x y z:set, x :e UPair y z -> x = y \/ x = z.
Axiom UPairI1 : forall y z:set, y :e UPair y z.
Axiom UPairI2 : forall y z:set, z :e UPair y z.

Parameter Sing : set -> set.
Notation SetEnum1 Sing.
Axiom SingI : forall x:set, x :e Sing x.
Axiom SingE : forall x y:set, y :e Sing x -> y = x.

Parameter binunion : set -> set -> set.
Infix :\/: 345 left := binunion.
Axiom binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
Axiom binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
Axiom binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.

Parameter binintersect:set->set->set.
Infix :/\: 340 left := binintersect.
Axiom binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
Axiom binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
Axiom binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
Axiom binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.

Parameter setminus:set->set->set.
Infix :\: 350 := setminus.
Axiom setminusI:forall X Y z, (z :e X) -> (z :e Y -> False) -> z :e X :\: Y.
Axiom setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
Axiom setminusE2:forall X Y z, (z :e X :\: Y) -> z :e Y -> False.

Parameter ordsucc : set->set.
Axiom ordsuccI1 : forall x:set, x c= ordsucc x.
Axiom ordsuccI2 : forall x:set, x :e ordsucc x.
Axiom ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.
Notation Nat Empty ordsucc.

Axiom neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
Axiom neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
Axiom ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.

Axiom In_irref : forall x, x :e x -> False.
Axiom In_no2cycle : forall x y, x :e y -> y :e x -> False.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Axiom nat_0 : nat_p 0.
Axiom nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
Axiom nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
Axiom nat_trans : forall n, nat_p n -> forall m :e n, m c= n.

Axiom nat_1 : nat_p 1.
Axiom nat_2 : nat_p 2.
Axiom nat_3 : nat_p 3.
Axiom nat_4 : nat_p 4.
Axiom nat_5 : nat_p 5.
Axiom nat_6 : nat_p 6.
Axiom nat_17 : nat_p 17.
Axiom nat_18 : nat_p 18.

Axiom In_0_1 : 0 :e 1.
Axiom In_0_2 : 0 :e 2.
Axiom In_1_2 : 1 :e 2.
Axiom In_0_5 : 0 :e 5.
Axiom In_1_5 : 1 :e 5.
Axiom In_2_5 : 2 :e 5.
Axiom In_3_5 : 3 :e 5.
Axiom In_4_5 : 4 :e 5.
Axiom In_0_6 : 0 :e 6.
Axiom In_1_6 : 1 :e 6.
Axiom In_2_6 : 2 :e 6.
Axiom In_3_6 : 3 :e 6.
Axiom In_4_6 : 4 :e 6.
Axiom In_5_6 : 5 :e 6.
Axiom In_0_17 : 0 :e 17.
Axiom In_1_17 : 1 :e 17.
Axiom In_2_17 : 2 :e 17.
Axiom In_3_17 : 3 :e 17.
Axiom In_4_17 : 4 :e 17.
Axiom In_5_17 : 5 :e 17.
Axiom In_6_17 : 6 :e 17.
Axiom In_7_17 : 7 :e 17.
Axiom In_8_17 : 8 :e 17.
Axiom In_9_17 : 9 :e 17.
Axiom In_10_17 : 10 :e 17.
Axiom In_11_17 : 11 :e 17.
Axiom In_12_17 : 12 :e 17.
Axiom In_13_17 : 13 :e 17.
Axiom In_14_17 : 14 :e 17.
Axiom In_15_17 : 15 :e 17.
Axiom In_16_17 : 16 :e 17.
Axiom In_0_18 : 0 :e 18.
Axiom In_1_18 : 1 :e 18.
Axiom In_2_18 : 2 :e 18.
Axiom In_3_18 : 3 :e 18.
Axiom In_4_18 : 4 :e 18.
Axiom In_5_18 : 5 :e 18.
Axiom In_6_18 : 6 :e 18.
Axiom In_7_18 : 7 :e 18.
Axiom In_8_18 : 8 :e 18.
Axiom In_9_18 : 9 :e 18.
Axiom In_10_18 : 10 :e 18.
Axiom In_11_18 : 11 :e 18.
Axiom In_12_18 : 12 :e 18.
Axiom In_13_18 : 13 :e 18.
Axiom In_14_18 : 14 :e 18.
Axiom In_15_18 : 15 :e 18.
Axiom In_16_18 : 16 :e 18.
Axiom In_17_18 : 17 :e 18.

Axiom neq_0_1 : 0 <> 1.
Axiom neq_0_2 : 0 <> 2.
Axiom neq_0_3 : 0 <> 3.
Axiom neq_0_4 : 0 <> 4.
Axiom neq_0_5 : 0 <> 5.
Axiom neq_1_0 : 1 <> 0.
Axiom neq_1_2 : 1 <> 2.
Axiom neq_1_3 : 1 <> 3.
Axiom neq_1_4 : 1 <> 4.
Axiom neq_1_5 : 1 <> 5.
Axiom neq_2_0 : 2 <> 0.
Axiom neq_2_1 : 2 <> 1.
Axiom neq_2_3 : 2 <> 3.
Axiom neq_2_4 : 2 <> 4.
Axiom neq_2_5 : 2 <> 5.
Axiom neq_3_0 : 3 <> 0.
Axiom neq_3_1 : 3 <> 1.
Axiom neq_3_2 : 3 <> 2.
Axiom neq_3_4 : 3 <> 4.
Axiom neq_3_5 : 3 <> 5.
Axiom neq_4_0 : 4 <> 0.
Axiom neq_4_1 : 4 <> 1.
Axiom neq_4_2 : 4 <> 2.
Axiom neq_4_3 : 4 <> 3.
Axiom neq_4_5 : 4 <> 5.
Axiom neq_5_0 : 5 <> 0.
Axiom neq_5_1 : 5 <> 1.
Axiom neq_5_2 : 5 <> 2.
Axiom neq_5_3 : 5 <> 3.
Axiom neq_5_4 : 5 <> 4.

Axiom cases_1 : forall x :e 1, forall p:set->prop, p 0 -> p x.
Axiom cases_2 : forall x :e 2, forall p:set->prop, p 0 -> p 1 -> p x.
Axiom cases_5 : forall x :e 5, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p x.
Axiom cases_6 : forall x :e 6, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p x.

Definition ordinal : set -> prop := fun x => forall y :e x, forall z :e y, z :e x.
Axiom nat_p_ordinal : forall n, nat_p n -> ordinal n.

Definition equip : set -> set -> prop :=
  fun X Y => exists f:set->set,
    (forall x :e X, f x :e Y) /\
    (forall x y :e X, f x = f y -> x = y) /\
    (forall y :e Y, exists x :e X, f x = y).

Axiom equip_ref : forall X, equip X X.
Axiom equip_sym : forall X Y, equip X Y -> equip Y X.
Axiom equip_tra : forall X Y Z, equip X Y -> equip Y Z -> equip X Z.
Axiom equip_0_Empty : forall X, equip 0 X -> X = Empty.
Axiom equip_1_Sing : forall X, equip 1 X -> exists x, X = {x}.
Axiom equip_3_I : forall u v w, u <> v -> u <> w -> v <> w -> equip 3 {u,v,w}.

Definition TwoRamseyProp : set -> set -> set -> prop
 := fun M N V =>
      forall R:set -> set -> prop,
        (forall x y, R x y -> R y x)
       -> ((exists X c= V, equip M X /\ (forall x y :e X, x <> y -> R x y))
        \/ (exists Y c= V, equip N Y /\ (forall x y :e Y, x <> y -> ~R x y))).

Definition is_graph : set -> (set -> set -> prop) -> prop :=
  fun V R => (forall x y :e V, R x y -> R y x) /\ (forall x :e V, ~R x x).

Definition triangle_free : set -> (set -> set -> prop) -> prop :=
  fun V R => forall x y z :e V, R x y -> R y z -> R x z -> False.

Definition is_indep_set : set -> (set -> set -> prop) -> set -> prop :=
  fun V R S => S c= V /\ (forall x y :e S, x <> y -> ~R x y).

Definition no_k_indep : set -> (set -> set -> prop) -> set -> prop :=
  fun V R k => forall S c= V, equip k S -> ~is_indep_set V R S.

Definition degree : set -> (set -> set -> prop) -> set -> set -> prop :=
  fun V R v d => equip d {y :e V | R v y}.

Definition k_regular : set -> (set -> set -> prop) -> set -> prop :=
  fun V R k => forall v :e V, degree V R v k.

Definition common_neighbors : set -> (set -> set -> prop) -> set -> set -> set :=
  fun V R u v => {w :e V | R u w /\ R v w}.

Axiom TwoRamseyProp_3_3_6 : TwoRamseyProp 3 3 6.
Axiom TwoRamseyProp_3_4_9 : TwoRamseyProp 3 4 9.
Axiom TwoRamseyProp_3_5_14 : TwoRamseyProp 3 5 14.

Axiom ordinal_equip_3_E_impred : forall X, equip 3 X ->
  (forall alpha :e X, ordinal alpha) ->
  forall p:prop,
    (forall alpha beta gamma :e X,
      alpha :e beta -> beta :e gamma ->
      (forall y :e X, forall q:set -> prop, q alpha -> q beta -> q gamma -> q y)
      -> p)
    -> p.

Definition bij : set -> set -> (set -> set) -> prop :=
  fun X Y f =>
    (forall x :e X, f x :e Y) /\
    (forall x y :e X, f x = f y -> x = y) /\
    (forall y :e Y, exists x :e X, f x = y).

Axiom bijI : forall X Y f,
  (forall x :e X, f x :e Y) ->
  (forall x y :e X, f x = f y -> x = y) ->
  (forall y :e Y, exists x :e X, f x = y) ->
  bij X Y f.

Parameter If_i : prop -> set -> set -> set.
Axiom If_i_1 : forall p:prop, forall x y:set, p -> If_i p x y = x.
Axiom If_i_0 : forall p:prop, forall x y:set, ~p -> If_i p x y = y.

Parameter Sep: set -> (set -> prop) -> set.
Notation Sep Sep.
Axiom SepI:forall X:set, forall P:(set->prop), forall x:set, x :e X -> P x -> x :e {x :e X|P x}.
Axiom SepE:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X /\ P x.
Axiom SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
Axiom SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.
