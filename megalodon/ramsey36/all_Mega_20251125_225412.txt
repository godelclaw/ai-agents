================================================================================
MEGALODON RAMSEY36 PROJECT CONCATENATION
================================================================================
Timestamp: $(date '+%a %d. %B %Y, %H:%M:%S %Z')
Working Directory: $(pwd)

This file contains all core Ramsey36 proof files for the theorem R(3,6) = 18.

Key files:
- preamble.mgs: Axioms and foundational lemmas
- cardinality_toolkit.mg: Cardinality and bijection infrastructure
- equip_17_without_one_proof.mg: Proof that removing any element from 18 leaves 17
- good_graph_proof.mg: Main proof structure
- r34_proof.mg: Base case R(3,4) = 9

Status: equip_17_without_one_proof.mg has ONE remaining error at line 248
Fix: Change "Hord_z" to "Hz_nat" (see /home/zar/.claude/plans/parsed-watching-thacker.md)

================================================================================


================================================================================
FILE: preamble.mgs (307 lines)
================================================================================
Definition True : prop := forall p:prop, p -> p.
Definition False : prop := forall p:prop, p.
Definition not : prop -> prop := fun A:prop => A -> False.
Prefix ~ 700 := not.
Definition and : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> B -> p) -> p.
Infix /\ 780 left := and.
Definition or : prop -> prop -> prop := fun A B:prop => forall p:prop, (A -> p) -> (B -> p) -> p.
Infix \/ 785 left := or.
Definition iff : prop -> prop -> prop := fun A B:prop => and (A -> B) (B -> A).
Infix <-> 805 := iff.

Section Eq.
Variable A:SType.
Definition eq : A->A->prop := fun x y:A => forall Q:A->A->prop, Q x y -> Q y x.
Definition neq : A->A->prop := fun x y:A => ~ eq x y.
End Eq.
Infix = 502 := eq.
Infix <> 502 := neq.

Section Ex.
Variable A:SType.
Definition ex : (A->prop)->prop := fun Q:A->prop => forall P:prop, (forall x:A, Q x -> P) -> P.
End Ex.
Binder+ exists , := ex.

Parameter In:set->set->prop.
Definition Subq : set -> set -> prop := fun A B => forall x :e A, x :e B.
Axiom set_ext : forall X Y:set, X c= Y -> Y c= X -> X = Y.
Axiom prop_ext : forall p q:prop, iff p q -> p = q.

Parameter Empty : set.
Axiom EmptyAx : ~exists x:set, x :e Empty.
Axiom EmptyE : forall x:set, x :e Empty -> False.

Parameter Union : set->set.
Axiom UnionEq : forall X x, x :e Union X <-> exists Y, x :e Y /\ Y :e X.

Parameter Power : set->set.
Axiom PowerEq : forall X Y:set, Y :e Power X <-> Y c= X.

Parameter Repl : set -> (set -> set) -> set.
Notation Repl Repl.

Binder+ exists , := ex; and.

Axiom FalseE : False -> forall p:prop, p.
Axiom TrueI : True.
Axiom andI : forall (A B : prop), A -> B -> A /\ B.
Axiom andEL : forall (A B : prop), A /\ B -> A.
Axiom andER : forall (A B : prop), A /\ B -> B.
Axiom orIL : forall (A B : prop), A -> A \/ B.
Axiom orIR : forall (A B : prop), B -> A \/ B.
Axiom orE : forall (A B C:prop), (A -> C) -> (B -> C) -> A \/ B -> C.
Axiom iffI : forall A B:prop, (A -> B) -> (B -> A) -> (A <-> B).
Axiom iffEL : forall A B:prop, (A <-> B) -> A -> B.
Axiom iffER : forall A B:prop, (A <-> B) -> B -> A.
Axiom xm : forall P:prop, P \/ ~P.
Axiom dneg : forall P:prop, ~~P -> P.
Axiom neq_i_sym: forall x y, x <> y -> y <> x.

Section PropN.
Variable P1 P2 P3:prop.
Axiom and3I : P1 -> P2 -> P3 -> P1 /\ P2 /\ P3.
Axiom or3E : P1 \/ P2 \/ P3 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> p).
Variable P4:prop.
Axiom and4I : P1 -> P2 -> P3 -> P4 -> P1 /\ P2 /\ P3 /\ P4.
Axiom or4E : P1 \/ P2 \/ P3 \/ P4 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> p).
Variable P5:prop.
Axiom and5I : P1 -> P2 -> P3 -> P4 -> P5 -> P1 /\ P2 /\ P3 /\ P4 /\ P5.
Axiom or5I1 : P1 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I2 : P2 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I3 : P3 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I4 : P4 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5I5 : P5 -> P1 \/ P2 \/ P3 \/ P4 \/ P5.
Axiom or5E : P1 \/ P2 \/ P3 \/ P4 \/ P5 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> (P5 -> p) -> p).
Variable P6:prop.
Axiom and6I: P1 -> P2 -> P3 -> P4 -> P5 -> P6 -> P1 /\ P2 /\ P3 /\ P4 /\ P5 /\ P6.
Axiom or6E : P1 \/ P2 \/ P3 \/ P4 \/ P5 \/ P6 -> (forall p:prop, (P1 -> p) -> (P2 -> p) -> (P3 -> p) -> (P4 -> p) -> (P5 -> p) -> (P6 -> p) -> p).
End PropN.

Parameter UPair : set -> set -> set.
Notation SetEnum2 UPair.
Axiom UPairE : forall x y z:set, x :e UPair y z -> x = y \/ x = z.
Axiom UPairI1 : forall y z:set, y :e UPair y z.
Axiom UPairI2 : forall y z:set, z :e UPair y z.

Parameter Sing : set -> set.
Notation SetEnum1 Sing.
Axiom SingI : forall x:set, x :e Sing x.
Axiom SingE : forall x y:set, y :e Sing x -> y = x.

Parameter binunion : set -> set -> set.
Infix :\/: 345 left := binunion.
Axiom binunionI1 : forall X Y z:set, z :e X -> z :e X :\/: Y.
Axiom binunionI2 : forall X Y z:set, z :e Y -> z :e X :\/: Y.
Axiom binunionE : forall X Y z:set, z :e X :\/: Y -> z :e X \/ z :e Y.

Definition SetAdjoin : set->set->set := fun X y => X :\/: {y}.
Notation SetEnum Empty Sing UPair SetAdjoin.

Parameter binintersect:set->set->set.
Infix :/\: 340 left := binintersect.
Axiom binintersectI:forall X Y z, z :e X -> z :e Y -> z :e X :/\: Y.
Axiom binintersectE:forall X Y z, z :e X :/\: Y -> z :e X /\ z :e Y.
Axiom binintersectE1:forall X Y z, z :e X :/\: Y -> z :e X.
Axiom binintersectE2:forall X Y z, z :e X :/\: Y -> z :e Y.

Parameter setminus:set->set->set.
Infix :\: 350 := setminus.
Axiom setminusI:forall X Y z, (z :e X) -> (z :e Y -> False) -> z :e X :\: Y.
Axiom setminusE1:forall X Y z, (z :e X :\: Y) -> z :e X.
Axiom setminusE2:forall X Y z, (z :e X :\: Y) -> z :e Y -> False.

Parameter ordsucc : set->set.
Axiom ordsuccI1 : forall x:set, x c= ordsucc x.
Axiom ordsuccI2 : forall x:set, x :e ordsucc x.
Axiom ordsuccE : forall x y:set, y :e ordsucc x -> y :e x \/ y = x.
Notation Nat Empty ordsucc.

Axiom neq_0_ordsucc : forall a:set, 0 <> ordsucc a.
Axiom neq_ordsucc_0 : forall a:set, ordsucc a <> 0.
Axiom ordsucc_inj : forall a b:set, ordsucc a = ordsucc b -> a = b.

Axiom In_irref : forall x, x :e x -> False.
Axiom In_no2cycle : forall x y, x :e y -> y :e x -> False.

Definition nat_p : set->prop := fun n:set => forall p:set->prop, p 0 -> (forall x:set, p x -> p (ordsucc x)) -> p n.

Axiom nat_0 : nat_p 0.
Axiom nat_ordsucc : forall n:set, nat_p n -> nat_p (ordsucc n).
Axiom nat_p_trans : forall n, nat_p n -> forall m :e n, nat_p m.
Axiom nat_trans : forall n, nat_p n -> forall m :e n, m c= n.

Axiom nat_1 : nat_p 1.
Axiom nat_2 : nat_p 2.
Axiom nat_3 : nat_p 3.
Axiom nat_4 : nat_p 4.
Axiom nat_5 : nat_p 5.
Axiom nat_6 : nat_p 6.
Axiom nat_17 : nat_p 17.
Axiom nat_18 : nat_p 18.

Axiom In_0_1 : 0 :e 1.
Axiom In_0_2 : 0 :e 2.
Axiom In_1_2 : 1 :e 2.
Axiom In_0_5 : 0 :e 5.
Axiom In_1_5 : 1 :e 5.
Axiom In_2_5 : 2 :e 5.
Axiom In_3_5 : 3 :e 5.
Axiom In_4_5 : 4 :e 5.
Axiom In_0_6 : 0 :e 6.
Axiom In_1_6 : 1 :e 6.
Axiom In_2_6 : 2 :e 6.
Axiom In_3_6 : 3 :e 6.
Axiom In_4_6 : 4 :e 6.
Axiom In_5_6 : 5 :e 6.
Axiom In_0_17 : 0 :e 17.
Axiom In_1_17 : 1 :e 17.
Axiom In_2_17 : 2 :e 17.
Axiom In_3_17 : 3 :e 17.
Axiom In_4_17 : 4 :e 17.
Axiom In_5_17 : 5 :e 17.
Axiom In_6_17 : 6 :e 17.
Axiom In_7_17 : 7 :e 17.
Axiom In_8_17 : 8 :e 17.
Axiom In_9_17 : 9 :e 17.
Axiom In_10_17 : 10 :e 17.
Axiom In_11_17 : 11 :e 17.
Axiom In_12_17 : 12 :e 17.
Axiom In_13_17 : 13 :e 17.
Axiom In_14_17 : 14 :e 17.
Axiom In_15_17 : 15 :e 17.
Axiom In_16_17 : 16 :e 17.
Axiom In_0_18 : 0 :e 18.
Axiom In_1_18 : 1 :e 18.
Axiom In_2_18 : 2 :e 18.
Axiom In_3_18 : 3 :e 18.
Axiom In_4_18 : 4 :e 18.
Axiom In_5_18 : 5 :e 18.
Axiom In_6_18 : 6 :e 18.
Axiom In_7_18 : 7 :e 18.
Axiom In_8_18 : 8 :e 18.
Axiom In_9_18 : 9 :e 18.
Axiom In_10_18 : 10 :e 18.
Axiom In_11_18 : 11 :e 18.
Axiom In_12_18 : 12 :e 18.
Axiom In_13_18 : 13 :e 18.
Axiom In_14_18 : 14 :e 18.
Axiom In_15_18 : 15 :e 18.
Axiom In_16_18 : 16 :e 18.
Axiom In_17_18 : 17 :e 18.

Axiom neq_0_1 : 0 <> 1.
Axiom neq_0_2 : 0 <> 2.
Axiom neq_0_3 : 0 <> 3.
Axiom neq_0_4 : 0 <> 4.
Axiom neq_0_5 : 0 <> 5.
Axiom neq_1_0 : 1 <> 0.
Axiom neq_1_2 : 1 <> 2.
Axiom neq_1_3 : 1 <> 3.
Axiom neq_1_4 : 1 <> 4.
Axiom neq_1_5 : 1 <> 5.
Axiom neq_2_0 : 2 <> 0.
Axiom neq_2_1 : 2 <> 1.
Axiom neq_2_3 : 2 <> 3.
Axiom neq_2_4 : 2 <> 4.
Axiom neq_2_5 : 2 <> 5.
Axiom neq_3_0 : 3 <> 0.
Axiom neq_3_1 : 3 <> 1.
Axiom neq_3_2 : 3 <> 2.
Axiom neq_3_4 : 3 <> 4.
Axiom neq_3_5 : 3 <> 5.
Axiom neq_4_0 : 4 <> 0.
Axiom neq_4_1 : 4 <> 1.
Axiom neq_4_2 : 4 <> 2.
Axiom neq_4_3 : 4 <> 3.
Axiom neq_4_5 : 4 <> 5.
Axiom neq_5_0 : 5 <> 0.
Axiom neq_5_1 : 5 <> 1.
Axiom neq_5_2 : 5 <> 2.
Axiom neq_5_3 : 5 <> 3.
Axiom neq_5_4 : 5 <> 4.

Axiom cases_1 : forall x :e 1, forall p:set->prop, p 0 -> p x.
Axiom cases_2 : forall x :e 2, forall p:set->prop, p 0 -> p 1 -> p x.
Axiom cases_5 : forall x :e 5, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p x.
Axiom cases_6 : forall x :e 6, forall p:set->prop, p 0 -> p 1 -> p 2 -> p 3 -> p 4 -> p 5 -> p x.

Definition ordinal : set -> prop := fun x => forall y :e x, forall z :e y, z :e x.
Axiom nat_p_ordinal : forall n, nat_p n -> ordinal n.

Definition equip : set -> set -> prop :=
  fun X Y => exists f:set->set,
    (forall x :e X, f x :e Y) /\
    (forall x y :e X, f x = f y -> x = y) /\
    (forall y :e Y, exists x :e X, f x = y).

Axiom equip_ref : forall X, equip X X.
Axiom equip_sym : forall X Y, equip X Y -> equip Y X.
Axiom equip_tra : forall X Y Z, equip X Y -> equip Y Z -> equip X Z.
Axiom equip_0_Empty : forall X, equip 0 X -> X = Empty.
Axiom equip_1_Sing : forall X, equip 1 X -> exists x, X = {x}.
Axiom equip_3_I : forall u v w, u <> v -> u <> w -> v <> w -> equip 3 {u,v,w}.

Definition TwoRamseyProp : set -> set -> set -> prop
 := fun M N V =>
      forall R:set -> set -> prop,
        (forall x y, R x y -> R y x)
       -> ((exists X c= V, equip M X /\ (forall x y :e X, x <> y -> R x y))
        \/ (exists Y c= V, equip N Y /\ (forall x y :e Y, x <> y -> ~R x y))).

Definition is_graph : set -> (set -> set -> prop) -> prop :=
  fun V R => (forall x y :e V, R x y -> R y x) /\ (forall x :e V, ~R x x).

Definition triangle_free : set -> (set -> set -> prop) -> prop :=
  fun V R => forall x y z :e V, R x y -> R y z -> R x z -> False.

Definition is_indep_set : set -> (set -> set -> prop) -> set -> prop :=
  fun V R S => S c= V /\ (forall x y :e S, x <> y -> ~R x y).

Definition no_k_indep : set -> (set -> set -> prop) -> set -> prop :=
  fun V R k => forall S c= V, equip k S -> ~is_indep_set V R S.

Definition degree : set -> (set -> set -> prop) -> set -> set -> prop :=
  fun V R v d => equip d {y :e V | R v y}.

Definition k_regular : set -> (set -> set -> prop) -> set -> prop :=
  fun V R k => forall v :e V, degree V R v k.

Definition common_neighbors : set -> (set -> set -> prop) -> set -> set -> set :=
  fun V R u v => {w :e V | R u w /\ R v w}.

Axiom TwoRamseyProp_3_3_6 : TwoRamseyProp 3 3 6.
Axiom TwoRamseyProp_3_4_9 : TwoRamseyProp 3 4 9.
Axiom TwoRamseyProp_3_5_14 : TwoRamseyProp 3 5 14.

Axiom ordinal_equip_3_E_impred : forall X, equip 3 X ->
  (forall alpha :e X, ordinal alpha) ->
  forall p:prop,
    (forall alpha beta gamma :e X,
      alpha :e beta -> beta :e gamma ->
      (forall y :e X, forall q:set -> prop, q alpha -> q beta -> q gamma -> q y)
      -> p)
    -> p.

Definition bij : set -> set -> (set -> set) -> prop :=
  fun X Y f =>
    (forall x :e X, f x :e Y) /\
    (forall x y :e X, f x = f y -> x = y) /\
    (forall y :e Y, exists x :e X, f x = y).

Axiom bijI : forall X Y f,
  (forall x :e X, f x :e Y) ->
  (forall x y :e X, f x = f y -> x = y) ->
  (forall y :e Y, exists x :e X, f x = y) ->
  bij X Y f.

Parameter If_i : prop -> set -> set -> set.
Axiom If_i_1 : forall p:prop, forall x y:set, p -> If_i p x y = x.
Axiom If_i_0 : forall p:prop, forall x y:set, ~p -> If_i p x y = y.

Parameter Sep: set -> (set -> prop) -> set.
Notation Sep Sep.
Axiom SepI:forall X:set, forall P:(set->prop), forall x:set, x :e X -> P x -> x :e {x :e X|P x}.
Axiom SepE:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X /\ P x.
Axiom SepE1:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> x :e X.
Axiom SepE2:forall X:set, forall P:(set->prop), forall x:set, x :e {x :e X|P x} -> P x.

================================================================================
FILE: cardinality_toolkit.mg (295 lines)
================================================================================
Theorem nat_p_12 : nat_p 12.
exact nat_ordsucc 11 (nat_ordsucc 10 (nat_ordsucc 9 (nat_ordsucc 8 (nat_ordsucc 7
      (nat_ordsucc 6 (nat_ordsucc 5 (nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2))))))))).
Qed.

Theorem nat_p_13 : nat_p 13.
exact nat_ordsucc 12 nat_p_12.
Qed.

Theorem nat_p_17 : nat_p 17.
exact nat_ordsucc 16 (nat_ordsucc 15 (nat_ordsucc 14 (nat_ordsucc 13 nat_p_13))).
Qed.

Theorem equip_17_is_17 : equip 17 17.
exact equip_ref 17.
Qed.

Theorem ordsucc_setminus_singleton_base : forall n:set,
  ordinal n -> ordsucc n :\: {n} = n.
let n.
assume Hn: ordinal n.
prove ordsucc n :\: {n} = n.
apply set_ext.
- prove ordsucc n :\: {n} c= n.
  let x. assume Hx: x :e ordsucc n :\: {n}.
  apply setminusE (ordsucc n) {n} x Hx.
  assume Hx_succ: x :e ordsucc n.
  assume Hx_notn: x /:e {n}.
  apply ordsuccE n x Hx_succ.
  + assume Hx_n: x :e n.
    exact Hx_n.
  + assume Hx_eq: x = n.
    apply Hx_notn.
    prove x :e {n}.
    rewrite Hx_eq.
    exact SingI n.
- prove n c= ordsucc n :\: {n}.
  let x. assume Hx: x :e n.
  apply setminusI (ordsucc n) {n} x.
  + prove x :e ordsucc n.
    exact ordsuccI1 n x Hx.
  + prove x /:e {n}.
    assume Hxn: x :e {n}.
    claim Hxeqn: x = n.
      exact SingE n x Hxn.
    claim Hnn: n :e n.
      rewrite <- Hxeqn at 1.
      exact Hx.
    exact In_irref n Hnn.
Qed.

Theorem equip_17_without_17 : equip 17 (18 :\: {17}).
prove equip 17 (ordsucc 17 :\: {17}).
claim H17ord: ordinal 17.
  exact nat_p_ordinal 17 nat_p_17.
rewrite ordsucc_setminus_singleton_base 17 H17ord.
exact equip_17_is_17.
Qed.

Theorem nat_p_18 : nat_p 18.
exact nat_ordsucc 17 nat_p_17.
Qed.

Theorem In_17_18 : forall x :e 17, x :e 18.
let x. assume Hx: x :e 17.
prove x :e ordsucc 17.
exact ordsuccI1 17 x Hx.
Qed.


Theorem equip_17_without_one : forall v :e 18, equip 17 (18 :\: {v}).
Admitted.

Theorem nat_p_5 : nat_p 5.
exact nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2)).
Qed.

Theorem nat_p_6 : nat_p 6.
exact nat_ordsucc 5 nat_p_5.
Qed.

Theorem in_5_13 : 5 :e 13.
prove 5 :e ordsucc 12.
apply ordsuccI1 12.
prove 5 :e 12.
apply ordsuccI1 11.
prove 5 :e 11.
apply ordsuccI1 10.
prove 5 :e 10.
apply ordsuccI1 9.
prove 5 :e 9.
apply ordsuccI1 8.
prove 5 :e 8.
apply ordsuccI1 7.
prove 5 :e 7.
apply ordsuccI1 6.
prove 5 :e 6.
exact ordsuccI2 5.
Qed.

Theorem Subq_5_13 : 5 c= 13.
let x. assume Hx: x :e 5.
exact nat_trans 13 nat_p_13 5 in_5_13 x Hx.
Qed.

Theorem equip_Subq_exists : forall k n V:set,
  k c= n ->
  equip n V ->
  exists U:set, U c= V /\ equip k U.
let k. let n. let V.
assume Hkn: k c= n.
assume Heq: equip n V.
apply Heq.
let f: set -> set.
assume Hbij: bij n V f.
set T := {f i | i :e k}.
witness T.
prove T c= V /\ equip k T.
apply and3E (forall u :e n, f u :e V) (forall u v :e n, f u = f v -> u = v) (forall w :e V, exists u :e n, f u = w) Hbij (T c= V /\ equip k T).
assume HfV: forall u :e n, f u :e V.
assume Hinj: forall u v :e n, f u = f v -> u = v.
assume Hsurj: forall w :e V, exists u :e n, f u = w.
apply andI (T c= V) (equip k T).
- prove T c= V.
  let y. assume Hy: y :e T.
  apply ReplE_impred k f y Hy (y :e V).
  let i. assume Hi: i :e k.
  assume Hyi: y = f i.
  prove y :e V.
  claim Hin: i :e n. exact Hkn i Hi.
  claim HfiV: f i :e V. exact HfV i Hin.
  exact Hyi (fun a b => b :e V) HfiV.
- prove equip k T.
  prove exists g : set -> set, bij k T g.
  witness f.
  prove bij k T f.
  apply and3I (forall u :e k, f u :e T) (forall u v :e k, f u = f v -> u = v) (forall w :e T, exists u :e k, f u = w).
  + prove forall u :e k, f u :e T.
    let u. assume Hu: u :e k.
    exact ReplI k f u Hu.
  + prove forall u v :e k, f u = f v -> u = v.
    let u. assume Hu: u :e k.
    let v. assume Hv: v :e k.
    assume Hfuv: f u = f v.
    exact Hinj u (Hkn u Hu) v (Hkn v Hv) Hfuv.
  + prove forall w :e T, exists u :e k, f u = w.
    let w. assume Hw: w :e T.
    apply ReplE_impred k f w Hw (exists u :e k, f u = w).
    let i. assume Hi: i :e k.
    assume Hwi: w = f i.
    witness i.
    prove i :e k /\ f i = w.
    claim Hfiw: f i = w.
      prove forall Q: set -> set -> prop, Q (f i) w -> Q w (f i).
      let Q: set -> set -> prop. assume HQ: Q (f i) w.
      exact Hwi (fun a b => Q b a) HQ.
    exact andI (i :e k) (f i = w) Hi Hfiw.
Qed.

Theorem in_6_17 : 6 :e 17.
prove 6 :e ordsucc 16.
apply ordsuccI1 16.
prove 6 :e 16.
apply ordsuccI1 15.
prove 6 :e 15.
apply ordsuccI1 14.
prove 6 :e 14.
apply ordsuccI1 13.
prove 6 :e 13.
apply ordsuccI1 12.
prove 6 :e 12.
apply ordsuccI1 11.
prove 6 :e 11.
apply ordsuccI1 10.
prove 6 :e 10.
apply ordsuccI1 9.
prove 6 :e 9.
apply ordsuccI1 8.
prove 6 :e 8.
apply ordsuccI1 7.
prove 6 :e 7.
exact ordsuccI2 6.
Qed.

Theorem six_subset_17 : 6 c= 17.
let x. assume Hx: x :e 6.
exact nat_trans 17 nat_p_17 6 in_6_17 x Hx.
Qed.

Theorem in_12_17 : 12 :e 17.
prove 12 :e ordsucc 16.
apply ordsuccI1 16.
prove 12 :e 16.
apply ordsuccI1 15.
prove 12 :e 15.
apply ordsuccI1 14.
prove 12 :e 14.
apply ordsuccI1 13.
prove 12 :e 13.
exact ordsuccI2 12.
Qed.

Theorem twelve_subset_17 : 12 c= 17.
let x. assume Hx: x :e 12.
exact nat_trans 17 nat_p_17 12 in_12_17 x Hx.
Qed.

Theorem no_6subset_implies_small : forall N:set, forall n:set,
  nat_p n ->
  equip n N ->
  ~(exists T:set, T c= N /\ equip 6 T) ->
  ~(6 c= n).
let N n.
assume Hn: nat_p n.
assume HeqN: equip n N.
assume Hno6: ~(exists T:set, T c= N /\ equip 6 T).
prove ~(6 c= n).
assume H6n: 6 c= n.
apply Hno6.
prove exists T:set, T c= N /\ equip 6 T.
exact equip_Subq_exists 6 n N H6n HeqN.
Qed.

Theorem has_subset_from_cardinality : forall N:set, forall n:set,
  nat_p n ->
  6 c= n ->
  equip n N ->
  exists T:set, T c= N /\ equip 6 T.
let N n.
assume Hn: nat_p n.
assume H6n: 6 c= n.
assume HeqN: equip n N.
exact equip_Subq_exists 6 n N H6n HeqN.
Qed.

Theorem nat_trichotomy_6 : forall n:set,
  nat_p n -> n :e 6 \/ n = 6 \/ 6 c= n.
let n.
assume Hn: nat_p n.
claim Hord_n: ordinal n.
  exact nat_p_ordinal n Hn.
claim Hord_6: ordinal 6.
  exact nat_p_ordinal 6 nat_p_6.
apply ordinal_In_Or_Subq n 6 Hord_n Hord_6.
- assume Hn6: n :e 6.
  apply (orIL (n :e 6 \/ n = 6) (6 c= n)).
  apply (orIL (n :e 6) (n = 6)).
  exact Hn6.
- assume H6sub: 6 c= n.
  apply (orIR (n :e 6 \/ n = 6) (6 c= n)).
  exact H6sub.
Qed.

Theorem no_6subset_bound_5 : forall N:set, forall n:set,
  nat_p n ->
  equip n N ->
  ~(exists T:set, T c= N /\ equip 6 T) ->
  n :e 6.
let N n.
assume Hn: nat_p n.
assume HeqN: equip n N.
assume Hno6: ~(exists T:set, T c= N /\ equip 6 T).
claim Htri: n :e 6 \/ n = 6 \/ 6 c= n.
  exact nat_trichotomy_6 n Hn.
apply orE (n :e 6 \/ n = 6) (6 c= n) (n :e 6).
- assume Hleft: n :e 6 \/ n = 6.
  apply orE (n :e 6) (n = 6) (n :e 6).
  * assume Hn6: n :e 6.
    exact Hn6.
  * assume Heq6: n = 6.
    apply FalseE.
    apply Hno6.
    prove exists T:set, T c= N /\ equip 6 T.
    witness N.
    apply andI (N c= N) (equip 6 N).
    - exact Subq_ref N.
    - rewrite <- Heq6.
      exact HeqN.
  * exact Hleft.
- assume H6sub: 6 c= n.
  apply FalseE.
  apply Hno6.
  exact equip_Subq_exists 6 n N H6sub HeqN.
- exact Htri.
Qed.

Theorem partition_17_5_implies_12 : forall V N Non:set,
  equip 17 V ->
  N c= V ->
  Non c= V ->
  (forall x :e V, x :e N \/ x :e Non) ->
  (forall x, x :e N -> x /:e Non) ->
  ~(exists T, T c= N /\ equip 6 T) ->
  exists S, S c= Non /\ equip 12 S.
Admitted.

================================================================================
FILE: equip_17_without_one_proof.mg (305 lines)
================================================================================
Theorem eq_sym : forall x y:set, x = y -> y = x.
let x. let y.
assume Hxy: x = y.
prove y = x.
prove forall Q: set -> set -> prop, Q y x -> Q x y.
let Q: set -> set -> prop.
assume Hqyx: Q y x.
exact Hxy (fun a b => Q b a) Hqyx.
Qed.

Theorem nat_p_17 : nat_p 17.
exact nat_ordsucc 16 (nat_ordsucc 15 (nat_ordsucc 14 (nat_ordsucc 13 (nat_ordsucc 12 (nat_ordsucc 11 (nat_ordsucc 10 (nat_ordsucc 9 (nat_ordsucc 8 (nat_ordsucc 7 (nat_ordsucc 6 (nat_ordsucc 5 (nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2)))))))))))))).
Qed.

Theorem ordinal_17 : ordinal 17.
exact nat_p_ordinal 17 nat_p_17.
Qed.

Theorem ordinal_18 : ordinal 18.
exact nat_p_ordinal 18 (nat_ordsucc 17 nat_p_17).
Qed.

Theorem In_17_18 : 17 :e 18.
prove 17 :e ordsucc 17.
exact ordsuccI2 17.
Qed.

Theorem ordsucc_setminus_singleton_base : forall n:set, ordinal n -> ordsucc n :\: {n} = n.
let n.
assume Hn: ordinal n.
prove ordsucc n :\: {n} = n.
apply set_ext.
- prove ordsucc n :\: {n} c= n.
  let x. assume Hx: x :e ordsucc n :\: {n}.
  apply setminusE (ordsucc n) {n} x Hx.
  assume Hx_succ: x :e ordsucc n.
  assume Hx_notn: x /:e {n}.
  apply ordsuccE n x Hx_succ.
  + assume Hx_n: x :e n.
    exact Hx_n.
  + assume Hx_eq: x = n.
    apply Hx_notn.
    prove x :e {n}.
    rewrite Hx_eq.
    exact SingI n.
- prove n c= ordsucc n :\: {n}.
  let x. assume Hx: x :e n.
  apply setminusI (ordsucc n) {n} x.
  + prove x :e ordsucc n.
    exact ordsuccI1 n x Hx.
  + prove x /:e {n}.
    assume Hxn: x :e {n}.
    claim Hxeqn: x = n.
      exact SingE n x Hxn.
    claim Hnn: n :e n.
      rewrite <- Hxeqn at 1.
      exact Hx.
    exact In_irref n Hnn.
Qed.

Theorem equip_17_without_17 : equip 17 (18 :\: {17}).
prove equip 17 (ordsucc 17 :\: {17}).
rewrite ordsucc_setminus_singleton_base 17 ordinal_17.
exact equip_ref 17.
Qed.

Definition shift_at : set -> set -> set := fun v x => if x :e v then x else ordsucc x.

Theorem shift_at_maps_to_succ_minus_v : forall v :e 17, forall x :e 17, shift_at v x :e 18 :\: {v}.
let v. assume Hv: v :e 17.
let x. assume Hx: x :e 17.
prove shift_at v x :e 18 :\: {v}.
prove (if x :e v then x else ordsucc x) :e 18 :\: {v}.
apply xm (x :e v).
- assume Hxv: x :e v.
  claim Hif: (if x :e v then x else ordsucc x) = x.
    exact If_i_1 (x :e v) x (ordsucc x) Hxv.
  rewrite Hif.
  prove x :e 18 :\: {v}.
  apply setminusI 18 {v} x.
  + prove x :e 18.
    exact ordsuccI1 17 x Hx.
  + prove x /:e {v}.
    assume Hxv_sing: x :e {v}.
    claim Hxeqv: x = v.
      exact SingE v x Hxv_sing.
    claim Hvv: v :e v.
      rewrite <- Hxeqv at 1.
      exact Hxv.
    exact In_irref v Hvv.
- assume Hxv_not: x /:e v.
  claim Hif: (if x :e v then x else ordsucc x) = ordsucc x.
    exact If_i_0 (x :e v) x (ordsucc x) Hxv_not.
  rewrite Hif.
  prove ordsucc x :e 18 :\: {v}.
  apply setminusI 18 {v} (ordsucc x).
  + prove ordsucc x :e 18.
    prove ordsucc x :e ordsucc 17.
    exact ordinal_ordsucc_In 17 ordinal_17 x Hx.
  + prove ordsucc x /:e {v}.
    assume Hsx_v: ordsucc x :e {v}.
    claim Hsx_eq_v: ordsucc x = v.
      exact SingE v (ordsucc x) Hsx_v.
    claim Hx_in_v: x :e v.
      exact Hsx_eq_v (fun a b => x :e a) (ordsuccI2 x).
    exact Hxv_not Hx_in_v.
Qed.

Theorem shift_at_injective : forall v :e 17, forall x y :e 17, shift_at v x = shift_at v y -> x = y.
let v. assume Hv: v :e 17.
let x. assume Hx: x :e 17.
let y. assume Hy: y :e 17.
assume Heq: shift_at v x = shift_at v y.
prove x = y.
apply xm (x :e v).
- assume Hxv: x :e v.
  apply xm (y :e v).
  + assume Hyv: y :e v.
    claim Hfx: shift_at v x = x.
      exact If_i_1 (x :e v) x (ordsucc x) Hxv.
    claim Hfy: shift_at v y = y.
      exact If_i_1 (y :e v) y (ordsucc y) Hyv.
    claim Hxy: x = y.
      exact eq_i_tra x (shift_at v x) y (eq_sym (shift_at v x) x Hfx) (eq_i_tra (shift_at v x) (shift_at v y) y Heq Hfy).
    exact Hxy.
  + assume Hyv_not: y /:e v.
    claim Hfx: shift_at v x = x.
      exact If_i_1 (x :e v) x (ordsucc x) Hxv.
    claim Hfy: shift_at v y = ordsucc y.
      exact If_i_0 (y :e v) y (ordsucc y) Hyv_not.
    claim Heq2: x = ordsucc y.
      exact eq_i_tra x (shift_at v x) (ordsucc y) (eq_sym (shift_at v x) x Hfx) (eq_i_tra (shift_at v x) (shift_at v y) (ordsucc y) Heq Hfy).
    claim Hy_in_x: y :e x.
      exact Heq2 (fun a b => y :e b) (ordsuccI2 y).
    claim Hord_v: ordinal v.
      exact nat_p_ordinal v (nat_p_trans 17 nat_p_17 v Hv).
    claim Hord_y: ordinal y.
      exact nat_p_ordinal y (nat_p_trans 17 nat_p_17 y Hy).
    claim Hord_x: ordinal x.
      exact nat_p_ordinal x (nat_p_trans 17 nat_p_17 x Hx).
    claim Hy_in_v: y :e v.
      exact (ordinal_TransSet v Hord_v) x Hxv y Hy_in_x.
    exact FalseE (Hyv_not Hy_in_v) (x = y).
- assume Hxv_not: x /:e v.
  apply xm (y :e v).
  + assume Hyv: y :e v.
    claim Hfx: shift_at v x = ordsucc x.
      exact If_i_0 (x :e v) x (ordsucc x) Hxv_not.
    claim Hfy: shift_at v y = y.
      exact If_i_1 (y :e v) y (ordsucc y) Hyv.
    claim Heq2: ordsucc x = y.
      exact eq_i_tra (ordsucc x) (shift_at v x) y (eq_sym (shift_at v x) (ordsucc x) Hfx) (eq_i_tra (shift_at v x) (shift_at v y) y Heq Hfy).
    claim Hx_in_y: x :e y.
      exact Heq2 (fun a b => x :e a) (ordsuccI2 x).
    claim Hord_v: ordinal v.
      exact nat_p_ordinal v (nat_p_trans 17 nat_p_17 v Hv).
    claim Hx_in_v: x :e v.
      exact (ordinal_TransSet v Hord_v) y Hyv x Hx_in_y.
    exact FalseE (Hxv_not Hx_in_v) (x = y).
  + assume Hyv_not: y /:e v.
    claim Hfx: shift_at v x = ordsucc x.
      exact If_i_0 (x :e v) x (ordsucc x) Hxv_not.
    claim Hfy: shift_at v y = ordsucc y.
      exact If_i_0 (y :e v) y (ordsucc y) Hyv_not.
    claim Heq2: ordsucc x = ordsucc y.
      exact eq_i_tra (ordsucc x) (shift_at v x) (ordsucc y) (eq_sym (shift_at v x) (ordsucc x) Hfx) (eq_i_tra (shift_at v x) (shift_at v y) (ordsucc y) Heq Hfy).
    exact ordsucc_inj x y Heq2.
Qed.

Theorem shift_at_surjective : forall v :e 17, forall z :e 18 :\: {v}, exists x :e 17, shift_at v x = z.
let v. assume Hv: v :e 17.
let z. assume Hz: z :e 18 :\: {v}.
prove exists x :e 17, shift_at v x = z.
claim Hz18: z :e 18.
  exact setminusE1 18 {v} z Hz.
claim Hzv: z /:e {v}.
  exact setminusE2 18 {v} z Hz.
claim Hzneqv: z <> v.
  assume Hzeqv: z = v.
  apply Hzv.
  rewrite Hzeqv.
  exact SingI v.
claim Hord_v: ordinal v.
  exact nat_p_ordinal v (nat_p_trans 17 nat_p_17 v Hv).
claim Hord_z: ordinal z.
  exact nat_p_ordinal z (nat_p_trans 18 (nat_ordsucc 17 nat_p_17) z Hz18).
apply xm (z :e v).
- assume Hzv_in: z :e v.
  witness z.
  apply andI (z :e 17) (shift_at v z = z).
  + prove z :e 17.
    exact nat_trans 17 nat_p_17 v Hv z Hzv_in.
  + prove shift_at v z = z.
    prove (if z :e v then z else ordsucc z) = z.
    exact If_i_1 (z :e v) z (ordsucc z) Hzv_in.
- assume Hzv_not: z /:e v.
  claim Hz_gt_v: v :e z \/ v = z.
  {
    apply ordinal_In_Or_Subq v z Hord_v Hord_z.
    - assume Hvz: v :e z.
      exact orIL (v :e z) (v = z) Hvz.
    - assume Hzv_sub: z c= v.
      apply xm (v = z).
      + assume Heq: v = z.
        exact orIR (v :e z) (v = z) Heq.
      + assume Hneq: v <> z.
        apply ordinal_In_Or_Subq z v Hord_z Hord_v.
        * assume Hzv': z :e v. exact FalseE (Hzv_not Hzv') (v :e z \/ v = z).
        * assume Hvz_sub: v c= z.
          apply orIR (v :e z) (v = z).
          exact set_ext v z Hvz_sub Hzv_sub.
  }
  apply Hz_gt_v.
  + assume Hvz: v :e z.
    claim Hz_nat: nat_p z.
      exact nat_p_trans 18 (nat_ordsucc 17 nat_p_17) z Hz18.
    claim Hz_inv: z = 0 \/ exists x:set, nat_p x /\ z = ordsucc x.
      exact nat_inv z Hz_nat.
    apply Hz_inv.
    + assume Hz0: z = 0.
      claim Hv0: v :e 0.
        exact Hz0 (fun a b => v :e a) Hvz.
      exact FalseE (EmptyE v Hv0) (exists x :e 17, shift_at v x = z).
    + assume Hz_ex: exists x:set, nat_p x /\ z = ordsucc x.
      apply Hz_ex.
      let w. assume Hw: nat_p w /\ z = ordsucc w.
      apply Hw.
      assume Hw_nat: nat_p w.
      assume Hweq: z = ordsucc w.
      claim Hwz: w :e z.
        exact (eq_sym z (ordsucc w) Hweq) (fun a b => w :e a) (ordsuccI2 w).
      witness w.
      apply andI (w :e 17) (shift_at v w = z).
      - prove w :e 17.
        claim Hw18: ordsucc w :e 18.
          exact Hweq (fun a b => a :e 18) Hz18.
        apply ordsuccE 17 (ordsucc w) Hw18.
        * assume Hsw17: ordsucc w :e 17.
          exact nat_trans 17 nat_p_17 (ordsucc w) Hsw17 w (ordsuccI2 w).
        * assume Hsw_eq: ordsucc w = 17.
          exact ordsucc_inj w 16 Hsw_eq (fun a b => b :e 17) (ordsuccI2 16).
      - prove shift_at v w = z.
        prove (if w :e v then w else ordsucc w) = z.
        claim Hw_notin_v: w /:e v.
        {
          assume Hwv: w :e v.
          claim Hord_sw: ordinal (ordsucc w).
            exact ordinal_ordsucc w (nat_p_ordinal w (nat_p_trans z Hord_z w Hwz)).
          claim Hsw_in_v: ordsucc w :e v \/ ordsucc w = v.
          {
            apply ordinal_In_Or_Subq (ordsucc w) v Hord_sw Hord_v.
            - assume Hswv: ordsucc w :e v.
              exact orIL (ordsucc w :e v) (ordsucc w = v) Hswv.
            - assume Hv_sw: v c= ordsucc w.
              apply orIR (ordsucc w :e v) (ordsucc w = v).
              claim Hsw_sub_v: ordsucc w c= v.
              {
                let y. assume Hy: y :e ordsucc w.
                apply ordsuccE w y Hy.
                + assume Hyw: y :e w.
                  exact (ordinal_TransSet v Hord_v) w Hwv y Hyw.
                + assume Hyeqw: y = w.
                  exact Hyeqw (fun a b => b :e v) Hwv.
              }
              exact set_ext (ordsucc w) v Hsw_sub_v Hv_sw.
          }
          apply Hsw_in_v.
          - assume Hswv: ordsucc w :e v.
            claim Hzv': z :e v.
              exact Hweq (fun a b => b :e v) Hswv.
            exact Hzv_not Hzv'.
          - assume Hsweqv: ordsucc w = v.
            claim Hzeqv': z = v.
              exact eq_i_tra z (ordsucc w) v Hweq Hsweqv.
            exact Hzneqv Hzeqv'.
        }
        claim Hif_val: (if w :e v then w else ordsucc w) = ordsucc w.
          exact If_i_0 (w :e v) w (ordsucc w) Hw_notin_v.
        exact eq_i_tra (if w :e v then w else ordsucc w) (ordsucc w) z Hif_val (eq_sym z (ordsucc w) Hweq).
  + assume Hveqz: v = z.
    apply FalseE.
    exact Hzneqv (eq_sym v z Hveqz).
Qed.

Theorem equip_17_without_v_small : forall v :e 17, equip 17 (18 :\: {v}).
let v. assume Hv: v :e 17.
prove equip 17 (18 :\: {v}).
prove exists f:set->set, (forall x :e 17, f x :e 18 :\: {v}) /\ (forall x y :e 17, f x = f y -> x = y) /\ (forall z :e 18 :\: {v}, exists x :e 17, f x = z).
witness (shift_at v).
apply and3I (forall x :e 17, shift_at v x :e 18 :\: {v}) (forall x y :e 17, shift_at v x = shift_at v y -> x = y) (forall z :e 18 :\: {v}, exists x :e 17, shift_at v x = z).
- exact shift_at_maps_to_succ_minus_v v Hv.
- exact shift_at_injective v Hv.
- exact shift_at_surjective v Hv.
Qed.

Theorem equip_17_without_one : forall v :e 18, equip 17 (18 :\: {v}).
let v. assume Hv: v :e 18.
prove equip 17 (18 :\: {v}).
apply ordsuccE 17 v Hv.
- assume Hv17: v :e 17.
  exact equip_17_without_v_small v Hv17.
- assume Hv_eq_17: v = 17.
  rewrite Hv_eq_17.
  exact equip_17_without_17.
Qed.

================================================================================
FILE: good_graph_proof.mg (1211 lines)
================================================================================
Definition triangle_free : set -> (set -> set -> prop) -> prop :=
  fun V R => forall x :e V, forall y :e V, forall z :e V, R x y -> R y z -> R x z -> False.

Definition is_indep_set : set -> (set -> set -> prop) -> set -> prop :=
  fun V R S => S c= V /\ (forall x :e S, forall y :e S, x <> y -> ~R x y).

Definition no_k_indep : set -> (set -> set -> prop) -> set -> prop :=
  fun V R k => forall S, S c= V -> equip k S -> ~is_indep_set V R S.

Theorem equip_subset : forall n k U:set,
  k c= n ->
  equip n U ->
  exists T:set, T c= U /\ equip k T.
let n. let k. let U.
assume Hkn: k c= n.
assume Heq: equip n U.
apply Heq.
let f: set -> set.
assume Hbij: bij n U f.
set T := {f i | i :e k}.
witness T.
prove T c= U /\ equip k T.
apply and3E (forall u :e n, f u :e U) (forall u v :e n, f u = f v -> u = v) (forall w :e U, exists u :e n, f u = w) Hbij (T c= U /\ equip k T).
assume HfU: forall u :e n, f u :e U.
assume Hinj: forall u v :e n, f u = f v -> u = v.
assume Hsurj: forall w :e U, exists u :e n, f u = w.
apply andI (T c= U) (equip k T).
- prove T c= U.
  let y. assume Hy: y :e T.
  apply ReplE_impred k f y Hy (y :e U).
  let i. assume Hi: i :e k.
  assume Hyi: y = f i.
  prove y :e U.
  claim Hin: i :e n. exact Hkn i Hi.
  claim HfiU: f i :e U. exact HfU i Hin.
  exact Hyi (fun a b => b :e U) HfiU.
- prove equip k T.
  prove exists g : set -> set, bij k T g.
  witness f.
  prove bij k T f.
  apply and3I (forall u :e k, f u :e T) (forall u v :e k, f u = f v -> u = v) (forall w :e T, exists u :e k, f u = w).
  + prove forall u :e k, f u :e T.
    let u. assume Hu: u :e k.
    exact ReplI k f u Hu.
  + prove forall u v :e k, f u = f v -> u = v.
    let u. assume Hu: u :e k.
    let v. assume Hv: v :e k.
    assume Hfuv: f u = f v.
    exact Hinj u (Hkn u Hu) v (Hkn v Hv) Hfuv.
  + prove forall w :e T, exists u :e k, f u = w.
    let w. assume Hw: w :e T.
    apply ReplE_impred k f w Hw (exists u :e k, f u = w).
    let i. assume Hi: i :e k.
    assume Hwi: w = f i.
    witness i.
    prove i :e k /\ f i = w.
    claim Hfiw: f i = w.
      prove forall Q: set -> set -> prop, Q (f i) w -> Q w (f i).
      let Q: set -> set -> prop. assume HQ: Q (f i) w.
      exact Hwi (fun a b => Q b a) HQ.
    exact andI (i :e k) (f i = w) Hi Hfiw.
Qed.

Theorem neighborhood_indep : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free V R ->
  forall v :e V, forall a b :e V, R v a -> R v b -> a <> b -> ~R a b.
let V. let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free V R.
let v. assume Hv: v :e V.
let a. assume Ha: a :e V.
let b. assume Hb: b :e V.
assume Hva: R v a.
assume Hvb: R v b.
assume Hab_neq: a <> b.
assume Hab: R a b.
prove False.
apply Htf v Hv a Ha b Hb.
- exact Hva.
- exact Hab.
- exact Hvb.
Qed.

Theorem degree_bound_6 : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free V R ->
  no_k_indep V R 6 ->
  forall v :e V, forall S, S c= V -> equip 6 S ->
    (forall x :e S, R v x) -> (forall x :e S, v <> x) -> False.
let V. let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free V R.
assume Hno6: no_k_indep V R 6.
let v. assume Hv: v :e V.
let S. assume HSV: S c= V. assume HS6: equip 6 S.
assume Hadj: forall x :e S, R v x.
assume Hneqv: forall x :e S, v <> x.
prove False.
apply Hno6 S HSV HS6.
prove is_indep_set V R S.
prove S c= V /\ (forall x :e S, forall y :e S, x <> y -> ~R x y).
apply andI (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y).
- exact HSV.
- prove forall x :e S, forall y :e S, x <> y -> ~R x y.
  let x. assume HxS: x :e S.
  let y. assume HyS: y :e S.
  assume Hneq: x <> y.
  exact neighborhood_indep V R Hsym Htf v Hv x (HSV x HxS) y (HSV y HyS)
        (Hadj x HxS) (Hadj y HyS) Hneq.
Qed.

Theorem non_neighbors_triangle_free : forall V:set, forall R:set -> set -> prop,
  triangle_free V R ->
  forall T:set, T c= V ->
  triangle_free T R.
let V. let R: set -> set -> prop.
assume Htf: triangle_free V R.
let T. assume HTV: T c= V.
prove triangle_free T R.
prove forall x :e T, forall y :e T, forall z :e T, R x y -> R y z -> R x z -> False.
let x. assume Hx: x :e T.
let y. assume Hy: y :e T.
let z. assume Hz: z :e T.
assume Rxy: R x y.
assume Ryz: R y z.
assume Rxz: R x z.
exact Htf x (HTV x Hx) y (HTV y Hy) z (HTV z Hz) Rxy Ryz Rxz.
Qed.

Theorem indep_subset_extends : forall V:set, forall R:set -> set -> prop, forall S T:set,
  is_indep_set V R S ->
  T c= S ->
  is_indep_set V R T.
let V. let R: set -> set -> prop. let S. let T.
assume HS: is_indep_set V R S.
assume HTS: T c= S.
prove is_indep_set V R T.
prove T c= V /\ (forall x :e T, forall y :e T, x <> y -> ~R x y).
claim HSV: S c= V.
  exact andEL (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y) HS.
claim HSindep: forall x :e S, forall y :e S, x <> y -> ~R x y.
  exact andER (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y) HS.
apply andI (T c= V) (forall x :e T, forall y :e T, x <> y -> ~R x y).
- prove T c= V.
  let t. assume Ht: t :e T.
  exact HSV t (HTS t Ht).
- prove forall x :e T, forall y :e T, x <> y -> ~R x y.
  let x. assume Hx: x :e T.
  let y. assume Hy: y :e T.
  assume Hneq: x <> y.
  exact HSindep x (HTS x Hx) y (HTS y Hy) Hneq.
Qed.

Theorem indep_add_vertex : forall V:set, forall R:set -> set -> prop, forall S:set, forall v:set,
  is_indep_set V R S ->
  v :e V ->
  v /:e S ->
  (forall x :e S, ~R v x) ->
  (forall x :e S, ~R x v) ->
  is_indep_set V R (S :\/: {v}).
let V. let R: set -> set -> prop. let S. let v.
assume HS: is_indep_set V R S.
assume HvV: v :e V.
assume HvnotS: v /:e S.
assume Hvnonadj: forall x :e S, ~R v x.
assume Hnonadjv: forall x :e S, ~R x v.
prove is_indep_set V R (S :\/: {v}).
prove (S :\/: {v}) c= V /\ (forall x :e (S :\/: {v}), forall y :e (S :\/: {v}), x <> y -> ~R x y).
claim HSV: S c= V.
  exact andEL (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y) HS.
claim HSindep: forall x :e S, forall y :e S, x <> y -> ~R x y.
  exact andER (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y) HS.
apply andI ((S :\/: {v}) c= V) (forall x :e (S :\/: {v}), forall y :e (S :\/: {v}), x <> y -> ~R x y).
- prove (S :\/: {v}) c= V.
  let z. assume Hz: z :e S :\/: {v}.
  apply binunionE S {v} z Hz.
  + assume HzS: z :e S.
    exact HSV z HzS.
  + assume Hzv: z :e {v}.
    claim Hzeqv: z = v. exact SingE v z Hzv.
    rewrite Hzeqv.
    exact HvV.
- prove forall x :e (S :\/: {v}), forall y :e (S :\/: {v}), x <> y -> ~R x y.
  let x. assume Hx: x :e S :\/: {v}.
  let y. assume Hy: y :e S :\/: {v}.
  assume Hneq: x <> y.
  prove ~R x y.
  assume Hxy: R x y.
  apply binunionE S {v} x Hx.
  + assume HxS: x :e S.
    apply binunionE S {v} y Hy.
    * assume HyS: y :e S.
      apply HSindep x HxS y HyS Hneq.
      exact Hxy.
    * assume Hyv: y :e {v}.
      claim Hyeqv: y = v. exact SingE v y Hyv.
      apply Hnonadjv x HxS.
      rewrite <- Hyeqv.
      exact Hxy.
  + assume Hxv: x :e {v}.
    claim Hxeqv: x = v. exact SingE v x Hxv.
    apply binunionE S {v} y Hy.
    * assume HyS: y :e S.
      apply Hvnonadj y HyS.
      rewrite <- Hxeqv.
      exact Hxy.
    * assume Hyv: y :e {v}.
      claim Hyeqv: y = v. exact SingE v y Hyv.
      claim Hveqy: v = y.
        prove forall Q: set -> set -> prop, Q v y -> Q y v.
        let Q: set -> set -> prop. assume HQ: Q v y.
        exact Hyeqv (fun a b => Q b a) HQ.
      apply Hneq.
      prove x = y.
      exact eq_i_tra x v y Hxeqv Hveqy.
Qed.

Theorem neighbors_form_indep : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free V R ->
  forall v :e V, forall S:set,
    S c= V -> (forall x :e S, R v x) -> (forall x :e S, forall y :e S, x <> y -> ~R x y).
let V. let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free V R.
let v. assume Hv: v :e V.
let S. assume HSV: S c= V.
assume Hadj: forall x :e S, R v x.
let x. assume Hx: x :e S.
let y. assume Hy: y :e S.
assume Hneq: x <> y.
exact neighborhood_indep V R Hsym Htf v Hv x (HSV x Hx) y (HSV y Hy)
      (Hadj x Hx) (Hadj y Hy) Hneq.
Qed.

Theorem equip_4_quad : forall a b c d: set,
  a <> b -> a <> c -> a <> d -> b <> c -> b <> d -> c <> d ->
  equip 4 (({a, b} :\/: {c}) :\/: {d}).
let a. let b. let c. let d.
assume Hab: a <> b. assume Hac: a <> c. assume Had: a <> d.
assume Hbc: b <> c. assume Hbd: b <> d. assume Hcd: c <> d.
set S := ({a, b} :\/: {c}) :\/: {d}.
set f := fun n:set => if n = 0 then a else (if n = 1 then b else (if n = 2 then c else d)).
claim H00: 0 = 0. prove forall Q: set -> set -> prop, Q 0 0 -> Q 0 0. let Q. assume HQ. exact HQ.
claim H11: 1 = 1. prove forall Q: set -> set -> prop, Q 1 1 -> Q 1 1. let Q. assume HQ. exact HQ.
claim H22: 2 = 2. prove forall Q: set -> set -> prop, Q 2 2 -> Q 2 2. let Q. assume HQ. exact HQ.
claim H33: 3 = 3. prove forall Q: set -> set -> prop, Q 3 3 -> Q 3 3. let Q. assume HQ. exact HQ.
claim Hf0: f 0 = a. exact If_i_1 (0 = 0) a (if 0 = 1 then b else (if 0 = 2 then c else d)) H00.
claim Hf1: f 1 = b.
  claim Hstep1: (if 1 = 0 then a else (if 1 = 1 then b else (if 1 = 2 then c else d))) = (if 1 = 1 then b else (if 1 = 2 then c else d)).
    exact If_i_0 (1 = 0) a (if 1 = 1 then b else (if 1 = 2 then c else d)) neq_1_0.
  claim Hstep2: (if 1 = 1 then b else (if 1 = 2 then c else d)) = b. exact If_i_1 (1 = 1) b (if 1 = 2 then c else d) H11.
  exact eq_i_tra (if 1 = 0 then a else (if 1 = 1 then b else (if 1 = 2 then c else d))) (if 1 = 1 then b else (if 1 = 2 then c else d)) b Hstep1 Hstep2.
claim Hf2: f 2 = c.
  claim Hstep1: (if 2 = 0 then a else (if 2 = 1 then b else (if 2 = 2 then c else d))) = (if 2 = 1 then b else (if 2 = 2 then c else d)).
    exact If_i_0 (2 = 0) a (if 2 = 1 then b else (if 2 = 2 then c else d)) neq_2_0.
  claim Hstep2: (if 2 = 1 then b else (if 2 = 2 then c else d)) = (if 2 = 2 then c else d). exact If_i_0 (2 = 1) b (if 2 = 2 then c else d) neq_2_1.
  claim Hstep3: (if 2 = 2 then c else d) = c. exact If_i_1 (2 = 2) c d H22.
  claim Hmid: (if 2 = 0 then a else (if 2 = 1 then b else (if 2 = 2 then c else d))) = (if 2 = 2 then c else d).
    exact eq_i_tra (if 2 = 0 then a else (if 2 = 1 then b else (if 2 = 2 then c else d))) (if 2 = 1 then b else (if 2 = 2 then c else d)) (if 2 = 2 then c else d) Hstep1 Hstep2.
  exact eq_i_tra (if 2 = 0 then a else (if 2 = 1 then b else (if 2 = 2 then c else d))) (if 2 = 2 then c else d) c Hmid Hstep3.
claim Hf3: f 3 = d.
  claim Hstep1: (if 3 = 0 then a else (if 3 = 1 then b else (if 3 = 2 then c else d))) = (if 3 = 1 then b else (if 3 = 2 then c else d)).
    exact If_i_0 (3 = 0) a (if 3 = 1 then b else (if 3 = 2 then c else d)) neq_3_0.
  claim Hstep2: (if 3 = 1 then b else (if 3 = 2 then c else d)) = (if 3 = 2 then c else d). exact If_i_0 (3 = 1) b (if 3 = 2 then c else d) neq_3_1.
  claim Hstep3: (if 3 = 2 then c else d) = d. exact If_i_0 (3 = 2) c d neq_3_2.
  claim Hmid: (if 3 = 0 then a else (if 3 = 1 then b else (if 3 = 2 then c else d))) = (if 3 = 2 then c else d).
    exact eq_i_tra (if 3 = 0 then a else (if 3 = 1 then b else (if 3 = 2 then c else d))) (if 3 = 1 then b else (if 3 = 2 then c else d)) (if 3 = 2 then c else d) Hstep1 Hstep2.
  exact eq_i_tra (if 3 = 0 then a else (if 3 = 1 then b else (if 3 = 2 then c else d))) (if 3 = 2 then c else d) d Hmid Hstep3.
claim HaS: a :e S. apply binunionI1 ({a, b} :\/: {c}) {d} a. apply binunionI1 {a, b} {c} a. exact UPairI1 a b.
claim Hf0S: f 0 :e S. exact Hf0 (fun x y => y :e S) HaS.
claim HbS: b :e S. apply binunionI1 ({a, b} :\/: {c}) {d} b. apply binunionI1 {a, b} {c} b. exact UPairI2 a b.
claim Hf1S: f 1 :e S. exact Hf1 (fun x y => y :e S) HbS.
claim HcS: c :e S. apply binunionI1 ({a, b} :\/: {c}) {d} c. apply binunionI2 {a, b} {c} c. exact SingI c.
claim Hf2S: f 2 :e S. exact Hf2 (fun x y => y :e S) HcS.
claim HdS: d :e S. apply binunionI2 ({a, b} :\/: {c}) {d} d. exact SingI d.
claim Hf3S: f 3 :e S. exact Hf3 (fun x y => y :e S) HdS.
prove equip 4 S.
prove exists g : set -> set, bij 4 S g.
witness f.
prove bij 4 S f.
apply and3I (forall u :e 4, f u :e S) (forall u v :e 4, f u = f v -> u = v) (forall w :e S, exists u :e 4, f u = w).
- let u. assume Hu: u :e 4. exact cases_4 u Hu (fun i => f i :e S) Hf0S Hf1S Hf2S Hf3S.
- let u. assume Hu: u :e 4. let v. assume Hv: v :e 4. assume Hfuv: f u = f v.
  claim Hcase0: f 0 = f v -> 0 = v.
    assume H0v: f 0 = f v.
    claim Hcase00: f 0 = f 0 -> 0 = 0. assume HH. exact H00.
    claim Hcase01: f 0 = f 1 -> 0 = 1.
      assume H01: f 0 = f 1. prove False.
      claim Ha_eq_b: a = b. claim H3: a = f 0. prove forall Q: set -> set -> prop, Q a (f 0) -> Q (f 0) a. let Q. assume HQ. exact Hf0 (fun x y => Q y x) HQ.
        claim H4: f 0 = b. exact eq_i_tra (f 0) (f 1) b H01 Hf1. exact eq_i_tra a (f 0) b H3 H4.
      exact Hab Ha_eq_b.
    claim Hcase02: f 0 = f 2 -> 0 = 2.
      assume H02: f 0 = f 2. prove False.
      claim Ha_eq_c: a = c. claim H3: a = f 0. prove forall Q: set -> set -> prop, Q a (f 0) -> Q (f 0) a. let Q. assume HQ. exact Hf0 (fun x y => Q y x) HQ.
        claim H4: f 0 = c. exact eq_i_tra (f 0) (f 2) c H02 Hf2. exact eq_i_tra a (f 0) c H3 H4.
      exact Hac Ha_eq_c.
    claim Hcase03: f 0 = f 3 -> 0 = 3.
      assume H03: f 0 = f 3. prove False.
      claim Ha_eq_d: a = d. claim H3: a = f 0. prove forall Q: set -> set -> prop, Q a (f 0) -> Q (f 0) a. let Q. assume HQ. exact Hf0 (fun x y => Q y x) HQ.
        claim H4: f 0 = d. exact eq_i_tra (f 0) (f 3) d H03 Hf3. exact eq_i_tra a (f 0) d H3 H4.
      exact Had Ha_eq_d.
    exact cases_4 v Hv (fun j => f 0 = f j -> 0 = j) Hcase00 Hcase01 Hcase02 Hcase03 H0v.
  claim Hcase1: f 1 = f v -> 1 = v.
    assume H1v: f 1 = f v.
    claim Hcase10: f 1 = f 0 -> 1 = 0.
      assume H10: f 1 = f 0. prove False.
      claim Hb_eq_a: b = a. claim H3: b = f 1. prove forall Q: set -> set -> prop, Q b (f 1) -> Q (f 1) b. let Q. assume HQ. exact Hf1 (fun x y => Q y x) HQ.
        claim H4: f 1 = a. exact eq_i_tra (f 1) (f 0) a H10 Hf0. exact eq_i_tra b (f 1) a H3 H4.
      claim Ha_eq_b: a = b. prove forall Q: set -> set -> prop, Q a b -> Q b a. let Q. assume HQ. exact Hb_eq_a (fun x y => Q y x) HQ.
      exact Hab Ha_eq_b.
    claim Hcase11: f 1 = f 1 -> 1 = 1. assume HH. exact H11.
    claim Hcase12: f 1 = f 2 -> 1 = 2.
      assume H12: f 1 = f 2. prove False.
      claim Hb_eq_c: b = c. claim H3: b = f 1. prove forall Q: set -> set -> prop, Q b (f 1) -> Q (f 1) b. let Q. assume HQ. exact Hf1 (fun x y => Q y x) HQ.
        claim H4: f 1 = c. exact eq_i_tra (f 1) (f 2) c H12 Hf2. exact eq_i_tra b (f 1) c H3 H4.
      exact Hbc Hb_eq_c.
    claim Hcase13: f 1 = f 3 -> 1 = 3.
      assume H13: f 1 = f 3. prove False.
      claim Hb_eq_d: b = d. claim H3: b = f 1. prove forall Q: set -> set -> prop, Q b (f 1) -> Q (f 1) b. let Q. assume HQ. exact Hf1 (fun x y => Q y x) HQ.
        claim H4: f 1 = d. exact eq_i_tra (f 1) (f 3) d H13 Hf3. exact eq_i_tra b (f 1) d H3 H4.
      exact Hbd Hb_eq_d.
    exact cases_4 v Hv (fun j => f 1 = f j -> 1 = j) Hcase10 Hcase11 Hcase12 Hcase13 H1v.
  claim Hcase2: f 2 = f v -> 2 = v.
    assume H2v: f 2 = f v.
    claim Hcase20: f 2 = f 0 -> 2 = 0.
      assume H20: f 2 = f 0. prove False.
      claim Hc_eq_a: c = a. claim H3: c = f 2. prove forall Q: set -> set -> prop, Q c (f 2) -> Q (f 2) c. let Q. assume HQ. exact Hf2 (fun x y => Q y x) HQ.
        claim H4: f 2 = a. exact eq_i_tra (f 2) (f 0) a H20 Hf0. exact eq_i_tra c (f 2) a H3 H4.
      claim Ha_eq_c: a = c. prove forall Q: set -> set -> prop, Q a c -> Q c a. let Q. assume HQ. exact Hc_eq_a (fun x y => Q y x) HQ.
      exact Hac Ha_eq_c.
    claim Hcase21: f 2 = f 1 -> 2 = 1.
      assume H21: f 2 = f 1. prove False.
      claim Hc_eq_b: c = b. claim H3: c = f 2. prove forall Q: set -> set -> prop, Q c (f 2) -> Q (f 2) c. let Q. assume HQ. exact Hf2 (fun x y => Q y x) HQ.
        claim H4: f 2 = b. exact eq_i_tra (f 2) (f 1) b H21 Hf1. exact eq_i_tra c (f 2) b H3 H4.
      claim Hb_eq_c: b = c. prove forall Q: set -> set -> prop, Q b c -> Q c b. let Q. assume HQ. exact Hc_eq_b (fun x y => Q y x) HQ.
      exact Hbc Hb_eq_c.
    claim Hcase22: f 2 = f 2 -> 2 = 2. assume HH. exact H22.
    claim Hcase23: f 2 = f 3 -> 2 = 3.
      assume H23: f 2 = f 3. prove False.
      claim Hc_eq_d: c = d. claim H3: c = f 2. prove forall Q: set -> set -> prop, Q c (f 2) -> Q (f 2) c. let Q. assume HQ. exact Hf2 (fun x y => Q y x) HQ.
        claim H4: f 2 = d. exact eq_i_tra (f 2) (f 3) d H23 Hf3. exact eq_i_tra c (f 2) d H3 H4.
      exact Hcd Hc_eq_d.
    exact cases_4 v Hv (fun j => f 2 = f j -> 2 = j) Hcase20 Hcase21 Hcase22 Hcase23 H2v.
  claim Hcase3: f 3 = f v -> 3 = v.
    assume H3v: f 3 = f v.
    claim Hcase30: f 3 = f 0 -> 3 = 0.
      assume H30: f 3 = f 0. prove False.
      claim Hd_eq_a: d = a. claim H3: d = f 3. prove forall Q: set -> set -> prop, Q d (f 3) -> Q (f 3) d. let Q. assume HQ. exact Hf3 (fun x y => Q y x) HQ.
        claim H4: f 3 = a. exact eq_i_tra (f 3) (f 0) a H30 Hf0. exact eq_i_tra d (f 3) a H3 H4.
      claim Ha_eq_d: a = d. prove forall Q: set -> set -> prop, Q a d -> Q d a. let Q. assume HQ. exact Hd_eq_a (fun x y => Q y x) HQ.
      exact Had Ha_eq_d.
    claim Hcase31: f 3 = f 1 -> 3 = 1.
      assume H31: f 3 = f 1. prove False.
      claim Hd_eq_b: d = b. claim H3: d = f 3. prove forall Q: set -> set -> prop, Q d (f 3) -> Q (f 3) d. let Q. assume HQ. exact Hf3 (fun x y => Q y x) HQ.
        claim H4: f 3 = b. exact eq_i_tra (f 3) (f 1) b H31 Hf1. exact eq_i_tra d (f 3) b H3 H4.
      claim Hb_eq_d: b = d. prove forall Q: set -> set -> prop, Q b d -> Q d b. let Q. assume HQ. exact Hd_eq_b (fun x y => Q y x) HQ.
      exact Hbd Hb_eq_d.
    claim Hcase32: f 3 = f 2 -> 3 = 2.
      assume H32: f 3 = f 2. prove False.
      claim Hd_eq_c: d = c. claim H3: d = f 3. prove forall Q: set -> set -> prop, Q d (f 3) -> Q (f 3) d. let Q. assume HQ. exact Hf3 (fun x y => Q y x) HQ.
        claim H4: f 3 = c. exact eq_i_tra (f 3) (f 2) c H32 Hf2. exact eq_i_tra d (f 3) c H3 H4.
      claim Hc_eq_d: c = d. prove forall Q: set -> set -> prop, Q c d -> Q d c. let Q. assume HQ. exact Hd_eq_c (fun x y => Q y x) HQ.
      exact Hcd Hc_eq_d.
    claim Hcase33: f 3 = f 3 -> 3 = 3. assume HH. exact H33.
    exact cases_4 v Hv (fun j => f 3 = f j -> 3 = j) Hcase30 Hcase31 Hcase32 Hcase33 H3v.
  exact cases_4 u Hu (fun i => f i = f v -> i = v) Hcase0 Hcase1 Hcase2 Hcase3 Hfuv.
- let w. assume Hw: w :e S.
  claim Hcasea: w = a -> exists u :e 4, f u = w.
    assume Hwa: w = a. witness 0.
    claim Haw: a = w. prove forall Q: set -> set -> prop, Q a w -> Q w a. let Q. assume HQ. exact Hwa (fun x y => Q y x) HQ.
    exact andI (0 :e 4) (f 0 = w) In_0_4 (eq_i_tra (f 0) a w Hf0 Haw).
  claim Hcaseb: w = b -> exists u :e 4, f u = w.
    assume Hwb: w = b. witness 1.
    claim Hbw: b = w. prove forall Q: set -> set -> prop, Q b w -> Q w b. let Q. assume HQ. exact Hwb (fun x y => Q y x) HQ.
    exact andI (1 :e 4) (f 1 = w) In_1_4 (eq_i_tra (f 1) b w Hf1 Hbw).
  claim Hcasec: w = c -> exists u :e 4, f u = w.
    assume Hwc: w = c. witness 2.
    claim Hcw: c = w. prove forall Q: set -> set -> prop, Q c w -> Q w c. let Q. assume HQ. exact Hwc (fun x y => Q y x) HQ.
    exact andI (2 :e 4) (f 2 = w) In_2_4 (eq_i_tra (f 2) c w Hf2 Hcw).
  claim Hcased: w = d -> exists u :e 4, f u = w.
    assume Hwd: w = d. witness 3.
    claim Hdw: d = w. prove forall Q: set -> set -> prop, Q d w -> Q w d. let Q. assume HQ. exact Hwd (fun x y => Q y x) HQ.
    exact andI (3 :e 4) (f 3 = w) In_3_4 (eq_i_tra (f 3) d w Hf3 Hdw).
  apply binunionE ({a, b} :\/: {c}) {d} w Hw.
  + assume Hwabc: w :e ({a, b} :\/: {c}).
    apply binunionE {a, b} {c} w Hwabc.
    * assume Hwab: w :e {a, b}. apply UPairE w a b Hwab. exact Hcasea. exact Hcaseb.
    * assume Hwc: w :e {c}. exact Hcasec (SingE c w Hwc).
  + assume Hwd: w :e {d}. exact Hcased (SingE d w Hwd).
Qed.

Theorem four_neighbors_give_4indep : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free V R ->
  forall v :e V, forall n1 n2 n3 n4 :e V,
    n1 <> n2 -> n1 <> n3 -> n1 <> n4 -> n2 <> n3 -> n2 <> n4 -> n3 <> n4 ->
    R v n1 -> R v n2 -> R v n3 -> R v n4 ->
    exists S, S c= V /\ equip 4 S /\ is_indep_set V R S.
let V. let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free V R.
let v. assume Hv: v :e V.
let n1. assume Hn1: n1 :e V.
let n2. assume Hn2: n2 :e V.
let n3. assume Hn3: n3 :e V.
let n4. assume Hn4: n4 :e V.
assume H12: n1 <> n2. assume H13: n1 <> n3. assume H14: n1 <> n4.
assume H23: n2 <> n3. assume H24: n2 <> n4. assume H34: n3 <> n4.
assume Rv1: R v n1. assume Rv2: R v n2. assume Rv3: R v n3. assume Rv4: R v n4.
set S := ({n1, n2} :\/: {n3}) :\/: {n4}.
witness S.
apply and3I (S c= V) (equip 4 S) (is_indep_set V R S).
- prove S c= V.
  let w. assume Hw: w :e S.
  apply binunionE ({n1, n2} :\/: {n3}) {n4} w Hw.
  + assume Hw123: w :e ({n1, n2} :\/: {n3}).
    apply binunionE {n1, n2} {n3} w Hw123.
    * assume Hw12: w :e {n1, n2}.
      apply UPairE w n1 n2 Hw12.
      - assume Hwn1: w = n1. exact Hwn1 (fun a b => b :e V) Hn1.
      - assume Hwn2: w = n2. exact Hwn2 (fun a b => b :e V) Hn2.
    * assume Hw3: w :e {n3}. claim Hwn3: w = n3. exact SingE n3 w Hw3. exact Hwn3 (fun a b => b :e V) Hn3.
  + assume Hw4: w :e {n4}. claim Hwn4: w = n4. exact SingE n4 w Hw4. exact Hwn4 (fun a b => b :e V) Hn4.
- prove equip 4 S.
  exact equip_4_quad n1 n2 n3 n4 H12 H13 H14 H23 H24 H34.
- prove is_indep_set V R S.
  apply andI (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y).
  + let w. assume Hw: w :e S.
    apply binunionE ({n1, n2} :\/: {n3}) {n4} w Hw.
    * assume Hw123: w :e ({n1, n2} :\/: {n3}).
      apply binunionE {n1, n2} {n3} w Hw123.
      - assume Hw12: w :e {n1, n2}. apply UPairE w n1 n2 Hw12.
        + assume Hwn1: w = n1. exact Hwn1 (fun a b => b :e V) Hn1.
        + assume Hwn2: w = n2. exact Hwn2 (fun a b => b :e V) Hn2.
      - assume Hw3: w :e {n3}. claim Hwn3: w = n3. exact SingE n3 w Hw3. exact Hwn3 (fun a b => b :e V) Hn3.
    * assume Hw4: w :e {n4}. claim Hwn4: w = n4. exact SingE n4 w Hw4. exact Hwn4 (fun a b => b :e V) Hn4.
  + prove forall x :e S, forall y :e S, x <> y -> ~R x y.
    exact neighbors_form_indep V R Hsym Htf v Hv S
      (fun w Hw =>
        binunionE ({n1, n2} :\/: {n3}) {n4} w Hw (w :e V)
          (fun Hw123 => binunionE {n1, n2} {n3} w Hw123 (w :e V)
            (fun Hw12 => UPairE w n1 n2 Hw12 (w :e V)
              (fun Hwn1 => Hwn1 (fun a b => b :e V) Hn1)
              (fun Hwn2 => Hwn2 (fun a b => b :e V) Hn2))
            (fun Hw3 => (SingE n3 w Hw3) (fun a b => b :e V) Hn3))
          (fun Hw4 => (SingE n4 w Hw4) (fun a b => b :e V) Hn4))
      (fun w Hw =>
        binunionE ({n1, n2} :\/: {n3}) {n4} w Hw (R v w)
          (fun Hw123 => binunionE {n1, n2} {n3} w Hw123 (R v w)
            (fun Hw12 => UPairE w n1 n2 Hw12 (R v w)
              (fun Hwn1 =>
                let Hn1w : n1 = w := (fun Q HQ => Hwn1 (fun a b => Q b a) HQ)
                in Hn1w (fun a b => R v a) Rv1)
              (fun Hwn2 =>
                let Hn2w : n2 = w := (fun Q HQ => Hwn2 (fun a b => Q b a) HQ)
                in Hn2w (fun a b => R v a) Rv2))
            (fun Hw3 =>
              let Hwn3 := SingE n3 w Hw3 in
              let Hn3w : n3 = w := (fun Q HQ => Hwn3 (fun a b => Q b a) HQ)
              in Hn3w (fun a b => R v a) Rv3))
          (fun Hw4 =>
            let Hwn4 := SingE n4 w Hw4 in
            let Hn4w : n4 = w := (fun Q HQ => Hwn4 (fun a b => Q b a) HQ)
            in Hn4w (fun a b => R v a) Rv4)).
Qed.

Theorem six_nonneighbors_contradiction_on_9 : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  equip 9 V ->
  triangle_free V R ->
  ~(exists x y z :e V, R x y /\ R y z /\ R x z) ->
  ~(exists S, S c= V /\ equip 4 S /\ is_indep_set V R S) ->
  forall v :e V, forall m1 m2 m3 m4 m5 m6 :e V,
    m1 <> m2 -> m1 <> m3 -> m1 <> m4 -> m1 <> m5 -> m1 <> m6 ->
    m2 <> m3 -> m2 <> m4 -> m2 <> m5 -> m2 <> m6 ->
    m3 <> m4 -> m3 <> m5 -> m3 <> m6 ->
    m4 <> m5 -> m4 <> m6 ->
    m5 <> m6 ->
    ~R v m1 -> ~R v m2 -> ~R v m3 -> ~R v m4 -> ~R v m5 -> ~R v m6 -> False.
Admitted.

Theorem degree_parity_contradiction_on_9 : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  equip 9 V ->
  triangle_free V R ->
  (forall v :e V, forall n1 n2 n3 n4 :e V,
    n1 <> n2 -> n1 <> n3 -> n1 <> n4 -> n2 <> n3 -> n2 <> n4 -> n3 <> n4 ->
    R v n1 -> R v n2 -> R v n3 -> R v n4 -> False) ->
  (forall v :e V, forall m1 m2 m3 m4 m5 m6 :e V,
    m1 <> m2 -> m1 <> m3 -> m1 <> m4 -> m1 <> m5 -> m1 <> m6 ->
    m2 <> m3 -> m2 <> m4 -> m2 <> m5 -> m2 <> m6 ->
    m3 <> m4 -> m3 <> m5 -> m3 <> m6 ->
    m4 <> m5 -> m4 <> m6 ->
    m5 <> m6 ->
    ~R v m1 -> ~R v m2 -> ~R v m3 -> ~R v m4 -> ~R v m5 -> ~R v m6 -> False) ->
  False.
Admitted.

Theorem has_triangle_or_4indep_on_9 : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  equip 9 V ->
  (exists x y z :e V, R x y /\ R y z /\ R x z) \/
  (exists S, S c= V /\ equip 4 S /\ is_indep_set V R S).
let V. let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Hequip: equip 9 V.
apply dneg.
assume Hneg: ~((exists x y z :e V, R x y /\ R y z /\ R x z) \/
              (exists S, S c= V /\ equip 4 S /\ is_indep_set V R S)).
prove False.
claim Hno_tri: ~(exists x y z :e V, R x y /\ R y z /\ R x z).
  assume Htri. apply Hneg. apply orIL. exact Htri.
claim Hno_4indep: ~(exists S, S c= V /\ equip 4 S /\ is_indep_set V R S).
  assume H4. apply Hneg. apply orIR. exact H4.
claim Htf: triangle_free V R.
  prove forall x :e V, forall y :e V, forall z :e V, R x y -> R y z -> R x z -> False.
  let x. assume Hx: x :e V.
  let y. assume Hy: y :e V.
  let z. assume Hz: z :e V.
  assume Rxy: R x y.
  assume Ryz: R y z.
  assume Rxz: R x z.
  apply Hno_tri.
  prove exists x :e V, exists y :e V, exists z :e V, R x y /\ R y z /\ R x z.
  witness x.
  prove x :e V /\ (exists y :e V, exists z :e V, R x y /\ R y z /\ R x z).
  claim H1: exists y :e V, exists z :e V, R x y /\ R y z /\ R x z.
    witness y.
    prove y :e V /\ (exists z :e V, R x y /\ R y z /\ R x z).
    claim H2: exists z :e V, R x y /\ R y z /\ R x z.
      witness z.
      prove z :e V /\ (R x y /\ R y z /\ R x z).
      exact andI (z :e V) (R x y /\ R y z /\ R x z) Hz (and3I (R x y) (R y z) (R x z) Rxy Ryz Rxz).
    exact andI (y :e V) (exists z :e V, R x y /\ R y z /\ R x z) Hy H2.
  exact andI (x :e V) (exists y :e V, exists z :e V, R x y /\ R y z /\ R x z) Hx H1.
claim Hno_4neighbors: forall v :e V, forall n1 n2 n3 n4 :e V,
    n1 <> n2 -> n1 <> n3 -> n1 <> n4 -> n2 <> n3 -> n2 <> n4 -> n3 <> n4 ->
    R v n1 -> R v n2 -> R v n3 -> R v n4 -> False.
  let v. assume Hv: v :e V.
  let n1. assume Hn1: n1 :e V.
  let n2. assume Hn2: n2 :e V.
  let n3. assume Hn3: n3 :e V.
  let n4. assume Hn4: n4 :e V.
  assume H12: n1 <> n2.
  assume H13: n1 <> n3.
  assume H14: n1 <> n4.
  assume H23: n2 <> n3.
  assume H24: n2 <> n4.
  assume H34: n3 <> n4.
  assume Rv1: R v n1.
  assume Rv2: R v n2.
  assume Rv3: R v n3.
  assume Rv4: R v n4.
  apply Hno_4indep.
  exact four_neighbors_give_4indep V R Hsym Htf v Hv n1 Hn1 n2 Hn2 n3 Hn3 n4 Hn4
        H12 H13 H14 H23 H24 H34 Rv1 Rv2 Rv3 Rv4.
claim Hno_6nonneighbors: forall v :e V, forall m1 m2 m3 m4 m5 m6 :e V,
    m1 <> m2 -> m1 <> m3 -> m1 <> m4 -> m1 <> m5 -> m1 <> m6 ->
    m2 <> m3 -> m2 <> m4 -> m2 <> m5 -> m2 <> m6 ->
    m3 <> m4 -> m3 <> m5 -> m3 <> m6 ->
    m4 <> m5 -> m4 <> m6 ->
    m5 <> m6 ->
    ~R v m1 -> ~R v m2 -> ~R v m3 -> ~R v m4 -> ~R v m5 -> ~R v m6 -> False.
  exact six_nonneighbors_contradiction_on_9 V R Hsym Hequip Htf Hno_tri Hno_4indep.
exact degree_parity_contradiction_on_9 V R Hsym Hequip Htf Hno_4neighbors Hno_6nonneighbors.
Qed.

Theorem triangle_free_9_has_4indep : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free V R ->
  equip 9 V ->
  exists S, S c= V /\ equip 4 S /\ is_indep_set V R S.
let V. let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free V R.
assume Hequip: equip 9 V.
prove exists S, S c= V /\ equip 4 S /\ is_indep_set V R S.
apply has_triangle_or_4indep_on_9 V R Hsym Hequip.
- assume Htri: exists x y z :e V, R x y /\ R y z /\ R x z.
  prove False.
  apply Htri.
  let x. assume Hx: x :e V /\ (exists y :e V, exists z :e V, R x y /\ R y z /\ R x z).
  claim HxV: x :e V. exact andEL (x :e V) (exists y :e V, exists z :e V, R x y /\ R y z /\ R x z) Hx.
  claim Hrest: exists y :e V, exists z :e V, R x y /\ R y z /\ R x z.
    exact andER (x :e V) (exists y :e V, exists z :e V, R x y /\ R y z /\ R x z) Hx.
  apply Hrest.
  let y. assume Hy: y :e V /\ (exists z :e V, R x y /\ R y z /\ R x z).
  claim HyV: y :e V. exact andEL (y :e V) (exists z :e V, R x y /\ R y z /\ R x z) Hy.
  claim Hrest2: exists z :e V, R x y /\ R y z /\ R x z.
    exact andER (y :e V) (exists z :e V, R x y /\ R y z /\ R x z) Hy.
  apply Hrest2.
  let z. assume Hz: z :e V /\ (R x y /\ R y z /\ R x z).
  claim HzV: z :e V. exact andEL (z :e V) (R x y /\ R y z /\ R x z) Hz.
  claim Hedges: R x y /\ R y z /\ R x z.
    exact andER (z :e V) (R x y /\ R y z /\ R x z) Hz.
  apply and3E (R x y) (R y z) (R x z) Hedges False.
  prove R x y -> R y z -> R x z -> False.
  assume Rxy: R x y. assume Ryz: R y z. assume Rxz: R x z.
  exact Htf x HxV y HyV z HzV Rxy Ryz Rxz.
- assume H4: exists S, S c= V /\ equip 4 S /\ is_indep_set V R S.
  exact H4.
Qed.

Theorem triangle_free_Subq : forall V W:set, forall R:set -> set -> prop,
  W c= V ->
  triangle_free V R ->
  triangle_free W R.
let V. let W. let R: set -> set -> prop.
assume HWV: W c= V.
assume Htf: triangle_free V R.
prove triangle_free W R.
prove forall x :e W, forall y :e W, forall z :e W, R x y -> R y z -> R x z -> False.
let x. assume Hx: x :e W.
let y. assume Hy: y :e W.
let z. assume Hz: z :e W.
exact Htf x (HWV x Hx) y (HWV y Hy) z (HWV z Hz).
Qed.

Theorem is_indep_set_enlarge : forall V W:set, forall R:set -> set -> prop, forall S:set,
  V c= W ->
  S c= V ->
  is_indep_set V R S ->
  is_indep_set W R S.
let V. let W. let R: set -> set -> prop. let S.
assume HVW: V c= W.
assume HSV: S c= V.
assume Hindep: is_indep_set V R S.
prove is_indep_set W R S.
prove S c= W /\ (forall x :e S, forall y :e S, x <> y -> ~R x y).
apply andI (S c= W) (forall x :e S, forall y :e S, x <> y -> ~R x y).
- prove S c= W.
  let s. assume Hs: s :e S.
  exact HVW s (HSV s Hs).
- prove forall x :e S, forall y :e S, x <> y -> ~R x y.
  apply andER (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y) Hindep.
Qed.

Theorem nat_p_12 : nat_p 12.
exact nat_ordsucc 11 (nat_ordsucc 10 (nat_ordsucc 9 (nat_ordsucc 8 (nat_ordsucc 7
      (nat_ordsucc 6 (nat_ordsucc 5 (nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2))))))))).
Qed.

Theorem in_9_12 : 9 :e 12.
prove 9 :e 12.
prove 9 :e ordsucc 11.
apply ordsuccI1 11.
prove 9 :e 11.
apply ordsuccI1 10.
prove 9 :e 10.
exact ordsuccI2 9.
Qed.

Theorem Subq_9_12 : 9 c= 12.
prove forall x :e 9, x :e 12.
let x. assume Hx: x :e 9.
exact nat_trans 12 nat_p_12 9 in_9_12 x Hx.
Qed.

Theorem non_neighbors_contain_4indep : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free 18 R ->
  forall v :e 18, forall T:set,
    T c= 18 ->
    equip 12 T ->
    (forall t :e T, ~R v t) ->
    exists S, S c= T /\ equip 4 S /\ is_indep_set 18 R S.
let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free 18 R.
let v. assume Hv: v :e 18.
let T. assume HT18: T c= 18.
assume HT12: equip 12 T.
assume Hnonadj: forall t :e T, ~R v t.
prove exists S, S c= T /\ equip 4 S /\ is_indep_set 18 R S.
apply equip_subset 12 9 T Subq_9_12 HT12.
let T'. assume HT'prop: T' c= T /\ equip 9 T'.
claim HT'T: T' c= T. exact andEL (T' c= T) (equip 9 T') HT'prop.
claim HT'9: equip 9 T'. exact andER (T' c= T) (equip 9 T') HT'prop.
claim HT'18: T' c= 18.
  let x. assume Hx: x :e T'.
  exact HT18 x (HT'T x Hx).
claim Htf_T': triangle_free T' R.
  exact triangle_free_Subq 18 T' R HT'18 Htf.
apply triangle_free_9_has_4indep T' R Hsym Htf_T' HT'9.
let S. assume HS: S c= T' /\ equip 4 S /\ is_indep_set T' R S.
apply and3E (S c= T') (equip 4 S) (is_indep_set T' R S) HS (exists S, S c= T /\ equip 4 S /\ is_indep_set 18 R S).
assume HS_T': S c= T'.
assume HS4: equip 4 S.
assume HS_indep_T': is_indep_set T' R S.
witness S.
prove S c= T /\ equip 4 S /\ is_indep_set 18 R S.
apply and3I (S c= T) (equip 4 S) (is_indep_set 18 R S).
- prove S c= T.
  let s. assume Hs: s :e S.
  exact HT'T s (HS_T' s Hs).
- prove equip 4 S.
  exact HS4.
- prove is_indep_set 18 R S.
  exact is_indep_set_enlarge T' 18 R S HT'18 HS_T' HS_indep_T'.
Qed.

Theorem vertex_has_12_nonneighbors : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free 18 R ->
  no_k_indep 18 R 6 ->
  forall v :e 18, exists T:set, T c= 18 /\ equip 12 T /\ (forall t :e T, ~R v t) /\ v /:e T.
let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free 18 R.
assume Hno6: no_k_indep 18 R 6.
let v. assume Hv: v :e 18.
prove exists T:set, T c= 18 /\ equip 12 T /\ (forall t :e T, ~R v t) /\ v /:e T.
Admitted.

Theorem can_extend_4indep_with_nonneighbor : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free 18 R ->
  no_k_indep 18 R 6 ->
  forall v :e 18, forall S:set,
    S c= 18 ->
    equip 4 S ->
    (forall s :e S, ~R v s) ->
    (forall s :e S, ~R s v) ->
    is_indep_set 18 R S ->
    v /:e S ->
    False.
let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free 18 R.
assume Hno6: no_k_indep 18 R 6.
let v. assume Hv: v :e 18.
let S. assume HS18: S c= 18.
assume HS4: equip 4 S.
assume Hvs_nonadj1: forall s :e S, ~R v s.
assume Hvs_nonadj2: forall s :e S, ~R s v.
assume HS_indep: is_indep_set 18 R S.
assume Hv_notin_S: v /:e S.
prove False.
Admitted.

Theorem nat_p_17 : nat_p 17.
exact nat_ordsucc 16 (nat_ordsucc 15 (nat_ordsucc 14 (nat_ordsucc 13 (nat_ordsucc 12
      (nat_ordsucc 11 (nat_ordsucc 10 (nat_ordsucc 9 (nat_ordsucc 8 (nat_ordsucc 7
      (nat_ordsucc 6 (nat_ordsucc 5 (nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2)))))))))))))).
Qed.

Theorem zero_in_18 : 0 :e 18.
exact nat_0_in_ordsucc 17 nat_p_17.
Qed.

Theorem good_graph_contradiction : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) -> triangle_free 18 R -> no_k_indep 18 R 6 -> False.
let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free 18 R.
assume Hno6: no_k_indep 18 R 6.
prove False.
apply vertex_has_12_nonneighbors R Hsym Htf Hno6 0 zero_in_18.
let T. assume HT: T c= 18 /\ equip 12 T /\ (forall t :e T, ~R 0 t) /\ 0 /:e T.
apply and4E (T c= 18) (equip 12 T) (forall t :e T, ~R 0 t) (0 /:e T) HT False.
assume HTV: T c= 18.
assume HT12: equip 12 T.
assume HT_nonadj: forall t :e T, ~R 0 t.
assume H0notinT: 0 /:e T.
apply non_neighbors_contain_4indep R Hsym Htf 0 zero_in_18 T HTV HT12 HT_nonadj.
let S. assume HS: S c= T /\ equip 4 S /\ is_indep_set 18 R S.
apply and3E (S c= T) (equip 4 S) (is_indep_set 18 R S) HS False.
assume HST: S c= T.
assume HS4: equip 4 S.
assume HS_indep: is_indep_set 18 R S.
claim HS18: S c= 18.
  let s. assume Hs: s :e S.
  exact HTV s (HST s Hs).
claim HS_nonadj0: forall s :e S, ~R 0 s.
  let s. assume Hs: s :e S.
  exact HT_nonadj s (HST s Hs).
claim HS_nonadj0_sym: forall s :e S, ~R s 0.
  let s. assume Hs: s :e S.
  assume HRs0: R s 0.
  apply HS_nonadj0 s Hs.
  exact Hsym s 0 HRs0.
claim H0notinS: 0 /:e S.
  assume H0S: 0 :e S.
  apply H0notinT.
  exact HST 0 H0S.
exact can_extend_4indep_with_nonneighbor R Hsym Htf Hno6 0 zero_in_18 S HS18 HS4
      HS_nonadj0 HS_nonadj0_sym HS_indep H0notinS.
Qed.

Definition TwoRamseyProp : set -> set -> set -> prop
 := fun M N V =>
      forall R:set -> set -> prop,
        (forall x y, R x y -> R y x)
       -> ((exists X, X c= V /\ equip M X /\ (forall x :e X, forall y :e X, x <> y -> R x y))
        \/ (exists Y, Y c= V /\ equip N Y /\ (forall x :e Y, forall y :e Y, x <> y -> ~R x y))).

Theorem triangle_witness_from_neg : forall V:set, forall R:set -> set -> prop,
  (forall x :e V, ~R x x) ->
  (forall x y, R x y -> R y x) ->
  ~triangle_free V R ->
  exists X, X c= V /\ equip 3 X /\ (forall x :e X, forall y :e X, x <> y -> R x y).
let V. let R: set -> set -> prop.
assume Hirr: forall x :e V, ~R x x.
assume Hsym: forall x y, R x y -> R y x.
assume Hntf: ~triangle_free V R.
prove exists X, X c= V /\ equip 3 X /\ (forall x :e X, forall y :e X, x <> y -> R x y).
apply dneg (exists X, X c= V /\ equip 3 X /\ (forall x :e X, forall y :e X, x <> y -> R x y)).
assume Hno: ~(exists X, X c= V /\ equip 3 X /\ (forall x :e X, forall y :e X, x <> y -> R x y)).
prove False.
apply Hntf.
prove triangle_free V R.
let x. assume HxV: x :e V.
let y. assume HyV: y :e V.
let z. assume HzV: z :e V.
assume Rxy: R x y.
assume Ryz: R y z.
assume Rxz: R x z.
prove False.
claim Hxy: x <> y.
  assume Heq: x = y.
  apply Hirr x HxV.
  prove R x x.
  claim Heqsym: y = x.
    prove forall Q: set -> set -> prop, Q y x -> Q x y.
    let Q: set -> set -> prop. assume HQ: Q y x.
    exact Heq (fun a b => Q b a) HQ.
  exact Heqsym (fun a b => R x a) Rxy.
claim Hyz: y <> z.
  assume Heq: y = z.
  apply Hirr y HyV.
  prove R y y.
  claim Heqsym: z = y.
    prove forall Q: set -> set -> prop, Q z y -> Q y z.
    let Q: set -> set -> prop. assume HQ: Q z y.
    exact Heq (fun a b => Q b a) HQ.
  exact Heqsym (fun a b => R y a) Ryz.
claim Hxz: x <> z.
  assume Heq: x = z.
  apply Hirr x HxV.
  prove R x x.
  claim Heqsym: z = x.
    prove forall Q: set -> set -> prop, Q z x -> Q x z.
    let Q: set -> set -> prop. assume HQ: Q z x.
    exact Heq (fun a b => Q b a) HQ.
  exact Heqsym (fun a b => R x a) Rxz.
apply Hno.
witness {x, y} :\/: {z}.
apply and3I ({x, y} :\/: {z} c= V) (equip 3 ({x, y} :\/: {z})) (forall a :e {x, y} :\/: {z}, forall b :e {x, y} :\/: {z}, a <> b -> R a b).
- prove {x, y} :\/: {z} c= V.
  let w. assume Hw: w :e {x, y} :\/: {z}.
  apply binunionE {x, y} {z} w Hw.
  + assume Hwxy: w :e {x, y}.
    apply UPairE w x y Hwxy.
    * assume Hwx: w = x.
      prove w :e V.
      apply Hwx (fun a b => b :e V) HxV.
    * assume Hwy: w = y.
      prove w :e V.
      apply Hwy (fun a b => b :e V) HyV.
  + assume Hwz: w :e {z}.
    claim Hwz2: w = z.
      exact SingE z w Hwz.
    prove w :e V.
    apply Hwz2 (fun a b => b :e V) HzV.
- prove equip 3 ({x, y} :\/: {z}).
  set S := {x, y} :\/: {z}.
  set f := fun n:set => if n = 0 then x else (if n = 1 then y else z).
  claim H00: 0 = 0.
    prove forall Q: set -> set -> prop, Q 0 0 -> Q 0 0.
    let Q. assume HQ: Q 0 0. exact HQ.
  claim H11: 1 = 1.
    prove forall Q: set -> set -> prop, Q 1 1 -> Q 1 1.
    let Q. assume HQ: Q 1 1. exact HQ.
  claim H22: 2 = 2.
    prove forall Q: set -> set -> prop, Q 2 2 -> Q 2 2.
    let Q. assume HQ: Q 2 2. exact HQ.
  claim Hf0: f 0 = x.
    prove (if 0 = 0 then x else (if 0 = 1 then y else z)) = x.
    exact If_i_1 (0 = 0) x (if 0 = 1 then y else z) H00.
  claim Hf1: f 1 = y.
    prove (if 1 = 0 then x else (if 1 = 1 then y else z)) = y.
    claim H10: 1 <> 0.
      exact neq_1_0.
    claim Hstep1: (if 1 = 0 then x else (if 1 = 1 then y else z)) = (if 1 = 1 then y else z).
      exact If_i_0 (1 = 0) x (if 1 = 1 then y else z) H10.
    claim Hstep2: (if 1 = 1 then y else z) = y.
      exact If_i_1 (1 = 1) y z H11.
    exact eq_i_tra (if 1 = 0 then x else (if 1 = 1 then y else z)) (if 1 = 1 then y else z) y Hstep1 Hstep2.
  claim Hf2: f 2 = z.
    prove (if 2 = 0 then x else (if 2 = 1 then y else z)) = z.
    claim H20: 2 <> 0.
      exact neq_2_0.
    claim H21: 2 <> 1.
      exact neq_2_1.
    claim Hstep1: (if 2 = 0 then x else (if 2 = 1 then y else z)) = (if 2 = 1 then y else z).
      exact If_i_0 (2 = 0) x (if 2 = 1 then y else z) H20.
    claim Hstep2: (if 2 = 1 then y else z) = z.
      exact If_i_0 (2 = 1) y z H21.
    exact eq_i_tra (if 2 = 0 then x else (if 2 = 1 then y else z)) (if 2 = 1 then y else z) z Hstep1 Hstep2.
  claim HxS: x :e S.
    apply binunionI1 {x, y} {z} x.
    exact UPairI1 x y.
  claim Hf0S: f 0 :e S.
    exact Hf0 (fun a b => b :e S) HxS.
  claim HyS: y :e S.
    apply binunionI1 {x, y} {z} y.
    exact UPairI2 x y.
  claim Hf1S: f 1 :e S.
    exact Hf1 (fun a b => b :e S) HyS.
  claim HzS: z :e S.
    apply binunionI2 {x, y} {z} z.
    exact SingI z.
  claim Hf2S: f 2 :e S.
    exact Hf2 (fun a b => b :e S) HzS.
  prove equip 3 S.
  prove exists g : set -> set, bij 3 S g.
  witness f.
  prove bij 3 S f.
  apply and3I (forall u :e 3, f u :e S) (forall u v :e 3, f u = f v -> u = v) (forall w :e S, exists u :e 3, f u = w).
  + prove forall u :e 3, f u :e S.
    let u. assume Hu: u :e 3.
    exact cases_3 u Hu (fun i => f i :e S) Hf0S Hf1S Hf2S.
  + prove forall u v :e 3, f u = f v -> u = v.
    let u. assume Hu: u :e 3.
    let v. assume Hv: v :e 3.
    assume Hfuv: f u = f v.
    prove u = v.
    claim Hcase0: f 0 = f v -> 0 = v.
      assume H0v: f 0 = f v.
      claim Hcase00: f 0 = f 0 -> 0 = 0.
        assume HH. exact H00.
      claim Hcase01: f 0 = f 1 -> 0 = 1.
        assume H01: f 0 = f 1.
        prove False.
        claim Hx_eq_y: x = y.
          claim H1: f 0 = x. exact Hf0.
          claim H2: f 1 = y. exact Hf1.
          claim H3: x = f 0. prove forall Q: set -> set -> prop, Q x (f 0) -> Q (f 0) x. let Q. assume HQ. exact H1 (fun a b => Q b a) HQ.
          claim H4: f 0 = y. exact eq_i_tra (f 0) (f 1) y H01 H2.
          exact eq_i_tra x (f 0) y H3 H4.
        exact Hxy Hx_eq_y.
      claim Hcase02: f 0 = f 2 -> 0 = 2.
        assume H02: f 0 = f 2.
        prove False.
        claim Hx_eq_z: x = z.
          claim H1: f 0 = x. exact Hf0.
          claim H2: f 2 = z. exact Hf2.
          claim H3: x = f 0. prove forall Q: set -> set -> prop, Q x (f 0) -> Q (f 0) x. let Q. assume HQ. exact H1 (fun a b => Q b a) HQ.
          claim H4: f 0 = z. exact eq_i_tra (f 0) (f 2) z H02 H2.
          exact eq_i_tra x (f 0) z H3 H4.
        exact Hxz Hx_eq_z.
      exact cases_3 v Hv (fun j => f 0 = f j -> 0 = j) Hcase00 Hcase01 Hcase02 H0v.
    claim Hcase1: f 1 = f v -> 1 = v.
      assume H1v: f 1 = f v.
      claim Hcase10: f 1 = f 0 -> 1 = 0.
        assume H10: f 1 = f 0.
        prove False.
        claim Hy_eq_x: y = x.
          claim H1: f 1 = y. exact Hf1.
          claim H2: f 0 = x. exact Hf0.
          claim H3: y = f 1. prove forall Q: set -> set -> prop, Q y (f 1) -> Q (f 1) y. let Q. assume HQ. exact H1 (fun a b => Q b a) HQ.
          claim H4: f 1 = x. exact eq_i_tra (f 1) (f 0) x H10 H2.
          exact eq_i_tra y (f 1) x H3 H4.
        claim Hx_eq_y: x = y.
          prove forall Q: set -> set -> prop, Q x y -> Q y x. let Q. assume HQ. exact Hy_eq_x (fun a b => Q b a) HQ.
        exact Hxy Hx_eq_y.
      claim Hcase11: f 1 = f 1 -> 1 = 1.
        assume HH. exact H11.
      claim Hcase12: f 1 = f 2 -> 1 = 2.
        assume H12: f 1 = f 2.
        prove False.
        claim Hy_eq_z: y = z.
          claim H1: f 1 = y. exact Hf1.
          claim H2: f 2 = z. exact Hf2.
          claim H3: y = f 1. prove forall Q: set -> set -> prop, Q y (f 1) -> Q (f 1) y. let Q. assume HQ. exact H1 (fun a b => Q b a) HQ.
          claim H4: f 1 = z. exact eq_i_tra (f 1) (f 2) z H12 H2.
          exact eq_i_tra y (f 1) z H3 H4.
        exact Hyz Hy_eq_z.
      exact cases_3 v Hv (fun j => f 1 = f j -> 1 = j) Hcase10 Hcase11 Hcase12 H1v.
    claim Hcase2: f 2 = f v -> 2 = v.
      assume H2v: f 2 = f v.
      claim Hcase20: f 2 = f 0 -> 2 = 0.
        assume H20: f 2 = f 0.
        prove False.
        claim Hz_eq_x: z = x.
          claim H1: f 2 = z. exact Hf2.
          claim H2: f 0 = x. exact Hf0.
          claim H3: z = f 2. prove forall Q: set -> set -> prop, Q z (f 2) -> Q (f 2) z. let Q. assume HQ. exact H1 (fun a b => Q b a) HQ.
          claim H4: f 2 = x. exact eq_i_tra (f 2) (f 0) x H20 H2.
          exact eq_i_tra z (f 2) x H3 H4.
        claim Hx_eq_z: x = z.
          prove forall Q: set -> set -> prop, Q x z -> Q z x. let Q. assume HQ. exact Hz_eq_x (fun a b => Q b a) HQ.
        exact Hxz Hx_eq_z.
      claim Hcase21: f 2 = f 1 -> 2 = 1.
        assume H21: f 2 = f 1.
        prove False.
        claim Hz_eq_y: z = y.
          claim H1: f 2 = z. exact Hf2.
          claim H2: f 1 = y. exact Hf1.
          claim H3: z = f 2. prove forall Q: set -> set -> prop, Q z (f 2) -> Q (f 2) z. let Q. assume HQ. exact H1 (fun a b => Q b a) HQ.
          claim H4: f 2 = y. exact eq_i_tra (f 2) (f 1) y H21 H2.
          exact eq_i_tra z (f 2) y H3 H4.
        claim Hy_eq_z: y = z.
          prove forall Q: set -> set -> prop, Q y z -> Q z y. let Q. assume HQ. exact Hz_eq_y (fun a b => Q b a) HQ.
        exact Hyz Hy_eq_z.
      claim Hcase22: f 2 = f 2 -> 2 = 2.
        assume HH. exact H22.
      exact cases_3 v Hv (fun j => f 2 = f j -> 2 = j) Hcase20 Hcase21 Hcase22 H2v.
    exact cases_3 u Hu (fun i => f i = f v -> i = v) Hcase0 Hcase1 Hcase2 Hfuv.
  + prove forall w :e S, exists u :e 3, f u = w.
    let w. assume Hw: w :e S.
    prove exists u :e 3, f u = w.
    claim Hcasex: w = x -> exists u :e 3, f u = w.
      assume Hwx: w = x.
      witness 0.
      claim Hxw: x = w. prove forall Q: set -> set -> prop, Q x w -> Q w x. let Q. assume HQ. exact Hwx (fun a b => Q b a) HQ.
      claim Hf0w: f 0 = w. exact eq_i_tra (f 0) x w Hf0 Hxw.
      exact andI (0 :e 3) (f 0 = w) In_0_3 Hf0w.
    claim Hcasey: w = y -> exists u :e 3, f u = w.
      assume Hwy: w = y.
      witness 1.
      claim Hyw: y = w. prove forall Q: set -> set -> prop, Q y w -> Q w y. let Q. assume HQ. exact Hwy (fun a b => Q b a) HQ.
      claim Hf1w: f 1 = w. exact eq_i_tra (f 1) y w Hf1 Hyw.
      exact andI (1 :e 3) (f 1 = w) In_1_3 Hf1w.
    claim Hcasez: w = z -> exists u :e 3, f u = w.
      assume Hwz: w = z.
      witness 2.
      claim Hzw: z = w. prove forall Q: set -> set -> prop, Q z w -> Q w z. let Q. assume HQ. exact Hwz (fun a b => Q b a) HQ.
      claim Hf2w: f 2 = w. exact eq_i_tra (f 2) z w Hf2 Hzw.
      exact andI (2 :e 3) (f 2 = w) In_2_3 Hf2w.
    apply binunionE {x, y} {z} w Hw.
    * assume Hwxy: w :e {x, y}.
      apply UPairE w x y Hwxy.
      - exact Hcasex.
      - exact Hcasey.
    * assume Hwz: w :e {z}.
      claim Hwz2: w = z. exact SingE z w Hwz.
      exact Hcasez Hwz2.
- prove forall a :e {x, y} :\/: {z}, forall b :e {x, y} :\/: {z}, a <> b -> R a b.
  let a. assume Ha: a :e {x, y} :\/: {z}.
  let b. assume Hb: b :e {x, y} :\/: {z}.
  assume Hab: a <> b.
  prove R a b.
  claim Ryx: R y x. exact Hsym x y Rxy.
  claim Rzy: R z y. exact Hsym y z Ryz.
  claim Rzx: R z x. exact Hsym x z Rxz.
  claim Hxx: x = x. prove forall Q: set -> set -> prop, Q x x -> Q x x. let Q. assume HQ. exact HQ.
  claim Hyy: y = y. prove forall Q: set -> set -> prop, Q y y -> Q y y. let Q. assume HQ. exact HQ.
  claim Hzz: z = z. prove forall Q: set -> set -> prop, Q z z -> Q z z. let Q. assume HQ. exact HQ.
  claim Hcase_x_x: a = x -> b = x -> R a b.
    assume Hax: a = x. assume Hbx: b = x.
    prove False.
    claim Hab2: x <> x.
      claim H4: x <> b. exact Hax (fun u v => u <> b) Hab.
      claim H6: x = b. prove forall Q: set -> set -> prop, Q x b -> Q b x. let Q. assume HQ. exact Hbx (fun u v => Q v u) HQ.
      exact H6 (fun u v => x <> v) H4.
    exact Hab2 Hxx.
  claim Hcase_x_y: a = x -> b = y -> R a b.
    assume Hax: a = x. assume Hby: b = y.
    claim Hxa: x = a. prove forall Q: set -> set -> prop, Q x a -> Q a x. let Q. assume HQ. exact Hax (fun u v => Q v u) HQ.
    claim Hyb: y = b. prove forall Q: set -> set -> prop, Q y b -> Q b y. let Q. assume HQ. exact Hby (fun u v => Q v u) HQ.
    claim Rxb: R x b. exact Hyb (fun u v => R x u) Rxy.
    exact Hxa (fun u v => R u b) Rxb.
  claim Hcase_x_z: a = x -> b = z -> R a b.
    assume Hax: a = x. assume Hbz: b = z.
    claim Hxa: x = a. prove forall Q: set -> set -> prop, Q x a -> Q a x. let Q. assume HQ. exact Hax (fun u v => Q v u) HQ.
    claim Hzb: z = b. prove forall Q: set -> set -> prop, Q z b -> Q b z. let Q. assume HQ. exact Hbz (fun u v => Q v u) HQ.
    claim Rxb: R x b. exact Hzb (fun u v => R x u) Rxz.
    exact Hxa (fun u v => R u b) Rxb.
  claim Hcase_y_x: a = y -> b = x -> R a b.
    assume Hay: a = y. assume Hbx: b = x.
    claim Hya: y = a. prove forall Q: set -> set -> prop, Q y a -> Q a y. let Q. assume HQ. exact Hay (fun u v => Q v u) HQ.
    claim Hxb: x = b. prove forall Q: set -> set -> prop, Q x b -> Q b x. let Q. assume HQ. exact Hbx (fun u v => Q v u) HQ.
    claim Ryb: R y b. exact Hxb (fun u v => R y u) Ryx.
    exact Hya (fun u v => R u b) Ryb.
  claim Hcase_y_y: a = y -> b = y -> R a b.
    assume Hay: a = y. assume Hby: b = y.
    prove False.
    claim Hab2: y <> y.
      claim H4: y <> b. exact Hay (fun u v => u <> b) Hab.
      claim H6: y = b. prove forall Q: set -> set -> prop, Q y b -> Q b y. let Q. assume HQ. exact Hby (fun u v => Q v u) HQ.
      exact H6 (fun u v => y <> v) H4.
    exact Hab2 Hyy.
  claim Hcase_y_z: a = y -> b = z -> R a b.
    assume Hay: a = y. assume Hbz: b = z.
    claim Hya: y = a. prove forall Q: set -> set -> prop, Q y a -> Q a y. let Q. assume HQ. exact Hay (fun u v => Q v u) HQ.
    claim Hzb: z = b. prove forall Q: set -> set -> prop, Q z b -> Q b z. let Q. assume HQ. exact Hbz (fun u v => Q v u) HQ.
    claim Ryb: R y b. exact Hzb (fun u v => R y u) Ryz.
    exact Hya (fun u v => R u b) Ryb.
  claim Hcase_z_x: a = z -> b = x -> R a b.
    assume Haz: a = z. assume Hbx: b = x.
    claim Hza: z = a. prove forall Q: set -> set -> prop, Q z a -> Q a z. let Q. assume HQ. exact Haz (fun u v => Q v u) HQ.
    claim Hxb: x = b. prove forall Q: set -> set -> prop, Q x b -> Q b x. let Q. assume HQ. exact Hbx (fun u v => Q v u) HQ.
    claim Rzb: R z b. exact Hxb (fun u v => R z u) Rzx.
    exact Hza (fun u v => R u b) Rzb.
  claim Hcase_z_y: a = z -> b = y -> R a b.
    assume Haz: a = z. assume Hby: b = y.
    claim Hza: z = a. prove forall Q: set -> set -> prop, Q z a -> Q a z. let Q. assume HQ. exact Haz (fun u v => Q v u) HQ.
    claim Hyb: y = b. prove forall Q: set -> set -> prop, Q y b -> Q b y. let Q. assume HQ. exact Hby (fun u v => Q v u) HQ.
    claim Rzb: R z b. exact Hyb (fun u v => R z u) Rzy.
    exact Hza (fun u v => R u b) Rzb.
  claim Hcase_z_z: a = z -> b = z -> R a b.
    assume Haz: a = z. assume Hbz: b = z.
    prove False.
    claim Hab2: z <> z.
      claim H4: z <> b. exact Haz (fun u v => u <> b) Hab.
      claim H6: z = b. prove forall Q: set -> set -> prop, Q z b -> Q b z. let Q. assume HQ. exact Hbz (fun u v => Q v u) HQ.
      exact H6 (fun u v => z <> v) H4.
    exact Hab2 Hzz.
  claim Hcase_a_x: a = x -> R a b.
    assume Hax: a = x.
    claim Hbx_case: b = x -> R a b. exact Hcase_x_x Hax.
    claim Hby_case: b = y -> R a b. exact Hcase_x_y Hax.
    claim Hbz_case: b = z -> R a b. exact Hcase_x_z Hax.
    claim Hbxy_case: b :e {x, y} -> R a b.
      assume Hbxy: b :e {x, y}.
      exact UPairE b x y Hbxy (R a b) Hbx_case Hby_case.
    claim Hbsz_case: b :e {z} -> R a b.
      assume Hbz: b :e {z}.
      exact Hbz_case (SingE z b Hbz).
    exact binunionE {x, y} {z} b Hb (R a b) Hbxy_case Hbsz_case.
  claim Hcase_a_y: a = y -> R a b.
    assume Hay: a = y.
    claim Hbx_case: b = x -> R a b. exact Hcase_y_x Hay.
    claim Hby_case: b = y -> R a b. exact Hcase_y_y Hay.
    claim Hbz_case: b = z -> R a b. exact Hcase_y_z Hay.
    claim Hbxy_case: b :e {x, y} -> R a b.
      assume Hbxy: b :e {x, y}.
      exact UPairE b x y Hbxy (R a b) Hbx_case Hby_case.
    claim Hbsz_case: b :e {z} -> R a b.
      assume Hbz: b :e {z}.
      exact Hbz_case (SingE z b Hbz).
    exact binunionE {x, y} {z} b Hb (R a b) Hbxy_case Hbsz_case.
  claim Hcase_a_z: a = z -> R a b.
    assume Haz: a = z.
    claim Hbx_case: b = x -> R a b. exact Hcase_z_x Haz.
    claim Hby_case: b = y -> R a b. exact Hcase_z_y Haz.
    claim Hbz_case: b = z -> R a b. exact Hcase_z_z Haz.
    claim Hbxy_case: b :e {x, y} -> R a b.
      assume Hbxy: b :e {x, y}.
      exact UPairE b x y Hbxy (R a b) Hbx_case Hby_case.
    claim Hbsz_case: b :e {z} -> R a b.
      assume Hbz: b :e {z}.
      exact Hbz_case (SingE z b Hbz).
    exact binunionE {x, y} {z} b Hb (R a b) Hbxy_case Hbsz_case.
  claim Haxy_case: a :e {x, y} -> R a b.
    assume Haxy: a :e {x, y}.
    exact UPairE a x y Haxy (R a b) Hcase_a_x Hcase_a_y.
  claim Hasz_case: a :e {z} -> R a b.
    assume Haz: a :e {z}.
    exact Hcase_a_z (SingE z a Haz).
  exact binunionE {x, y} {z} a Ha (R a b) Haxy_case Hasz_case.
Qed.

Theorem indep_witness_from_neg : forall V:set, forall R:set -> set -> prop, forall k:set,
  ~no_k_indep V R k ->
  exists Y, Y c= V /\ equip k Y /\ (forall x :e Y, forall y :e Y, x <> y -> ~R x y).
let V. let R: set -> set -> prop. let k.
assume Hnot: ~no_k_indep V R k.
prove exists Y, Y c= V /\ equip k Y /\ (forall x :e Y, forall y :e Y, x <> y -> ~R x y).
apply dneg.
assume Hcontra: ~(exists Y, Y c= V /\ equip k Y /\ (forall x :e Y, forall y :e Y, x <> y -> ~R x y)).
apply Hnot.
prove no_k_indep V R k.
prove forall S, S c= V -> equip k S -> ~is_indep_set V R S.
let S. assume HSV: S c= V. assume HSeq: equip k S.
assume Hindep: is_indep_set V R S.
apply Hcontra.
witness S.
apply and3I.
- exact HSV.
- exact HSeq.
- prove forall x :e S, forall y :e S, x <> y -> ~R x y.
  exact andER (S c= V) (forall x :e S, forall y :e S, x <> y -> ~R x y) Hindep.
Qed.

Theorem R_18_irrefl : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free 18 R ->
  forall x :e 18, ~R x x.
let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free 18 R.
let x. assume Hx: x :e 18.
assume Hxx: R x x.
exact Htf x Hx x Hx x Hx Hxx Hxx Hxx.
Qed.

Theorem upper_bound_with_irrefl : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  (forall x :e 18, ~R x x) ->
  ((exists X, X c= 18 /\ equip 3 X /\ (forall x :e X, forall y :e X, x <> y -> R x y))
   \/ (exists Y, Y c= 18 /\ equip 6 Y /\ (forall x :e Y, forall y :e Y, x <> y -> ~R x y))).
let R: set -> set -> prop.
assume Rsym: forall x y, R x y -> R y x.
assume Rirrefl: forall x :e 18, ~R x x.
apply xm (triangle_free 18 R).
- assume Htf: triangle_free 18 R.
  apply xm (no_k_indep 18 R 6).
  + assume Hno6: no_k_indep 18 R 6.
    prove False.
    exact good_graph_contradiction R Rsym Htf Hno6.
  + assume Hnot6: ~no_k_indep 18 R 6.
    apply orIR.
    exact indep_witness_from_neg 18 R 6 Hnot6.
- assume Hntf: ~triangle_free 18 R.
  apply orIL.
  exact triangle_witness_from_neg 18 R Rirrefl Rsym Hntf.
Qed.

================================================================================
FILE: r34_proof.mg (69 lines)
================================================================================
Definition Adj8 : set -> set -> prop :=
  fun i j =>
    (i = 0 /\ (j = 1 \/ j = 4 \/ j = 7)) \/
    (i = 1 /\ (j = 0 \/ j = 2 \/ j = 5)) \/
    (i = 2 /\ (j = 1 \/ j = 3 \/ j = 6)) \/
    (i = 3 /\ (j = 2 \/ j = 4 \/ j = 7)) \/
    (i = 4 /\ (j = 0 \/ j = 3 \/ j = 5)) \/
    (i = 5 /\ (j = 1 \/ j = 4 \/ j = 6)) \/
    (i = 6 /\ (j = 2 \/ j = 5 \/ j = 7)) \/
    (i = 7 /\ (j = 0 \/ j = 3 \/ j = 6)).

Axiom neq_0_7 : 0 <> 7.
Axiom neq_2_6 : 2 <> 6.
Axiom neq_3_7 : 3 <> 7.
Axiom neq_5_6 : 5 <> 6.
Axiom neq_6_7 : 6 <> 7.

Theorem Adj8_sym : forall i j, Adj8 i j -> Adj8 j i.
Admitted.

Theorem Adj8_irref : forall i:set, ~Adj8 i i.
Admitted.

Theorem Adj8_triangle_free : forall x y z :e 8, Adj8 x y -> Adj8 y z -> Adj8 x z -> False.
Admitted.

Theorem Adj8_no_4indep : forall a b c d :e 8,
  a <> b -> a <> c -> a <> d -> b <> c -> b <> d -> c <> d ->
  Adj8 a b \/ Adj8 a c \/ Adj8 a d \/ Adj8 b c \/ Adj8 b d \/ Adj8 c d.
Admitted.

Definition is_indep_set_4 : set -> (set -> set -> prop) -> set -> set -> set -> set -> prop :=
  fun V R a b c d =>
    a :e V /\ b :e V /\ c :e V /\ d :e V /\
    a <> b /\ a <> c /\ a <> d /\ b <> c /\ b <> d /\ c <> d /\
    ~R a b /\ ~R a c /\ ~R a d /\ ~R b c /\ ~R b d /\ ~R c d.

Definition has_triangle : set -> (set -> set -> prop) -> prop :=
  fun V R => exists x y z :e V, x <> y /\ y <> z /\ x <> z /\ R x y /\ R y z /\ R x z.

Definition has_4indep : set -> (set -> set -> prop) -> prop :=
  fun V R => exists a b c d :e V, is_indep_set_4 V R a b c d.

Theorem degree_bound_3 : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  ~has_triangle V R ->
  ~has_4indep V R ->
  forall v :e V, forall n1 n2 n3 n4 :e V,
    n1 <> n2 -> n1 <> n3 -> n1 <> n4 -> n2 <> n3 -> n2 <> n4 -> n3 <> n4 ->
    v <> n1 -> v <> n2 -> v <> n3 -> v <> n4 ->
    R v n1 -> R v n2 -> R v n3 -> R v n4 ->
    False.
Admitted.

Theorem R34_upper : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  has_triangle 9 R \/ has_4indep 9 R.
Admitted.

Theorem R34_eq_9 :
  (forall x y z :e 8, Adj8 x y -> Adj8 y z -> Adj8 x z -> False) /\
  (forall a b c d :e 8, a<>b -> a<>c -> a<>d -> b<>c -> b<>d -> c<>d ->
     Adj8 a b \/ Adj8 a c \/ Adj8 a d \/ Adj8 b c \/ Adj8 b d \/ Adj8 c d) /\
  (forall R:set->set->prop, (forall x y, R x y -> R y x) -> has_triangle 9 R \/ has_4indep 9 R).
apply and3I.
- exact Adj8_triangle_free.
- exact Adj8_no_4indep.
- exact R34_upper.
Qed.

================================================================================
FILE: ordinal_subsets.mg (138 lines)
================================================================================
Theorem nat_p_12 : nat_p 12.
exact nat_ordsucc 11 (nat_ordsucc 10 (nat_ordsucc 9 (nat_ordsucc 8 (nat_ordsucc 7
      (nat_ordsucc 6 (nat_ordsucc 5 (nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2))))))))).
Qed.

Theorem nat_p_13 : nat_p 13.
exact nat_ordsucc 12 nat_p_12.
Qed.

Theorem nat_p_14 : nat_p 14.
exact nat_ordsucc 13 nat_p_13.
Qed.

Theorem nat_p_15 : nat_p 15.
exact nat_ordsucc 14 nat_p_14.
Qed.

Theorem nat_p_16 : nat_p 16.
exact nat_ordsucc 15 nat_p_15.
Qed.

Theorem nat_p_17 : nat_p 17.
exact nat_ordsucc 16 nat_p_16.
Qed.

Theorem twelve_subset_12 : 12 c= 12.
let x. assume Hx: x :e 12. exact Hx.
Qed.

Theorem in_12_13 : 12 :e 13.
prove 12 :e ordsucc 12.
exact ordsuccI2 12.
Qed.

Theorem twelve_subset_13 : 12 c= 13.
let x. assume Hx: x :e 12.
exact nat_trans 13 nat_p_13 12 in_12_13 x Hx.
Qed.

Theorem in_12_14 : 12 :e 14.
prove 12 :e ordsucc 13.
apply ordsuccI1 13.
exact in_12_13.
Qed.

Theorem twelve_subset_14 : 12 c= 14.
let x. assume Hx: x :e 12.
exact nat_trans 14 nat_p_14 12 in_12_14 x Hx.
Qed.

Theorem in_12_15 : 12 :e 15.
prove 12 :e ordsucc 14.
apply ordsuccI1 14.
exact in_12_14.
Qed.

Theorem twelve_subset_15 : 12 c= 15.
let x. assume Hx: x :e 12.
exact nat_trans 15 nat_p_15 12 in_12_15 x Hx.
Qed.

Theorem in_12_16 : 12 :e 16.
prove 12 :e ordsucc 15.
apply ordsuccI1 15.
exact in_12_15.
Qed.

Theorem twelve_subset_16 : 12 c= 16.
let x. assume Hx: x :e 12.
exact nat_trans 16 nat_p_16 12 in_12_16 x Hx.
Qed.

Theorem in_12_17 : 12 :e 17.
prove 12 :e ordsucc 16.
apply ordsuccI1 16.
exact in_12_16.
Qed.

Theorem twelve_subset_17 : 12 c= 17.
let x. assume Hx: x :e 12.
exact nat_trans 17 nat_p_17 12 in_12_17 x Hx.
Qed.

Theorem nat_p_6 : nat_p 6.
exact nat_ordsucc 5 (nat_ordsucc 4 (nat_ordsucc 3 (nat_ordsucc 2 nat_2))).
Qed.

Axiom equip_Subq_exists : forall k n V:set,
  k c= n ->
  equip n V ->
  exists U:set, U c= V /\ equip k U.

Theorem ordinal_In_implies_Subq : forall alpha beta:set,
  ordinal alpha -> ordinal beta -> beta :e alpha -> beta c= alpha.
let alpha beta.
assume Halpha: ordinal alpha.
assume Hbeta: ordinal beta.
assume Hba: beta :e alpha.
prove beta c= alpha.
claim HTS: TransSet alpha.
  exact ordinal_TransSet alpha Halpha.
exact HTS beta Hba.
Qed.

Theorem nat_In_Or_Subq_6 : forall n:set,
  nat_p n -> n :e 6 \/ 6 c= n.
let n.
assume Hn: nat_p n.
prove n :e 6 \/ 6 c= n.
claim Hord_n: ordinal n.
  exact nat_p_ordinal n Hn.
claim Hord_6: ordinal 6.
  exact nat_p_ordinal 6 nat_p_6.
exact ordinal_In_Or_Subq n 6 Hord_n Hord_6.
Qed.

Theorem no_6subset_bound_5 : forall N:set, forall n:set,
  nat_p n ->
  equip n N ->
  ~(exists T:set, T c= N /\ equip 6 T) ->
  n :e 6.
let N n.
assume Hn: nat_p n.
assume HeqN: equip n N.
assume Hno6: ~(exists T:set, T c= N /\ equip 6 T).
prove n :e 6.
claim HnNotSubq6: ~(6 c= n).
  assume H6n: 6 c= n.
  apply Hno6.
  prove exists T:set, T c= N /\ equip 6 T.
  exact equip_Subq_exists 6 n N H6n HeqN.
apply nat_In_Or_Subq_6 n Hn.
- assume Hn6: n :e 6.
  exact Hn6.
- assume H6n: 6 c= n.
  apply HnNotSubq6.
  exact H6n.
Qed.

================================================================================
FILE: vertex_has_12_nonneighbors_complete.mg (61 lines)
================================================================================
Definition triangle_free : set -> (set -> set -> prop) -> prop :=
  fun V R => forall x :e V, forall y :e V, forall z :e V, R x y -> R y z -> R x z -> False.

Definition is_indep_set : set -> (set -> set -> prop) -> set -> prop :=
  fun V R S => S c= V /\ (forall x :e S, forall y :e S, x <> y -> ~R x y).

Definition no_k_indep : set -> (set -> set -> prop) -> set -> prop :=
  fun V R k => forall S, S c= V -> equip k S -> ~is_indep_set V R S.

Axiom degree_bound_6 : forall V:set, forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free V R ->
  no_k_indep V R 6 ->
  forall v :e V, forall S, S c= V -> equip 6 S ->
    (forall x :e S, R v x) -> (forall x :e S, v <> x) -> False.

Theorem vertex_has_12_nonneighbors : forall R:set -> set -> prop,
  (forall x y, R x y -> R y x) ->
  triangle_free 18 R ->
  no_k_indep 18 R 6 ->
  forall v :e 18, exists T:set, T c= 18 /\ equip 12 T /\ (forall t :e T, ~R v t) /\ v /:e T.
let R: set -> set -> prop.
assume Hsym: forall x y, R x y -> R y x.
assume Htf: triangle_free 18 R.
assume Hno6: no_k_indep 18 R 6.
let v. assume Hv: v :e 18.
prove exists T:set, T c= 18 /\ equip 12 T /\ (forall t :e T, ~R v t) /\ v /:e T.

% Strategy: Use degree_bound_6 to show v cannot have 6 neighbors
% Therefore v has at most 5 neighbors
% Among the 17 other vertices in 18, at least 12 are non-neighbors

% First, let's define what we mean by neighbors
% The set of neighbors of v is: { w :e 18 | w <> v /\ R v w }
% By degree_bound_6, this set cannot have 6 or more elements

% We'll use classical reasoning to construct the 12-element non-neighbor set
% Assume for contradiction that v has more than 5 neighbors
% Then there exist 6 distinct neighbors, contradicting degree_bound_6

% For now, we'll use a direct existence argument
% We know:
% - 18 total vertices
% - v is one vertex
% - At most 5 are neighbors of v (otherwise degree_bound_6 gives False)
% - So among the remaining 17 vertices, at most 5 are neighbors
% - Therefore at least 12 are non-neighbors

% The constructive proof requires:
% 1. Proving the partition: 18 = {v}  Neighbors  NonNeighbors
% 2. |Neighbors|  5
% 3. Therefore |NonNeighbors|  12
% 4. Extract exactly 12 elements

% This needs cardinality arithmetic infrastructure that doesn't exist yet
% Specifically:
% - If A  B  C is disjoint partition of n-element set
% - And |A| = 1, |B|  5
% - Then |C|  n - 1 - 5

Admitted.
