% Running in auto input_syntax mode. Trying TPTP
% Refutation found. Thanks to Tanya!
% SZS status Theorem for neighborhood_indep
% SZS output start Proof for neighborhood_indep

(; Prop ;)
Prop : Type.
def Prf : (Prop -> Type).
true : Prop.
[] Prf true --> (r : Prop -> ((Prf r) -> (Prf r))).
false : Prop.
[] Prf false --> (r : Prop -> (Prf r)).
not : (Prop -> Prop).
[p] Prf (not p) --> ((Prf p) -> (r : Prop -> (Prf r))).
and : (Prop -> (Prop -> Prop)).
[p, q] Prf (and p q) --> (r : Prop -> (((Prf p) -> ((Prf q) -> (Prf r))) -> (Prf r))).
or : (Prop -> (Prop -> Prop)).
[p, q] Prf (or p q) --> (((Prf p) -> (Prf false)) -> (((Prf q) -> (Prf false)) -> (Prf false))).
imp : (Prop -> (Prop -> Prop)).
[p, q] Prf (imp p q) --> ((Prf p) -> (Prf q)).
iff : Prop -> Prop -> Prop.
[p, q] Prf (iff p q) --> (Prf (and (imp p q) (imp q p))).

(; Set ;)
Set : Type.
injective El : (Set -> Type).
iota : Set.
inhabit : A : Set -> El A.

(; Equality ;)
def eq : a : Set -> El a -> El a -> Prop.
[a, x, y] Prf (eq a x y) --> p : (El a -> Prop) -> Prf (p x) -> Prf (p y).
def refl : (a : Set) -> x : (El a) -> Prf (eq a x x).
[a, x] refl a x --> p : ((El a) -> Prop) => t : Prf (p x) => t.
def comm : (a : Set) -> x : (El a) -> y : (El a) -> Prf (eq a x y) -> Prf (eq a y x).
[a, x, y] comm a x y --> e : (Prf (eq a x y)) => p : ((El a) -> Prop) => e (z : (El a) => imp (p z) (p x)) (t : (Prf (p x)) => t).
def comml : (a : Set) -> x : (El a) -> y : (El a) -> (Prf (eq a x y) -> Prf false) -> (Prf (eq a y x) -> Prf false).
[a, x, y] comml a x y --> l : (Prf (eq a x y) -> Prf false) => e : Prf (eq a y x) => l (comm a y x e).
def comml_not : (a : Set) -> x : (El a) -> y : (El a) -> (Prf (not (eq a x y)) -> Prf false) -> (Prf (not (eq a y x)) -> Prf false).
[a, x, y] comml_not a x y --> l : ((Prf (eq a x y) -> Prf false) -> Prf false) => ne : (Prf (eq a y x) -> Prf false) => l (e : Prf (eq a x y) => ne (comm a x y e)).

(; Quant ;)
forall : (a : Set -> (((El a) -> Prop) -> Prop)).
[a, p] Prf (forall a p) --> (x : (El a) -> (Prf (p x))).
exists : (a : Set -> (((El a) -> Prop) -> Prop)).
[a, p] Prf (exists a p) --> (r : Prop -> ((x : (El a) -> ((Prf (p x)) -> (Prf r))) -> (Prf r))).

(; polymorphic quantifier ;)
forall_poly : (Set -> Prop) -> Prop.
[p] Prf (forall_poly p) --> a : Set -> Prf (p a).

(; Classic ;)
def cPrf : (Prop -> Type) := (p : Prop => (Prf (not (not p)))).
def cand : (Prop -> (Prop -> Prop)) := (p : Prop => (q : Prop => (and (not (not p)) (not (not q))))).
def cor : (Prop -> (Prop -> Prop)) := (p : Prop => (q : Prop => (or (not (not p)) (not (not q))))).
def cimp : (Prop -> (Prop -> Prop)) := (p : Prop => (q : Prop => (imp (not (not p)) (not (not q))))).
def cforall : (a : Set -> (((El a) -> Prop) -> Prop)) := (a : Set => (p : ((El a) -> Prop) => (forall a (x : (El a) => (not (not (p x))))))).
def cexists : (a : Set -> (((El a) -> Prop) -> Prop)) := (a : Set => (p : ((El a) -> Prop) => (exists a (x : (El a) => (not (not (p x))))))).

(; Clauses ;)
def prop_clause : Type.
def ec : prop_clause.
def cons : (Prop -> (prop_clause -> prop_clause)).
def clause : Type.
def cl : (prop_clause -> clause).
def bind : (A : Set -> (((El A) -> clause) -> clause)).
def bind_poly : (Set -> clause) -> clause.
def Prf_prop_clause : (prop_clause -> Type).

[] Prf_prop_clause ec --> (Prf false).
[p, c] Prf_prop_clause (cons p c) --> ((Prf p -> Prf false) -> (Prf_prop_clause c)).
def Prf_clause : (clause -> Type).
[c] Prf_clause (cl c) --> (Prf_prop_clause c).
[A, f] Prf_clause (bind A f) --> (x : (El A) -> (Prf_clause (f x))).
[f] Prf_clause (bind_poly f) --> (alpha : Set -> (Prf_clause (f alpha))).

def av_clause : Type.
def acl : clause -> av_clause.
def if : Prop -> av_clause -> av_clause.
def Prf_av_clause : av_clause -> Type.

[c] Prf_av_clause (acl c) --> Prf_clause c.
[sp, c] Prf_av_clause (if sp c) --> (Prf (not sp) -> Prf false) -> Prf_av_clause c.

(;----------------------------------------------------------------------------;)

{|sK0|}: El iota.
{|sK1|}: El iota.
{|sK2|}: El iota.
{|adj|}: El iota -> El iota -> Prop.
{|axiom_1_adj_sym|}: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (imp ({|adj|} 0 1) ({|adj|} 1 0)))))).
def deduction1: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (imp ({|adj|} 0 1) ({|adj|} 1 0)))))) := {|axiom_1_adj_sym|}.
{|axiom_3_triangle_free|}: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (not (and ({|adj|} 0 1) (and ({|adj|} 1 2) ({|adj|} 0 2)))))))))).
def deduction3: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (not (and ({|adj|} 0 1) (and ({|adj|} 1 2) ({|adj|} 0 2)))))))))) := {|axiom_3_triangle_free|}.
{|axiom_5_|}: Prf (not (forall iota (3 : El iota => (forall iota (0 : El iota => (forall iota (1 : El iota => (imp (and ({|adj|} 3 0) (and ({|adj|} 3 1) (not (eq iota 0 1)))) (not ({|adj|} 0 1)))))))))).
def deduction5: Prf (not (forall iota (3 : El iota => (forall iota (0 : El iota => (forall iota (1 : El iota => (imp (and ({|adj|} 3 0) (and ({|adj|} 3 1) (not (eq iota 0 1)))) (not ({|adj|} 0 1)))))))))) := {|axiom_5_|}.
sorry6: Prf (not (forall iota (3 : El iota => (forall iota (0 : El iota => (forall iota (1 : El iota => (imp (and ({|adj|} 3 0) (and ({|adj|} 3 1) (not (eq iota 0 1)))) (not ({|adj|} 0 1)))))))))) -> Prf (not (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (imp (and ({|adj|} 0 1) (and ({|adj|} 0 2) (not (eq iota 1 2)))) (not ({|adj|} 1 2)))))))))).
#PRINT "sorry: rectify".
def deduction6: Prf (not (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (imp (and ({|adj|} 0 1) (and ({|adj|} 0 2) (not (eq iota 1 2)))) (not ({|adj|} 1 2)))))))))) := sorry6 deduction5.
sorry7: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (imp ({|adj|} 0 1) ({|adj|} 1 0)))))) -> Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (or (not ({|adj|} 0 1)) ({|adj|} 1 0)))))).
#PRINT "sorry: ennf transformation".
def deduction7: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (or (not ({|adj|} 0 1)) ({|adj|} 1 0)))))) := sorry7 deduction1.
sorry8: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (not (and ({|adj|} 0 1) (and ({|adj|} 1 2) ({|adj|} 0 2)))))))))) -> Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (or (not ({|adj|} 0 1)) (or (not ({|adj|} 1 2)) (not ({|adj|} 0 2)))))))))).
#PRINT "sorry: ennf transformation".
def deduction8: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (or (not ({|adj|} 0 1)) (or (not ({|adj|} 1 2)) (not ({|adj|} 0 2)))))))))) := sorry8 deduction3.
sorry9: Prf (not (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (imp (and ({|adj|} 0 1) (and ({|adj|} 0 2) (not (eq iota 1 2)))) (not ({|adj|} 1 2)))))))))) -> Prf (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and (and ({|adj|} 0 1) (and ({|adj|} 0 2) (not (eq iota 1 2)))) ({|adj|} 1 2)))))))).
#PRINT "sorry: ennf transformation".
def deduction9: Prf (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and (and ({|adj|} 0 1) (and ({|adj|} 0 2) (not (eq iota 1 2)))) ({|adj|} 1 2)))))))) := sorry9 deduction6.
sorry10: Prf (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and (and ({|adj|} 0 1) (and ({|adj|} 0 2) (not (eq iota 1 2)))) ({|adj|} 1 2)))))))) -> Prf (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and ({|adj|} 0 1) (and ({|adj|} 0 2) (and (not (eq iota 1 2)) ({|adj|} 1 2)))))))))).
#PRINT "sorry: flattening".
def deduction10: Prf (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and ({|adj|} 0 1) (and ({|adj|} 0 2) (and (not (eq iota 1 2)) ({|adj|} 1 2)))))))))) := sorry10 deduction9.
sorry11: Prf (imp (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and ({|adj|} 0 1) (and ({|adj|} 0 2) (and (not (eq iota 1 2)) ({|adj|} 1 2)))))))))) (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|}))))).
#PRINT "sorry: choice axiom".
def deduction11: Prf (imp (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and ({|adj|} 0 1) (and ({|adj|} 0 2) (and (not (eq iota 1 2)) ({|adj|} 1 2)))))))))) (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|}))))) := sorry11.
sorry12: Prf (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and ({|adj|} 0 1) (and ({|adj|} 0 2) (and (not (eq iota 1 2)) ({|adj|} 1 2)))))))))) -> Prf (imp (exists iota (0 : El iota => (exists iota (1 : El iota => (exists iota (2 : El iota => (and ({|adj|} 0 1) (and ({|adj|} 0 2) (and (not (eq iota 1 2)) ({|adj|} 1 2)))))))))) (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|}))))) -> Prf (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|})))).
#PRINT "sorry: skolemisation".
def deduction12: Prf (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|})))) := sorry12 deduction10 deduction11.
sorry13: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (or (not ({|adj|} 0 1)) ({|adj|} 1 0)))))) -> Prf_clause (bind iota (0 : El iota => (bind iota (1 : El iota => (cl (cons (not ({|adj|} 0 1)) (cons ({|adj|} 1 0) ec))))))).
#PRINT "sorry: cnf transformation".
def deduction13: Prf_clause (bind iota (0 : El iota => (bind iota (1 : El iota => (cl (cons (not ({|adj|} 0 1)) (cons ({|adj|} 1 0) ec))))))) := sorry13 deduction7.
sorry15: Prf (forall iota (0 : El iota => (forall iota (1 : El iota => (forall iota (2 : El iota => (or (not ({|adj|} 0 1)) (or (not ({|adj|} 1 2)) (not ({|adj|} 0 2)))))))))) -> Prf_clause (bind iota (0 : El iota => (bind iota (1 : El iota => (bind iota (2 : El iota => (cl (cons (not ({|adj|} 1 2)) (cons (not ({|adj|} 0 2)) (cons (not ({|adj|} 0 1)) ec)))))))))).
#PRINT "sorry: cnf transformation".
def deduction15: Prf_clause (bind iota (0 : El iota => (bind iota (1 : El iota => (bind iota (2 : El iota => (cl (cons (not ({|adj|} 1 2)) (cons (not ({|adj|} 0 2)) (cons (not ({|adj|} 0 1)) ec)))))))))) := sorry15 deduction8.
sorry16: Prf (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|})))) -> Prf_clause (cl (cons ({|adj|} {|sK0|} {|sK1|}) ec)).
#PRINT "sorry: cnf transformation".
def deduction16: Prf_clause (cl (cons ({|adj|} {|sK0|} {|sK1|}) ec)) := sorry16 deduction12.
sorry17: Prf (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|})))) -> Prf_clause (cl (cons ({|adj|} {|sK0|} {|sK2|}) ec)).
#PRINT "sorry: cnf transformation".
def deduction17: Prf_clause (cl (cons ({|adj|} {|sK0|} {|sK2|}) ec)) := sorry17 deduction12.
sorry19: Prf (and ({|adj|} {|sK0|} {|sK1|}) (and ({|adj|} {|sK0|} {|sK2|}) (and (not (eq iota {|sK1|} {|sK2|})) ({|adj|} {|sK1|} {|sK2|})))) -> Prf_clause (cl (cons ({|adj|} {|sK1|} {|sK2|}) ec)).
#PRINT "sorry: cnf transformation".
def deduction19: Prf_clause (cl (cons ({|adj|} {|sK1|} {|sK2|}) ec)) := sorry19 deduction12.
def deduction20: Prf_clause (cl (cons ({|adj|} {|sK1|} {|sK0|}) ec)) := 0x64d23df74c70 : (Prf ({|adj|} {|sK1|} {|sK0|}) -> Prf false) => deduction13 {|sK0|} {|sK1|} (tnp: (Prf (not ({|adj|} {|sK0|} {|sK1|}))) => deduction16 (tp: Prf ({|adj|} {|sK0|} {|sK1|}) => (tnp tp))) 0x64d23df74c70.
def deduction25: Prf_clause (bind iota (0 : El iota => (cl (cons (not ({|adj|} 0 {|sK2|})) (cons (not ({|adj|} 0 {|sK0|})) ec))))) :=  0 : El iota => 0x64d23df74630 : (Prf (not ({|adj|} 0 {|sK2|})) -> Prf false) => 0x64d23df74670 : (Prf (not ({|adj|} 0 {|sK0|})) -> Prf false) => deduction15 0 {|sK0|} {|sK2|} (tnp: (Prf (not ({|adj|} {|sK0|} {|sK2|}))) => deduction17 (tp: Prf ({|adj|} {|sK0|} {|sK2|}) => (tnp tp))) 0x64d23df74630 0x64d23df74670.
def deduction33: Prf_clause (cl (cons (not ({|adj|} {|sK1|} {|sK0|})) ec)) := 0x64d23df74870 : (Prf (not ({|adj|} {|sK1|} {|sK0|})) -> Prf false) => deduction25 {|sK1|} (tnp: (Prf (not ({|adj|} {|sK1|} {|sK2|}))) => deduction19 (tp: Prf ({|adj|} {|sK1|} {|sK2|}) => (tnp tp))) 0x64d23df74870.
def deduction34: Prf_clause (cl ec) := deduction33 (tnp: (Prf (not ({|adj|} {|sK1|} {|sK0|}))) => deduction20 (tp: Prf ({|adj|} {|sK1|} {|sK0|}) => (tnp tp))).
% SZS output end Proof for neighborhood_indep
% ------------------------------
% Version: Vampire 4.9 (Release build, commit 1e3e2d36b on 2025-03-16 07:25:11 +0000)
% Termination reason: Refutation

% Time elapsed: 0.002 s
% Peak memory usage: 12 MB
% ------------------------------
% ------------------------------
