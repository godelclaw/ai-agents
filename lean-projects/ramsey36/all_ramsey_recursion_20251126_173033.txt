# Ramsey Recursion Completion Request

## Context: We have R(3,3)=6 and R(3,4)=9 COMPLETE, now formalizing general recursion

We successfully completed the R(3,3)=6 proof using the pigeonhole principle.
Now we're formalizing the Greenwood-Gleason (1955) recursion theorem that unlocks all Ramsey numbers.

## What We Have: Greenwood-Gleason Theorem 2 (1955)

From `related_literature/div-class-title-combinatorial-relations-and-chromatic-graphs-div.txt`:

```
THEOREM 2. n(k, m) < n(k ‚Äî 1, m) + n(k, m ‚Äî 1).

Proof. Let T be any set of n(k ‚Äî 1, m) + n(k, m ‚Äî 1) vertices. Form a
chromatic graph by coloring each interconnecting segment either red or blue.
Select one vertex and call it a. For vertex a consider the two associated
numbers:
n‚ÇÅ = number of vertices such that the segments joining them to a are red,
n‚ÇÇ = number of vertices such that the segments joining them to a are blue.
Call these sets of vertices T‚ÇÅ and T‚ÇÇ.

Since all vertices other than a belong to either T‚ÇÅ or T‚ÇÇ, one obtains
n‚ÇÅ + n‚ÇÇ + 1 = n(k ‚Äî 1, m) + n(k, m ‚Äî 1).

If n‚ÇÅ < n(k ‚Äî 1,m), then n‚ÇÇ > n(k, m ‚Äî 1) and one selects the set T‚ÇÇ.
In T‚ÇÇ there is either a red interconnected set S‚ÇÅ with k vertices or a blue
interconnected set S‚ÇÇ with m ‚Äî 1 vertices. If the latter holds, the set {S‚ÇÇ + vertex
a} is a blue interconnected set with m vertices. Hence the inequality of
Theorem 2 is established for this case.

If n‚ÇÅ > n(k ‚Äî 1, m), one selects the set T‚ÇÅ. In T‚ÇÅ there is either a red
interconnected set S‚ÇÉ with k ‚Äî 1 vertices or a blue interconnected set S‚ÇÑ
with m vertices. In the first case the set {S‚ÇÉ + vertex a} is seen to be a red
interconnected set with k vertices. The proof of Theorem 2 is now complete.
```

## What We've Formalized (BUILDS SUCCESSFULLY)

File: `Ramsey36/SmallRamsey.lean` lines 329-407

```lean
theorem ramsey_recursion {r s : ‚Ñï} (hr : r ‚â• 2) (hs : s ‚â• 2)
    (h_r : 0 < ramseyNumber (r-1) s ‚àß
           ‚àÄ (G : SimpleGraph (Fin (ramseyNumber (r-1) s))) [DecidableRel G.Adj],
           HasRamseyProperty (r-1) s G)
    (h_s : 0 < ramseyNumber r (s-1) ‚àß
           ‚àÄ (G : SimpleGraph (Fin (ramseyNumber r (s-1)))) [DecidableRel G.Adj],
           HasRamseyProperty r (s-1) G) :
    ‚àÄ (G : SimpleGraph (Fin (ramseyNumber (r-1) s + ramseyNumber r (s-1)))) [DecidableRel G.Adj],
    HasRamseyProperty r s G := by
  intro G inst
  unfold HasRamseyProperty

  -- Pick vertex v and partition others into adjacent/nonadjacent
  let n := ramseyNumber (r-1) s + ramseyNumber r (s-1)
  have h_n_pos : 0 < n := by omega
  let v : Fin n := ‚ü®0, h_n_pos‚ü©
  let others := (Finset.univ : Finset (Fin n)).erase v
  let adjacent := others.filter (fun u => G.Adj v u)
  let nonadjacent := others.filter (fun u => ¬¨ G.Adj v u)

  -- Basic partition properties ‚úÖ COMPLETE
  have h_card : others.card = n - 1 := by
    simp [others, Fintype.card_fin]
  have h_partition : adjacent ‚à™ nonadjacent = others := by
    ext u; simp [adjacent, nonadjacent]; tauto
  have h_disjoint : Disjoint adjacent nonadjacent := by
    rw [Finset.disjoint_iff_inter_eq_empty]
    ext u; simp [adjacent, nonadjacent]; tauto
  have h_sum : adjacent.card + nonadjacent.card = n - 1 := by
    have := Finset.card_union_of_disjoint h_disjoint
    rw [h_partition] at this
    rw [‚Üê this, h_card]

  -- Pigeonhole: one partition has enough vertices ‚úÖ COMPLETE
  have h_pigeon : adjacent.card ‚â• ramseyNumber r (s-1) ‚à®
                   nonadjacent.card ‚â• ramseyNumber (r-1) s := by
    by_contra h_not
    push_neg at h_not
    have : adjacent.card + nonadjacent.card < ramseyNumber r (s-1) + ramseyNumber (r-1) s := by
      omega
    rw [h_sum] at this
    have : n - 1 < n := by omega
    omega

  rcases h_pigeon with h_adj | h_nonadj

  ¬∑ -- Case 1: adjacent has ‚â• R(r, s-1) vertices
    -- Greenwood-Gleason: "If n‚ÇÅ ‚â• n(k-1,m), one selects the set T‚ÇÅ.
    -- In T‚ÇÅ there is either a red interconnected set S‚ÇÉ with k-1 vertices
    -- or a blue interconnected set S‚ÇÑ with m vertices.
    -- In the first case the set {S‚ÇÉ + vertex a} is a red interconnected set with k vertices."

    -- Get subset of adjacent of size exactly R(r,s-1)
    obtain ‚ü®S, hS_sub, hS_card‚ü© := Finset.exists_subset_card_eq h_adj

    -- Apply inductive hypothesis to induced subgraph on S
    -- This requires Fin (R(r,s-1)) ‚Ü™ S machinery which is complex
    -- For now, assume we can apply h_s to get property on S
    sorry -- TODO: Apply h_s.2 to induced subgraph on S, lift result

  ¬∑ -- Case 2: nonadjacent has ‚â• R(r-1, s) vertices
    -- Greenwood-Gleason: "If n‚ÇÅ < n(k-1,m), then n‚ÇÇ > n(k,m-1) and one selects T‚ÇÇ.
    -- In T‚ÇÇ there is either a red interconnected set S‚ÇÅ with k vertices
    -- or a blue interconnected set S‚ÇÇ with m-1 vertices.
    -- If the latter holds, the set {S‚ÇÇ + vertex a} is a blue interconnected set with m vertices."

    -- Get subset of nonadjacent of size exactly R(r-1,s)
    obtain ‚ü®S, hS_sub, hS_card‚ü© := Finset.exists_subset_card_eq h_nonadj

    -- Apply inductive hypothesis to induced subgraph on S
    sorry -- TODO: Apply h_r.2 to induced subgraph on S, lift result
```

## The Problem: Mapping Between Fin Types and Finsets

We have:
- `S : Finset (Fin n)` with `S.card = ramseyNumber r (s-1)` (or `ramseyNumber (r-1) s`)
- Hypothesis `h_s.2` which works on `SimpleGraph (Fin (ramseyNumber r (s-1)))`
- Need to apply hypothesis to induced subgraph on S and lift result back

## Mathlib Infrastructure Available

From `Mathlib/Combinatorics/SimpleGraph/Clique.lean`:

```lean
/-- If a set of vertices `A` is an `n`-clique in subgraph of `G` induced by a superset of `A`,
its embedding is an `n`-clique in `G`. -/
theorem IsNClique.of_induce {S : Subgraph G} {F : Set Œ±} {s : Finset { x // x ‚àà F }} {n : ‚Ñï}
    (cc : (S.induce F).coe.IsNClique n s) :
    G.IsNClique n (Finset.map ‚ü®Subtype.val, Subtype.val_injective‚ü© s)

/-- The embedding of an `n`-independent set of an induced subgraph is an
`n`-independent set in `G` and vice versa. -/
theorem isNIndepSet_induce {F : Set Œ±} {s : Finset { x // x ‚àà F }} {n : ‚Ñï} :
    ((‚ä§ : Subgraph G).induce F).coe.IsNIndepSet n ‚Üës ‚Üî
    G.IsNIndepSet n (Finset.map ‚ü®Subtype.val, Subtype.val_injective‚ü© s)
```

Also from `Mathlib/Combinatorics/SimpleGraph/Basic.lean`:
- `SimpleGraph.induce : (s : Set V) ‚Üí SimpleGraph V` for induced subgraphs

## Example: How degree_ge_three works with Fin 6 ‚âÉ ‚ÜëH6

From `Ramsey36/SmallRamsey.lean` lines 732-770, we handle similar mapping:

```lean
-- Since |H6| = 6, there exists a bijection Fin 6 ‚âÉ ‚ÜëH6
have h_card_eq : Fintype.card (Fin 6) = Fintype.card (‚ÜëH6 : Set (Fin 9)) := by
  simp only [Fintype.card_fin]
  exact h_H6_card_type.symm

let f : Fin 6 ‚âÉ ‚ÜëH6 := Fintype.equivOfCardEq h_card_eq

-- Map graph via equivalence
let G_sub := G.comap (Equiv.toEmbedding f.symm)

-- Apply R(3,3)=6
have h_ramsey_sub := hasRamseyProperty_3_3_6.2 G_sub

-- Lift result back to G
rcases h_ramsey_sub with ‚ü®clique_sub, h_clique_sub‚ü© | ‚ü®indep_sub, h_indep_sub‚ü©
```

## What We Need Help With

**For each case (adjacent and nonadjacent), complete the sorry by:**

1. Creating an equivalence `Fin (ramseyNumber ...) ‚âÉ ‚ÜëS` using `Fintype.equivOfCardEq`
2. Mapping the graph via `G.comap` or using induced subgraph
3. Applying the inductive hypothesis (h_r.2 or h_s.2)
4. Lifting the clique/independent result back to G
5. For clique case: adding vertex v to get size r (or s) clique
6. For independent case: adding vertex v to get size s (or r) independent

The mathematical proof is clear from Greenwood-Gleason - we just need the Lean machinery!

## Definitions We're Using

```lean
-- From Ramsey36/Basic.lean
def HasRamseyProperty (k l : ‚Ñï) (G : SimpleGraph V) : Prop :=
  (‚àÉ s : Finset V, G.IsNClique k s) ‚à® (‚àÉ s : Finset V, G.IsNIndepSet l s)

-- IsNClique means all pairs adjacent + cardinality = n
-- IsNIndepSet means no pairs adjacent + cardinality = n
```

## Success Criteria

Replace the 2 sorries with complete proofs that:
1. Extract subset S as induced subgraph
2. Apply inductive hypothesis
3. Lift result (clique or independent) back to G
4. Handle the "add vertex v" case correctly

This will complete the Greenwood-Gleason recursion and unlock all small Ramsey numbers! üéØ

## Current recursion theorem code (lines 329-407)

```lean
/-- **Ramsey Recursion Theorem**: R(r,s) ‚â§ R(r-1,s) + R(r,s-1)

This is the fundamental recursion relation for Ramsey numbers. Given a graph on
R(r-1,s) + R(r,s-1) vertices, pick any vertex v and partition the remaining vertices
into those adjacent to v and those not adjacent to v. By pigeonhole, one partition
has enough vertices to apply the inductive hypothesis.

This generalizes the proof technique used for R(3,3)=6.
-/
theorem ramsey_recursion {r s : ‚Ñï} (hr : r ‚â• 2) (hs : s ‚â• 2)
    (h_r : 0 < ramseyNumber (r-1) s ‚àß
           ‚àÄ (G : SimpleGraph (Fin (ramseyNumber (r-1) s))) [DecidableRel G.Adj],
           HasRamseyProperty (r-1) s G)
    (h_s : 0 < ramseyNumber r (s-1) ‚àß
           ‚àÄ (G : SimpleGraph (Fin (ramseyNumber r (s-1)))) [DecidableRel G.Adj],
           HasRamseyProperty r (s-1) G) :
    ‚àÄ (G : SimpleGraph (Fin (ramseyNumber (r-1) s + ramseyNumber r (s-1)))) [DecidableRel G.Adj],
    HasRamseyProperty r s G := by
  intro G inst
  unfold HasRamseyProperty

  -- Pick vertex v and partition others into adjacent/nonadjacent
  let n := ramseyNumber (r-1) s + ramseyNumber r (s-1)
  have h_n_pos : 0 < n := by omega
  let v : Fin n := ‚ü®0, h_n_pos‚ü©
  let others := (Finset.univ : Finset (Fin n)).erase v
  let adjacent := others.filter (fun u => G.Adj v u)
  let nonadjacent := others.filter (fun u => ¬¨ G.Adj v u)

  -- Basic partition properties
  have h_card : others.card = n - 1 := by
    simp [others, Fintype.card_fin]
  have h_partition : adjacent ‚à™ nonadjacent = others := by
    ext u; simp [adjacent, nonadjacent]; tauto
  have h_disjoint : Disjoint adjacent nonadjacent := by
    rw [Finset.disjoint_iff_inter_eq_empty]
    ext u; simp [adjacent, nonadjacent]; tauto
  have h_sum : adjacent.card + nonadjacent.card = n - 1 := by
    have := Finset.card_union_of_disjoint h_disjoint
    rw [h_partition] at this
    rw [‚Üê this, h_card]

  -- Pigeonhole: one partition has enough vertices
  have h_pigeon : adjacent.card ‚â• ramseyNumber r (s-1) ‚à®
                   nonadjacent.card ‚â• ramseyNumber (r-1) s := by
    by_contra h_not
    push_neg at h_not
    have : adjacent.card + nonadjacent.card < ramseyNumber r (s-1) + ramseyNumber (r-1) s := by
      omega
    rw [h_sum] at this
    have : n - 1 < n := by omega
    omega

  rcases h_pigeon with h_adj | h_nonadj

  ¬∑ -- Case 1: adjacent has ‚â• R(r, s-1) vertices
    -- Greenwood-Gleason: "If n‚ÇÅ ‚â• n(k-1,m), one selects the set T‚ÇÅ.
    -- In T‚ÇÅ there is either a red interconnected set S‚ÇÉ with k-1 vertices
    -- or a blue interconnected set S‚ÇÑ with m vertices.
    -- In the first case the set {S‚ÇÉ + vertex a} is a red interconnected set with k vertices."

    -- Get subset of adjacent of size exactly R(r,s-1)
    obtain ‚ü®S, hS_sub, hS_card‚ü© := Finset.exists_subset_card_eq h_adj

    -- Apply inductive hypothesis to induced subgraph on S
    -- This requires Fin (R(r,s-1)) ‚Ü™ S machinery which is complex
    -- For now, assume we can apply h_s to get property on S
    sorry -- TODO: Apply h_s.2 to induced subgraph on S, lift result

  ¬∑ -- Case 2: nonadjacent has ‚â• R(r-1, s) vertices
    -- Greenwood-Gleason: "If n‚ÇÅ < n(k-1,m), then n‚ÇÇ > n(k,m-1) and one selects T‚ÇÇ.
    -- In T‚ÇÇ there is either a red interconnected set S‚ÇÅ with k vertices
    -- or a blue interconnected set S‚ÇÇ with m-1 vertices.
    -- If the latter holds, the set {S‚ÇÇ + vertex a} is a blue interconnected set with m vertices."

    -- Get subset of nonadjacent of size exactly R(r-1,s)
    obtain ‚ü®S, hS_sub, hS_card‚ü© := Finset.exists_subset_card_eq h_nonadj

    -- Apply inductive hypothesis to induced subgraph on S
```

