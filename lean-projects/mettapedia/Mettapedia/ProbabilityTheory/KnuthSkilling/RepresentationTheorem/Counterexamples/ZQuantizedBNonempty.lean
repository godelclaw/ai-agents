import Mathlib.Data.NNReal.Basic
import Mettapedia.ProbabilityTheory.KnuthSkilling.RepresentationTheorem.Core.Induction.ThetaPrime

namespace Mettapedia.ProbabilityTheory.KnuthSkilling.RepresentationTheorem.Counterexamples

open Classical
open scoped NNReal

open Mettapedia.ProbabilityTheory.KnuthSkilling
open KnuthSkillingAlgebra

/-!
# Counterexample: `ZQuantized_chooseδ_if_B_nonempty` can fail even in a commutative additive model

In the additive model `α = ℝ≥0` with `op := (+)` and representation `Θ = id` on the old μ-grid,
take the old grid generated by the single atom `1` and choose a new atom `d = 2/3`.

Then:
- `B` is globally nonempty, since `d^3 = 2` is already on the old grid;
- `chooseδ` (in its `B ≠ ∅` branch) equals the B-statistic `2/3`;
- but `ZQuantized F R (chooseδ …)` fails because `Θ(1) = 1` is not an integer multiple of `2/3`.

So the helper hypothesis `ZQuantized_chooseδ_if_B_nonempty` (used by the current extension theorem
in `.../Core/Induction/ThetaPrime.lean`) is not derivable in general.
-/

namespace ZQuantizedBNonempty

section

private lemma nat_iterate_add_left_eq_mul (x : ℝ≥0) : ∀ n : ℕ,
    Nat.iterate (fun z : ℝ≥0 => x + z) n x = ((n + 1 : ℕ) : ℝ≥0) * x
  | 0 => by simp
  | n + 1 => by
      have ih := nat_iterate_add_left_eq_mul x n
      have h_step :
          Nat.iterate (fun z : ℝ≥0 => x + z) (n + 1) x
            = x + Nat.iterate (fun z : ℝ≥0 => x + z) n x := by
        simp [Function.iterate_succ_apply']
      rw [h_step, ih]
      have hcoeff : (((n + 1 : ℕ) : ℝ≥0) + 1) = ((n + 2 : ℕ) : ℝ≥0) := by
        have hn : (n + 1 + 1 : ℕ) = n + 2 := by omega
        calc
          ((n + 1 : ℕ) : ℝ≥0) + 1 = ((n + 1 + 1 : ℕ) : ℝ≥0) := by
            simp [Nat.cast_add]
          _ = ((n + 2 : ℕ) : ℝ≥0) := by
            simp [hn]
      calc
        x + ((n + 1 : ℕ) : ℝ≥0) * x
            = ((n + 1 : ℕ) : ℝ≥0) * x + x := by
                simp [add_comm]
        _ = (((n + 1 : ℕ) : ℝ≥0) + 1) * x := by
                simp [add_mul, one_mul]
        _ = ((n + 2 : ℕ) : ℝ≥0) * x := by
                exact congrArg (fun a : ℝ≥0 => a * x) hcoeff

-- A concrete Knuth–Skilling algebra: `ℝ≥0` with `op := (· + ·)` and `ident := 0`.
-- We keep this `noncomputable` because the underlying `LinearOrder` on `ℝ` is noncomputable.
noncomputable local instance : KnuthSkillingAlgebra ℝ≥0 where
  op := (· + ·)
  ident := 0
  op_assoc := by intro x y z; simp [add_assoc]
  op_ident_right := by intro x; simp
  op_ident_left := by intro x; simp
  op_strictMono_left := by intro y x₁ x₂ hx; exact add_lt_add_right hx y
  op_strictMono_right := by intro x y₁ y₂ hy; exact add_lt_add_left hy x
  op_archimedean := by
    intro x y hx
    -- Choose `n` so that `(y / x) < n` in ℝ, then `y < n * x` hence `y < (n+1) * x`.
    have hx' : (0 : ℝ) < (x : ℝ) := by exact_mod_cast hx
    obtain ⟨n, hn⟩ : ∃ n : ℕ, (y : ℝ) / (x : ℝ) < n :=
      exists_nat_gt ((y : ℝ) / (x : ℝ))
    refine ⟨n, ?_⟩
    have hy_lt_nx : (y : ℝ) < (n : ℝ) * (x : ℝ) := by
      have := mul_lt_mul_of_pos_right hn hx'
      simpa [div_eq_mul_inv, mul_assoc, inv_mul_cancel₀ (ne_of_gt hx'), mul_one] using this
    have hy_lt_n1x : (y : ℝ) < ((n + 1 : ℕ) : ℝ) * (x : ℝ) := by
      have hx_nonneg : (0 : ℝ) ≤ (x : ℝ) := le_of_lt hx'
      have hn_le : (n : ℝ) * (x : ℝ) ≤ ((n + 1 : ℕ) : ℝ) * (x : ℝ) := by
        gcongr
        exact Nat.cast_le.2 (Nat.le_succ n)
      exact lt_of_lt_of_le hy_lt_nx hn_le
    -- Coerce the real inequality back to `ℝ≥0`.
    have hy_lt_n1x' : y < ((n + 1 : ℕ) : ℝ≥0) * x := by
      exact_mod_cast hy_lt_n1x
    -- Compute the iterate explicitly: repeated left-addition by `x`.
    have h_iter : Nat.iterate (fun z : ℝ≥0 => x + z) n x = ((n + 1 : ℕ) : ℝ≥0) * x :=
      nat_iterate_add_left_eq_mul x n
    -- Conclude the Archimedean inequality.
    have : y < Nat.iterate (fun z : ℝ≥0 => x + z) n x := by
      simpa [h_iter] using hy_lt_n1x'
    simpa [KnuthSkillingAlgebraBase.op] using this
  ident_le := by intro x; exact bot_le

-- Singleton atom family with atom `1`.
noncomputable def F1 : AtomFamily ℝ≥0 1 :=
  singletonAtomFamily (α := ℝ≥0) 1 (by
    simp [KnuthSkillingAlgebraBase.ident])

private noncomputable def i0 : Fin 1 := ⟨0, by decide⟩

private lemma multi1_eq_const (t : Multi 1) : t = fun _ : Fin 1 => t i0 := by
  funext i
  simpa [i0] using congrArg t (Fin.eq_zero i)

private lemma iterate_op_add_eq_mul (x : ℝ≥0) : ∀ n : ℕ, iterate_op x n = (n : ℝ≥0) * x
  | 0 => by
      simp [iterate_op, KnuthSkillingAlgebraBase.ident]
  | n + 1 => by
      have ih := iterate_op_add_eq_mul x n
      calc
        iterate_op x (n + 1) = x + iterate_op x n := by
          simp [iterate_op, KnuthSkillingAlgebraBase.op]
        _ = x + (n : ℝ≥0) * x := by simp [ih]
        _ = (n : ℝ≥0) * x + x := by
              simp [add_comm]
        _ = ((n : ℝ≥0) + 1) * x := by
              simp [add_mul, one_mul]
        _ = ((n + 1 : ℕ) : ℝ≥0) * x := by
              simp [Nat.cast_add, Nat.cast_one]

private lemma iterate_op_one_eq_natCast (n : ℕ) : iterate_op (1 : ℝ≥0) n = (n : ℝ≥0) := by
  simp [iterate_op_add_eq_mul]

private lemma mu_F1 (t : Multi 1) : mu F1 t = (t i0 : ℝ≥0) := by
  have ht : t = fun _ : Fin 1 => t i0 := multi1_eq_const t
  have h_ident_lt_one : (KnuthSkillingAlgebraBase.ident : ℝ≥0) < 1 := by
    simp [KnuthSkillingAlgebraBase.ident]
  calc
    mu F1 t = mu F1 (fun _ : Fin 1 => t i0) := by
      simpa using congrArg (fun r : Multi 1 => mu F1 r) ht
    _ = iterate_op (1 : ℝ≥0) (t i0) := by
          simpa [F1] using
            (mu_singleton (α := ℝ≥0) (a := (1 : ℝ≥0)) (ha := h_ident_lt_one) (n := t i0))
    _ = (t i0 : ℝ≥0) := by
          simp [iterate_op_one_eq_natCast]

-- A simple representation on the μ-grid: `Θ_grid(x) = (x : ℝ)`.
noncomputable def R1 : MultiGridRep F1 where
  Θ_grid := fun x => (x.1 : ℝ)
  strictMono := by
    intro x y hxy
    exact_mod_cast hxy
  add := by
    intro r s
    have hμr : mu F1 r = (r i0 : ℝ≥0) := mu_F1 r
    have hμs : mu F1 s = (s i0 : ℝ≥0) := mu_F1 s
    have hμrs : mu F1 (fun i => r i + s i) = ((r i0 + s i0 : ℕ) : ℝ≥0) := by
      simpa using (mu_F1 (fun i => r i + s i))
    change ((mu F1 (fun i => r i + s i) : ℝ≥0) : ℝ) =
        ((mu F1 r : ℝ≥0) : ℝ) + ((mu F1 s : ℝ≥0) : ℝ)
    simp [hμr, hμs, hμrs, Nat.cast_add]
  ident_eq_zero := by
    simp [KnuthSkillingAlgebraBase.ident]

-- New atom: d = 2/3 > 0.
noncomputable def d : ℝ≥0 := (2 : ℝ≥0) / 3

lemma d_pos : (KnuthSkillingAlgebraBase.ident : ℝ≥0) < d := by
  simp [d, KnuthSkillingAlgebraBase.ident]

private lemma chooseδ_eq_two_div_three :
    chooseδ (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos = (2 : ℝ) / 3 := by
  classical
  let r2 : Multi 1 := fun _ => 2
  have h_iter : iterate_op d 3 = (3 : ℝ≥0) * d := by
    simpa using iterate_op_add_eq_mul d 3
  have h3d : (3 : ℝ≥0) * d = (2 : ℝ≥0) := by
    ext
    norm_num [d]
  have hr2B : r2 ∈ extensionSetB F1 d 3 := by
    simp [extensionSetB, Set.mem_setOf_eq, r2, mu_F1, h_iter, h3d]
  have IH : GridBridge F1 := gridBridge_of_k_eq_one (F := F1)
  have hδB :
      separationStatistic R1 r2 3 (by decide) =
        chooseδ (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos :=
    chooseδ_B_bound (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 IH d d_pos r2 3 (by decide) hr2B
  have hstat : separationStatistic R1 r2 3 (by decide) = (2 : ℝ) / 3 := by
    simp [separationStatistic, R1, r2, mu_F1]
  -- Convert `separationStatistic = chooseδ` into a concrete evaluation.
  calc
    chooseδ (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos
        = separationStatistic R1 r2 3 (by decide) := by simpa using hδB.symm
    _ = (2 : ℝ) / 3 := hstat

theorem not_ZQuantized_chooseδ_if_B_nonempty_example :
    ¬ ZQuantized_chooseδ_if_B_nonempty (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos := by
  intro hZQ_if
  let r2 : Multi 1 := fun _ => 2
  have hB : ∃ r u, 0 < u ∧ r ∈ extensionSetB F1 d u := by
    refine ⟨r2, 3, by decide, ?_⟩
    have h_iter : iterate_op d 3 = (3 : ℝ≥0) * d := by
      simpa using iterate_op_add_eq_mul d 3
    have h3d : (3 : ℝ≥0) * d = (2 : ℝ≥0) := by
      ext
      norm_num [d]
    simp [extensionSetB, Set.mem_setOf_eq, r2, mu_F1, h_iter, h3d]

  have hQZ :
      ZQuantized F1 R1 (chooseδ (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos) :=
    hZQ_if hB

  have hδ :
      chooseδ (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos = (2 : ℝ) / 3 :=
    chooseδ_eq_two_div_three

  -- Apply ZQuantized to the old μ-grid value `μ(1) = 1`.
  let r1 : Multi 1 := fun _ => 1
  rcases hQZ r1 with ⟨m, hm⟩
  have hm' : (m : ℝ) * ((2 : ℝ) / 3) = 1 := by
    -- `Θ_grid(μ(1)) = 1` and `δ = 2/3`.
    have : (m : ℝ) * chooseδ (α := ℝ≥0) (hk := (le_rfl : (1 : ℕ) ≥ 1)) R1 d d_pos = 1 := by
      -- From `hm : Θ(μ(1)) = m*δ`.
      -- Note: `Θ(μ(1)) = 1` in this representation.
      -- Rewrite in the direction needed for `nlinarith`.
      simpa [R1, mu_F1, r1] using hm.symm
    simpa [hδ] using this

  -- But no integer multiple of `2/3` equals `1`.
  have : False := by
    -- Convert to `2*m = 3` in ℤ, hence `2 ∣ 3`, contradiction.
    have h : (2 : ℝ) * (m : ℝ) = 3 := by
      nlinarith [hm']
    have h' : ((2 : ℤ) : ℝ) * (m : ℝ) = ((3 : ℤ) : ℝ) := by
      simpa using h
    have h'' : ((2 * m : ℤ) : ℝ) = ((3 : ℤ) : ℝ) := by
      simpa [Int.cast_mul] using h'
    have hm_int : (2 * m : ℤ) = 3 := Int.cast_inj.mp h''
    have hdiv : (2 : ℤ) ∣ (3 : ℤ) := by
      refine ⟨m, ?_⟩
      simpa [mul_comm, mul_left_comm, mul_assoc] using hm_int.symm
    have hnot : ¬ (2 : ℤ) ∣ (3 : ℤ) := by decide
    exact hnot hdiv
  exact this

end

end ZQuantizedBNonempty

end Mettapedia.ProbabilityTheory.KnuthSkilling.RepresentationTheorem.Counterexamples
