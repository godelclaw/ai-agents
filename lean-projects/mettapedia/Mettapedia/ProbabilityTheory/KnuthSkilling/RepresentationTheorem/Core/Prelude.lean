/-
# K&S Representation Theorem (Prelude): Associativity → Representation → Commutativity

This file provides the core K&S Appendix A construction that proves:

> For any Knuth-Skilling algebra, there exists an additive representation Θ : α → ℝ,
> and consequently the operation is commutative.

**Reference**: Knuth & Skilling, "Foundations of Inference" (2012), Appendix A
(arXiv lines 1292-1922)

**Key insight**: Commutativity is DERIVED, not assumed!
  "Associativity + Order ⟹ Additivity allowed ⟹ Commutativity" (line 1166)

**Proof structure** (grid-based bootstrapping):
1. One type base case: m(r of a) = r·a (linear grid)
2. A/B/C sets partition old values relative to new type
3. Case B non-empty: new type's value is rationally related to old
4. Case B empty: Accuracy lemma pins down irrational value via Archimedean
5. Induction: extend from k types to k+1 types
6. Commutativity emerges from additivity + injectivity

**IMPORTANT**: This file does NOT import `Separation/Derivation`.
It provides the foundational grid/induction infrastructure used by the main proof chain under
`RepresentationTheorem/`.

The dependency structure is:
  Basic + Algebra  ─┬─ RepresentationTheorem/Core (this file and siblings)
                    ├─ RepresentationTheorem/Globalization + Main (public API)
                    └─ Separation/Derivation (experimental track; not used by the main chain)
-/

import Mettapedia.ProbabilityTheory.KnuthSkilling.Algebra
import Mettapedia.ProbabilityTheory.KnuthSkilling.Separation.SandwichSeparation
import Batteries.Data.Fin.Fold

set_option linter.unnecessarySimpa false
set_option linter.unusedSimpArgs false
set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace Mettapedia.ProbabilityTheory.KnuthSkilling.RepresentationTheorem

open Classical
open KnuthSkillingAlgebraBase
open KnuthSkillingAlgebra
open SandwichSeparation.SeparationToArchimedean

variable {α : Type*} [KnuthSkillingAlgebra α] [KSSeparation α]

/-! ## Main API: Representation Theorem and Commutativity

These are the two key results that the rest of the library depends on.
The proofs use the grid-based bootstrapping argument from K&S Appendix A.
-/

-- The associativity_representation theorem is defined later in this file
-- after all the necessary infrastructure (AtomFamily, MultiGridRep, etc.) is built.
-- See line ~7096 for the actual theorem statement and proof.

/-- Commutativity follows from the existence of an additive representation.

If Θ : α → ℝ is strictly monotone (or just injective) and additive, then:
  Θ(x ⊕ y) = Θ(x) + Θ(y) = Θ(y) + Θ(x) = Θ(y ⊕ x)
  ⟹ x ⊕ y = y ⊕ x (by injectivity)
-/
theorem commutativity_from_representation
    (Θ : α → ℝ)
    (hΘ_order : ∀ a b : α, a ≤ b ↔ Θ a ≤ Θ b)
    (hΘ_add : ∀ x y : α, Θ (op x y) = Θ x + Θ y) :
    ∀ x y : α, op x y = op y x := by
  intro x y
  -- Θ(x ⊕ y) = Θ(x) + Θ(y) = Θ(y) + Θ(x) = Θ(y ⊕ x)
  have h1 : Θ (op x y) = Θ x + Θ y := hΘ_add x y
  have h2 : Θ (op y x) = Θ y + Θ x := hΘ_add y x
  have h3 : Θ x + Θ y = Θ y + Θ x := add_comm (Θ x) (Θ y)
  have h4 : Θ (op x y) = Θ (op y x) := by rw [h1, h3, ← h2]
  -- From order preservation, Θ is injective
  have hΘ_inj : Function.Injective Θ := by
    intro a b hab
    have h_le : Θ a ≤ Θ b := le_of_eq hab
    have h_ge : Θ b ≤ Θ a := ge_of_eq hab
    have ha_le_b : a ≤ b := (hΘ_order a b).mpr h_le
    have hb_le_a : b ≤ a := (hΘ_order b a).mpr h_ge
    exact le_antisymm ha_le_b hb_le_a
  exact hΘ_inj h4

-- The op_comm_of_associativity theorem is defined later in this file
-- after associativity_representation. See end of file.

/-- Left cancellation from strict monotonicity: if x ⊕ z ≤ y ⊕ z then x ≤ y. -/
lemma cancellative_left {x y z : α} (h : op x z ≤ op y z) : x ≤ y := by
  rcases lt_trichotomy x y with hlt | heq | hgt
  · exact le_of_lt hlt
  · simpa [heq]
  · have h' : op y z < op x z := (op_strictMono_left z) hgt
    have : False := (not_lt_of_ge h) h'
    exact this.elim

/-- Right cancellation from strict monotonicity: if z ⊕ x ≤ z ⊕ y then x ≤ y. -/
lemma cancellative_right {x y z : α} (h : op z x ≤ op z y) : x ≤ y := by
  rcases lt_trichotomy x y with hlt | heq | hgt
  · exact le_of_lt hlt
  · simpa [heq]
  · have h' : op z y < op z x := (op_strictMono_right z) hgt
    have : False := (not_lt_of_ge h) h'
    exact this.elim

/-! ## Phase 1: One-Type Grid Representation (Foundation)

The first step in the Appendix A construction is to build Θ on the
grid generated by a single element a > ident.
-/

/-- The grid generated by element a: {a^n : n ∈ ℕ} -/
def grid (a : α) : Set α := {x | ∃ n : ℕ, x = iterate_op a n}

/-- Grid membership for iterates -/
lemma iterate_op_mem_grid (a : α) (n : ℕ) : iterate_op a n ∈ grid a :=
  ⟨n, rfl⟩

/-- The identity is in every grid (as a^0) -/
lemma ident_mem_grid (a : α) : ident ∈ grid a :=
  ⟨0, (iterate_op_zero a).symm⟩

/-- The map n ↦ a^n is strictly monotone for a > ident -/
lemma grid_strictMono (a : α) (ha : ident < a) : StrictMono (iterate_op a) :=
  iterate_op_strictMono a ha

/-- Grid elements are uniquely determined by their index -/
lemma grid_index_unique (a : α) (ha : ident < a) (m n : ℕ)
    (h : iterate_op a m = iterate_op a n) : m = n := by
  rcases lt_trichotomy m n with hlt | heq | hgt
  · exact absurd h (ne_of_lt (iterate_op_strictMono a ha hlt))
  · exact heq
  · exact absurd h.symm (ne_of_lt (iterate_op_strictMono a ha hgt))

/-- One-type representation on the grid -/
structure OneTypeGridRep (a : α) (ha : ident < a) where
  /-- The representation function on grid elements -/
  Θ_grid : {x // x ∈ grid a} → ℝ
  /-- Strict monotonicity -/
  strictMono : StrictMono Θ_grid
  /-- Additivity: Θ(a^m ⊕ a^n) = Θ(a^m) + Θ(a^n) -/
  add : ∀ m n : ℕ,
    Θ_grid ⟨iterate_op a (m + n), iterate_op_mem_grid a (m + n)⟩ =
    Θ_grid ⟨iterate_op a m, iterate_op_mem_grid a m⟩ +
    Θ_grid ⟨iterate_op a n, iterate_op_mem_grid a n⟩
  /-- Normalization: Θ(ident) = 0 -/
  ident_eq_zero : Θ_grid ⟨ident, ident_mem_grid a⟩ = 0
  /-- Normalization: Θ(a) = 1 -/
  ref_eq_one : Θ_grid ⟨a, ⟨1, (iterate_op_one a).symm⟩⟩ = 1

/-- Helper: extract the unique index for a grid element -/
noncomputable def gridIndex (a : α) (_ha : ident < a) (x : {x // x ∈ grid a}) : ℕ :=
  Classical.choose x.2

/-- The index is correct: x = a^(gridIndex x) -/
lemma gridIndex_spec (a : α) (ha : ident < a) (x : {x // x ∈ grid a}) :
    x.val = iterate_op a (gridIndex a ha x) :=
  Classical.choose_spec x.2

/-- The index for iterate_op a n is n -/
lemma gridIndex_iterate_op (a : α) (ha : ident < a) (n : ℕ) :
    gridIndex a ha ⟨iterate_op a n, iterate_op_mem_grid a n⟩ = n := by
  have h := gridIndex_spec a ha ⟨iterate_op a n, iterate_op_mem_grid a n⟩
  simp only at h
  exact grid_index_unique a ha _ n h.symm

/-- Canonical one-type representation Θ₁: send a^n to n. -/
noncomputable def Θ₁ (a : α) (ha : ident < a) : {x // x ∈ grid a} → ℝ :=
  fun x => (gridIndex a ha x : ℝ)

/-- Θ₁ evaluates to n on the nth iterate of a. -/
lemma Θ₁_on_power (a : α) (ha : ident < a) (n : ℕ) :
    Θ₁ a ha ⟨iterate_op a n, iterate_op_mem_grid a n⟩ = (n : ℝ) := by
  simp [Θ₁, gridIndex_iterate_op]

/-- The canonical OneTypeGridRep built from Θ₁. -/
noncomputable def oneTypeRep (a : α) (ha : ident < a) : OneTypeGridRep a ha := by
  classical
  refine
    { Θ_grid := Θ₁ a ha
      , strictMono := ?_
      , add := ?_
      , ident_eq_zero := ?_
      , ref_eq_one := ?_ }
  · intro x y hxy
    -- x < y in the grid implies gridIndex x < gridIndex y
    apply Nat.cast_lt.mpr
    have hx_eq := gridIndex_spec a ha x
    have hy_eq := gridIndex_spec a ha y
    have hmono := (grid_strictMono a ha).monotone
    by_contra hneg
    have hle : iterate_op a (gridIndex a ha y) ≤ iterate_op a (gridIndex a ha x) :=
      hmono (le_of_not_gt hneg)
    have hle' : y.val ≤ x.val := by simpa [hx_eq, hy_eq] using hle
    exact (not_le_of_gt hxy) hle'
  · intro m n
    -- Θ₁ is additive on the grid: Θ₁(a^{m+n}) = Θ₁(a^m) + Θ₁(a^n)
    simp [Θ₁, gridIndex_iterate_op, Nat.cast_add]
  · -- Θ₁(ident) = 0
    have h_spec := gridIndex_spec a ha ⟨ident, ident_mem_grid a⟩
    have h_eq : iterate_op a (gridIndex a ha ⟨ident, ident_mem_grid a⟩) = iterate_op a 0 := by
      simpa [iterate_op_zero] using h_spec.symm
    have hidx := grid_index_unique a ha _ 0 h_eq
    simp [Θ₁, hidx]
  · -- Θ₁(a) = 1
    have h_spec := gridIndex_spec a ha ⟨a, ⟨1, (iterate_op_one a).symm⟩⟩
    have h_eq :
        iterate_op a (gridIndex a ha ⟨a, ⟨1, (iterate_op_one a).symm⟩⟩) = iterate_op a 1 := by
      have h := h_spec.symm
      simpa [iterate_op_one] using h
    have hidx := grid_index_unique a ha _ 1 h_eq
    simp [Θ₁, hidx]

/-- Existence of one-type grid representation.

This is the base case of the Appendix A induction.
The representation is simply Θ(a^n) = n. -/
theorem one_type_grid_rep_exists (a : α) (ha : ident < a) : Nonempty (OneTypeGridRep a ha) := by
  exact ⟨oneTypeRep a ha⟩


end Mettapedia.ProbabilityTheory.KnuthSkilling.RepresentationTheorem
