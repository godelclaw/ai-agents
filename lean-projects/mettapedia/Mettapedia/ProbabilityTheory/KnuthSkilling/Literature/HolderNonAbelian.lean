import Mathlib.Algebra.Group.Basic
import Mathlib.Algebra.Group.Int.Defs
import Mathlib.Data.Int.Basic
import Mathlib.Data.Nat.Find
import Mathlib.Order.Basic
import Mathlib.Tactic.Abel

/-!
# Hölder / Clay–Rolfsen (non-abelian direction): Archimedean bi-ordered groups are abelian

This file formalizes the “non-abelian Hölder lemma” needed for Goertzel's proposed group-based
patch to K&S Appendix A:

> An Archimedean strictly ordered group is abelian.

More precisely, we work with an **additive** group `(G, +, 0, -)` equipped with a strict total
order `<` such that **both** left- and right-translation preserve `<` (bi-order), plus an
Archimedean condition stated without assuming commutativity.

The main proof follows Clay–Rolfsen, *Ordered Groups and Topology* (arXiv:1511.05088), Lemma 2.4,
with Lemma 2.5 providing the “square-root”/“halving” step in the no-minimal-positive case.

Local PDF:
- `literature/KS_codex/Clay_Mann_2015_Ordered_Groups_Topology.pdf` (Ch.2, Lemmas 2.4–2.5)
-/

namespace Mettapedia.ProbabilityTheory.KnuthSkilling.Literature

open Classical

/-!
## Order-compatibility axioms without commutativity

Mathlib’s `IsOrderedAddMonoid` requires commutativity (`AddCommMonoid`), so we record the strict
order-compatibility axioms directly for a potentially noncommutative `AddGroup`.
-/

/-- A *bi-ordered* additive group: strict order is preserved by left and right translation. -/
class IsBiOrderedAddGroup (G : Type*) [AddGroup G] [LinearOrder G] : Prop where
  add_lt_add_left : ∀ {a b : G}, a < b → ∀ c : G, c + a < c + b
  add_lt_add_right : ∀ {a b : G}, a < b → ∀ c : G, a + c < b + c

/-- An Archimedean axiom stated without commutativity: for any `x` and any `y > 0`,
there exists `n : ℕ` such that `x ≤ n • y`. This matches mathlib’s `Archimedean.arch` signature,
but works for `AddGroup` rather than `AddCommMonoid`. -/
class ArchimedeanNC (G : Type*) [AddGroup G] [PartialOrder G] : Prop where
  arch : ∀ (x : G) {y : G}, 0 < y → ∃ n : ℕ, x ≤ n • y

namespace HolderNonAbelian

section Ordered

variable {G : Type*} [AddGroup G] [LinearOrder G] [IsBiOrderedAddGroup G]

/-!
### Derived monotonicity lemmas for `≤` and basic order algebra
-/

theorem add_le_add_left {a b : G} (h : a ≤ b) (c : G) : c + a ≤ c + b := by
  rcases lt_or_eq_of_le h with hlt | rfl
  · exact (IsBiOrderedAddGroup.add_lt_add_left hlt c).le
  · rfl

theorem add_le_add_right {a b : G} (h : a ≤ b) (c : G) : a + c ≤ b + c := by
  rcases lt_or_eq_of_le h with hlt | rfl
  · exact (IsBiOrderedAddGroup.add_lt_add_right hlt c).le
  · rfl

theorem neg_le_neg_of_le {a b : G} (h : a ≤ b) : -b ≤ -a := by
  have h1 : (-b + a) ≤ (-b + b) := add_le_add_left h (-b)
  have h2 : (-b + a) + (-a) ≤ (-b + b) + (-a) := add_le_add_right h1 (-a)
  simpa [add_assoc] using h2

theorem neg_lt_neg_of_lt {a b : G} (h : a < b) : -b < -a := by
  have h1 : (-b + a) < (-b + b) := IsBiOrderedAddGroup.add_lt_add_left h (-b)
  have h2 : (-b + a) + (-a) < (-b + b) + (-a) := IsBiOrderedAddGroup.add_lt_add_right h1 (-a)
  simpa [add_assoc] using h2

theorem nsmul_lt_succ_nsmul {y : G} (hy : 0 < y) (n : ℕ) : n • y < (n + 1) • y := by
  have h := IsBiOrderedAddGroup.add_lt_add_left hy (n • y)
  -- `(n • y) + 0 < (n • y) + y`
  simpa [add_zero, Nat.succ_eq_add_one, succ_nsmul, add_assoc] using h

/-!
### A “floor” lemma along a positive step

This is the Clay–Rolfsen Problem 2.3-style fact specialized to natural multiples: for `x>0` and
`g>0`, we can trap `g` between two consecutive multiples of `x`.
-/

theorem exists_nsmul_le_lt_succ_nsmul [ArchimedeanNC G] {x g : G} (hx : 0 < x) (hg : 0 < g) :
    ∃ m : ℕ, m • x ≤ g ∧ g < (m + 1) • x := by
  have hExists : ∃ N : ℕ, g < N • x := by
    rcases ArchimedeanNC.arch (G := G) g hx with ⟨n, hn⟩
    refine ⟨n + 1, lt_of_le_of_lt hn ?_⟩
    exact nsmul_lt_succ_nsmul (G := G) hx n
  let N : ℕ := Nat.find hExists
  have hN : g < N • x := Nat.find_spec hExists
  have hNpos : 0 < N := by
    by_contra hN0
    have hNz : N = 0 := Nat.eq_zero_of_le_zero (Nat.le_of_not_gt hN0)
    have hg0 : g < 0 := by
      simpa [hNz] using hN
    exact (lt_asymm hg hg0)
  let m : ℕ := N - 1
  have hm1 : m + 1 = N := by
    have h1 : 1 ≤ N := Nat.succ_le_iff.2 hNpos
    simpa [m] using (Nat.sub_add_cancel h1)
  have hm_lt : m < N := by
    simpa [hm1] using (Nat.lt_succ_self m)
  have hm_not : ¬ g < m • x := Nat.find_min hExists hm_lt
  have hm_le : m • x ≤ g := le_of_not_gt hm_not
  have hm_succ : g < (m + 1) • x := by
    simpa [hm1] using hN
  exact ⟨m, hm_le, hm_succ⟩

/-!
## Clay–Rolfsen Lemmas 2.4–2.5 (additive translation)

We follow the two-case structure:
1. There is a least positive element `p`; then `G` is cyclic generated by `p`.
2. No least positive element; then noncommutativity contradicts Archimedeanness via the
   “halving” lemma.
-/

def HasLeastPos : Prop :=
  ∃ p : G, 0 < p ∧ ∀ g : G, 0 < g → p ≤ g

def NoLeastPos : Prop :=
  ∀ p : G, 0 < p → ∃ q : G, 0 < q ∧ q < p

theorem noLeastPos_of_not_hasLeastPos (h : ¬ HasLeastPos (G := G)) : NoLeastPos (G := G) := by
  intro p hp
  by_contra hcontra
  have hpLeast : ∀ g : G, 0 < g → p ≤ g := by
    intro g hg
    have : ¬ g < p := by
      intro hgp
      exact hcontra ⟨g, hg, hgp⟩
    exact le_of_not_gt this
  exact h ⟨p, hp, hpLeast⟩

/-- Clay–Rolfsen Lemma 2.5 (additive form): if there is no least positive element, then for any
`p>0` there is `q>0` with `q+q < p`. -/
theorem exists_pos_add_self_lt_of_noLeastPos (hNo : NoLeastPos (G := G)) {p : G} (hp : 0 < p) :
    ∃ q : G, 0 < q ∧ q + q < p := by
  rcases hNo p hp with ⟨r, hrPos, hrLt⟩
  rcases hNo r hrPos with ⟨s, hsPos, hsLt⟩
  let t : G := r - s
  have htPos : 0 < t := by
    have h := IsBiOrderedAddGroup.add_lt_add_right hsLt (-s)
    -- `s + (-s) < r + (-s)` i.e. `0 < r - s`
    simpa [t, sub_eq_add_neg, add_assoc] using h
  by_cases hSmall : t + t < r
  · refine ⟨t, htPos, lt_trans hSmall hrLt⟩
  · have hLarge : r ≤ t + t := le_of_not_gt hSmall
    have hrEq : r = t + s := by
      -- `t + s = (r - s) + s = r`
      simp [t, sub_eq_add_neg, add_assoc]
    have hts : t + s ≤ t + t := by simpa [hrEq, add_assoc] using hLarge
    have hs_le_t : s ≤ t := by
      have := add_le_add_left hts (-t)
      -- `(-t) + (t + s) ≤ (-t) + (t + t)` simplifies to `s ≤ t`
      simpa [add_assoc] using this
    have hs2_le_r : s + s ≤ r := by
      -- from `s ≤ t`, add `s` on the right and rewrite `t+s = r`
      have := add_le_add_right hs_le_t s
      simpa [hrEq, add_assoc] using this
    have hs2_lt_p : s + s < p := lt_of_le_of_lt hs2_le_r hrLt
    exact ⟨s, hsPos, hs2_lt_p⟩

/-- A noncommutativity witness, packaged as a commutator. -/
def commutator (g h : G) : G :=
  g + h + (-g) + (-h)

theorem commutator_eq_zero_iff (g h : G) : commutator (G := G) g h = 0 ↔ g + h = h + g := by
  constructor
  · intro hc
    -- add `h` on the right: `g + h + (-g) = h`
    have h1 : (g + h + (-g)) = h := by
      have := congrArg (fun t => t + h) hc
      -- simplify `(-h)+h` on the left
      simpa [commutator, add_assoc] using this
    -- add `g` on the right: `g + h = h + g`
    have := congrArg (fun t => t + g) h1
    simpa [add_assoc] using this
  · intro hgh
    -- `g+h = h+g` implies `g+h+(-g)+(-h)=0` by right-cancelling
    have := congrArg (fun t => t + (-g) + (-h)) hgh
    simpa [commutator, add_assoc] using this

theorem add_comm_iff_neg_left (g h : G) : g + h = h + g ↔ (-g) + h = h + (-g) := by
  constructor
  · intro hgh
    have := congrArg (fun t => (-g) + t) hgh
    -- `(-g)+(g+h) = (-g)+(h+g)` simplifies to `h = (-g)+h+g`
    have h1 : h = (-g) + h + g := by
      simpa [add_assoc] using this
    have := congrArg (fun t => t + (-g)) h1
    simpa [add_assoc] using this.symm
  · intro hneg
    have := congrArg (fun t => g + t) hneg
    have h1 : g + (-g) + h = g + h + (-g) := by
      simpa [add_assoc] using this
    have := congrArg (fun t => t + g) h1
    simpa [add_assoc] using this.symm

theorem commutator_swap (g h : G) :
    commutator (G := G) h g = - commutator (G := G) g h := by
  -- `-(a+b) = -b + -a` (reverse order) is `neg_add_rev`.
  simp [commutator, add_assoc, neg_add_rev]

/-!
### Main theorem: Archimedean bi-ordered additive groups are abelian

This is the Lean statement we need for the “group vertex” variant of the K&S Appendix A story.
-/

theorem add_comm_of_biOrdered_archimedean [ArchimedeanNC G] :
    ∀ a b : G, a + b = b + a := by
  classical
  by_cases hLeast : HasLeastPos (G := G)
  · rcases hLeast with ⟨p, hpPos, hpLeast⟩
    intro a b
    -- Show every element is an integer multiple of `p`.
    have hMul : ∀ g : G, ∃ z : ℤ, g = z • p := by
      intro g
      rcases lt_trichotomy g 0 with hgNeg | rfl | hgPos
      · -- negative: apply the positive case to `-g`
        have hgPos' : 0 < -g := by
          simpa using (neg_lt_neg_of_lt (G := G) hgNeg)
        rcases exists_nsmul_le_lt_succ_nsmul (G := G) (x := p) (g := -g) hpPos hgPos' with
          ⟨m, hmLe, hmLt⟩
        have hmEq : -g = m • p := by
          by_contra hne
          have hmStrict : m • p < -g := lt_of_le_of_ne hmLe (Ne.symm hne)
          let d : G := -(m • p) + (-g)
          have hdPos : 0 < d := by
            have := IsBiOrderedAddGroup.add_lt_add_left hmStrict (-(m • p))
            simpa [d, add_assoc] using this
          have hdLt : d < p := by
            have := IsBiOrderedAddGroup.add_lt_add_left hmLt (-(m • p))
            -- `-(m•p) + ((m+1)•p) = p`
            simpa [d, succ_nsmul, add_assoc] using this
          have : p ≤ d := hpLeast d hdPos
          exact (not_lt_of_ge this) hdLt
        refine ⟨-(m : ℤ), ?_⟩
        have hg : g = -(m • p) := by
          simpa using congrArg Neg.neg hmEq
        have hm : (-(m : ℤ)) • p = -(m • p) := by
          calc
            (-(m : ℤ)) • p = -((m : ℤ) • p) := by simpa [neg_zsmul]
            _ = -(m • p) := by simp [natCast_zsmul]
        simpa [hm] using hg
      · exact ⟨0, by simp⟩
      · -- positive case
        rcases exists_nsmul_le_lt_succ_nsmul (G := G) (x := p) (g := g) hpPos hgPos with ⟨m, hmLe, hmLt⟩
        have hmEq : g = m • p := by
          by_contra hne
          have hmStrict : m • p < g := lt_of_le_of_ne hmLe (Ne.symm hne)
          let d : G := -(m • p) + g
          have hdPos : 0 < d := by
            have := IsBiOrderedAddGroup.add_lt_add_left hmStrict (-(m • p))
            simpa [d, add_assoc] using this
          have hdLt : d < p := by
            have := IsBiOrderedAddGroup.add_lt_add_left hmLt (-(m • p))
            simpa [d, succ_nsmul, add_assoc] using this
          have : p ≤ d := hpLeast d hdPos
          exact (not_lt_of_ge this) hdLt
        refine ⟨(m : ℤ), ?_⟩
        have hm : (m : ℤ) • p = m • p := by
          simpa using (natCast_zsmul p m)
        simpa [hm] using hmEq
    rcases hMul a with ⟨za, rfl⟩
    rcases hMul b with ⟨zb, rfl⟩
    -- Now commutativity reduces to commutativity of integer addition.
    calc
      za • p + zb • p = (za + zb) • p := by
        simpa using (add_zsmul p za zb).symm
      _ = (zb + za) • p := by simpa [Int.add_comm]
      _ = zb • p + za • p := by
        simpa using (add_zsmul p zb za)
  · -- no least positive element: Clay–Rolfsen Lemma 2.4, Case 2
    have hNo : NoLeastPos (G := G) := noLeastPos_of_not_hasLeastPos (G := G) hLeast
    intro a b
    -- Suppose `a+b ≠ b+a`; derive a contradiction.
    by_contra hab
    have hab' : a + b ≠ b + a := by simpa using hab
    have ha0 : a ≠ 0 := by
      intro ha0
      apply hab'
      simpa [ha0]
    have hb0 : b ≠ 0 := by
      intro hb0
      apply hab'
      simpa [hb0]
    -- Make both elements positive by possibly negating.
    let g : G := if 0 < a then a else -a
    let h : G := if 0 < b then b else -b
    have hgPos : 0 < g := by
      by_cases ha : 0 < a
      · simp [g, ha]
      · have haLe : a ≤ 0 := le_of_not_gt ha
        have haLt : a < 0 := lt_of_le_of_ne haLe ha0
        have : 0 < -a := by simpa using (neg_lt_neg_of_lt (G := G) haLt)
        simp [g, ha, this]
    have hhPos : 0 < h := by
      by_cases hb : 0 < b
      · simp [h, hb]
      · have hbLe : b ≤ 0 := le_of_not_gt hb
        have hbLt : b < 0 := lt_of_le_of_ne hbLe hb0
        have : 0 < -b := by simpa using (neg_lt_neg_of_lt (G := G) hbLt)
        simp [h, hb, this]
    have add_comm_of_add_comm_neg_right {a b : G} (h : a + (-b) = (-b) + a) :
        a + b = b + a := by
      have h1 : a = (-b) + (a + b) := by
        have := congrArg (fun t => t + b) h
        simpa [add_assoc] using this
      have := congrArg (fun t => b + t) h1
      simpa [add_assoc] using this.symm
    have add_comm_of_add_comm_neg_left {a b : G} (h : (-a) + b = b + (-a)) :
        a + b = b + a := by
      have h1 : b = a + b + (-a) := by
        have := congrArg (fun t => a + t) h
        simpa [add_assoc] using this
      have := congrArg (fun t => t + a) h1
      simpa [add_assoc] using this.symm
    have hNonComm : g + h ≠ h + g := by
      intro hgh
      have habEq : a + b = b + a := by
        by_cases ha : 0 < a
        · by_cases hb : 0 < b
          · simpa [g, h, ha, hb] using hgh
          · have h1 : a + (-b) = (-b) + a := by
              simpa [g, h, ha, hb] using hgh
            exact add_comm_of_add_comm_neg_right (a := a) (b := b) h1
        · by_cases hb : 0 < b
          · have h1 : (-a) + b = b + (-a) := by
              simpa [g, h, ha, hb] using hgh
            exact add_comm_of_add_comm_neg_left (a := a) (b := b) h1
          · have h1 : (-a) + (-b) = (-b) + (-a) := by
              simpa [g, h, ha, hb] using hgh
            have h2 : a + (-b) = (-b) + a :=
              add_comm_of_add_comm_neg_left (a := a) (b := -b) h1
            exact add_comm_of_add_comm_neg_right (a := a) (b := b) h2
      exact hab' habEq
    have hCne : commutator (G := G) g h ≠ 0 := by
      intro h0
      exact hNonComm (commutator_eq_zero_iff (G := G) g h |>.1 h0)
    -- Ensure the commutator is positive by swapping if needed.
    have hCpos : 0 < commutator (G := G) g h ∨ 0 < commutator (G := G) h g := by
      rcases lt_trichotomy (commutator (G := G) g h) 0 with hcNeg | hcZero | hcPos
      · -- then `comm h g = - comm g h` is positive
        right
        have : commutator (G := G) h g = - commutator (G := G) g h := commutator_swap (G := G) g h
        have : 0 < commutator (G := G) h g := by
          -- `0 < -c` since `c < 0`
          simpa [this] using (neg_lt_neg_of_lt (G := G) hcNeg)
        exact this
      · exfalso
        exact hCne hcZero
      · left; exact hcPos
    -- Choose a positive commutator `c` and a positive pair `(g', h')`.
    let g' : G := if 0 < commutator (G := G) g h then g else h
    let h' : G := if 0 < commutator (G := G) g h then h else g
    have hg'Pos : 0 < g' := by
      by_cases hc : 0 < commutator (G := G) g h
      · simpa [g', hc] using hgPos
      · simpa [g', hc] using hhPos
    have hh'Pos : 0 < h' := by
      by_cases hc : 0 < commutator (G := G) g h
      · simpa [h', hc] using hhPos
      · simpa [h', hc] using hgPos
    have hCommPos : 0 < commutator (G := G) g' h' := by
      by_cases hc : 0 < commutator (G := G) g h
      · simpa [g', h', hc] using hc
      · have : 0 < commutator (G := G) h g := hCpos.resolve_left hc
        simpa [g', h', hc] using this
    -- Halving lemma: pick `x>0` with `x+x < commutator`.
    rcases exists_pos_add_self_lt_of_noLeastPos (G := G) hNo hCommPos with ⟨x, hxPos, hx2Lt⟩
    -- Trap `g'` and `h'` between consecutive multiples of `x`.
    rcases exists_nsmul_le_lt_succ_nsmul (G := G) (x := x) (g := g') hxPos hg'Pos with
      ⟨m, hmLe, hmLt⟩
    rcases exists_nsmul_le_lt_succ_nsmul (G := G) (x := x) (g := h') hxPos hh'Pos with
      ⟨n, hnLe, hnLt⟩
    have hmLeZ : (m : ℤ) • x ≤ g' := by
      simpa [natCast_zsmul] using hmLe
    have hnLeZ : (n : ℤ) • x ≤ h' := by
      simpa [natCast_zsmul] using hnLe
    have hmLtZ : g' < (↑m + 1 : ℤ) • x := by
      have hEq : (↑(m + 1) : ℤ) • x = (m + 1) • x := natCast_zsmul x (m + 1)
      have hmLt' : g' < (↑(m + 1) : ℤ) • x := lt_of_lt_of_eq hmLt hEq.symm
      have hCoef : (↑(m + 1) : ℤ) = (↑m + 1 : ℤ) := by
        simpa [Nat.succ_eq_add_one] using (Int.ofNat_succ m)
      have hCoef' : (↑(m + 1) : ℤ) • x = (↑m + 1 : ℤ) • x :=
        congrArg (fun t : ℤ => t • x) hCoef
      exact lt_of_lt_of_eq hmLt' hCoef'
    have hnLtZ : h' < (↑n + 1 : ℤ) • x := by
      have hEq : (↑(n + 1) : ℤ) • x = (n + 1) • x := natCast_zsmul x (n + 1)
      have hnLt' : h' < (↑(n + 1) : ℤ) • x := lt_of_lt_of_eq hnLt hEq.symm
      have hCoef : (↑(n + 1) : ℤ) = (↑n + 1 : ℤ) := by
        simpa [Nat.succ_eq_add_one] using (Int.ofNat_succ n)
      have hCoef' : (↑(n + 1) : ℤ) • x = (↑n + 1 : ℤ) • x :=
        congrArg (fun t : ℤ => t • x) hCoef
      exact lt_of_lt_of_eq hnLt' hCoef'
    have hnegG : -g' ≤ (-(m : ℤ)) • x := by
      -- `m•x ≤ g'` implies `-g' ≤ -(m•x)`; rewrite `-(m•x)` as `(-m)•x`.
      have : -g' ≤ -((m : ℤ) • x) := neg_le_neg_of_le (G := G) hmLeZ
      simpa [neg_zsmul] using this
    have hnegH : -h' ≤ (-(n : ℤ)) • x := by
      have : -h' ≤ -((n : ℤ) • x) := neg_le_neg_of_le (G := G) hnLeZ
      simpa [neg_zsmul] using this
    -- Now bound the commutator above by `x+x`, contradicting `x+x < commutator`.
    have hUpper : commutator (G := G) g' h' < x + x := by
      -- Step 1: `g'+h' < (m+1)•x + (n+1)•x`
      have h1 : g' + h' < (↑m + 1 : ℤ) • x + h' := IsBiOrderedAddGroup.add_lt_add_right hmLtZ h'
      have h2 : (↑m + 1 : ℤ) • x + h' < (↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x :=
        IsBiOrderedAddGroup.add_lt_add_left hnLtZ ((↑m + 1 : ℤ) • x)
      have hgh : g' + h' < (↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x := lt_trans h1 h2
      -- Step 2: add `-g'` on the right, then replace by `(-m)•x` via `≤`
      have h3 :
          g' + h' + (-g') < ((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-g') :=
        IsBiOrderedAddGroup.add_lt_add_right hgh (-g')
      have h4 :
          ((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-g') ≤
            ((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x :=
        add_le_add_left (G := G) hnegG ((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x)
      have h3' :
          g' + h' + (-g') < ((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x :=
        lt_of_lt_of_le h3 h4
      -- Step 3: add `-h'` on the right, then replace by `(-n)•x`
      have h5 : g' + h' + (-g') + (-h') <
          (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x) + (-h') :=
        IsBiOrderedAddGroup.add_lt_add_right h3' (-h')
      have h6 :
          (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x) + (-h') ≤
            (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x) + (-(n : ℤ)) • x :=
        add_le_add_left (G := G) hnegH
          (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x)
      have h5' : g' + h' + (-g') + (-h') <
          (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x) + (-(n : ℤ)) • x :=
        lt_of_lt_of_le h5 h6
      -- Step 4: compute the RHS as `x+x` by combining adjacent `zsmul`s (as in Clay–Rolfsen).
      have hRhs :
          (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x) + (-(n : ℤ)) • x = x + x := by
        -- Reassociate into two adjacent sums, convert each via `add_zsmul`, then compute the scalar.
        calc
          (((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + (-(m : ℤ)) • x) + (-(n : ℤ)) • x
              = ((↑m + 1 : ℤ) • x + (↑n + 1 : ℤ) • x) + ((-(m : ℤ)) • x + (-(n : ℤ)) • x) := by
                  simp [add_assoc]
          _ = ((↑m + 1 + (↑n + 1) : ℤ) • x) + ((-(m : ℤ) + (-(n : ℤ)) : ℤ) • x) := by
                  simp [add_zsmul]
          _ = ((↑m + 1 + (↑n + 1) + (-(m : ℤ) + (-(n : ℤ))) : ℤ) • x) := by
                  simpa using (add_zsmul x (↑m + 1 + (↑n + 1) : ℤ) (-(m : ℤ) + (-(n : ℤ)) : ℤ)).symm
          _ = (2 : ℤ) • x := by
                  -- scalar arithmetic in `ℤ`
                  have h0 : (↑m + 1 + (↑n + 1) + (-(m : ℤ) + (-(n : ℤ))) : ℤ) = 2 := by
                    abel
                  simpa [h0]
          _ = x + x := by simpa using (two_zsmul x)
      have h5'' : g' + h' + (-g') + (-h') < x + x := lt_of_lt_of_eq h5' hRhs
      have : commutator (G := G) g' h' < x + x := by
        simpa [commutator, add_assoc] using h5''
      exact this
    exact (not_lt_of_ge (le_of_lt hx2Lt)) hUpper

end Ordered

end HolderNonAbelian

end Mettapedia.ProbabilityTheory.KnuthSkilling.Literature
