import Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA.Core.MultiGrid

set_option linter.unnecessarySimpa false
set_option linter.unusedSimpArgs false
set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA

open Classical KnuthSkillingAlgebra

variable {α : Type*} [KnuthSkillingAlgebra α]

/-! ## Phase 3: Inductive Construction (Summary)

The full K&S argument proceeds by induction on the number of atom types:

**Base case (k=1)**: Phase 1 above shows Θ(a^n) = n is well-defined on the
grid generated by a single positive element.

**Inductive step (k → k+1)**: Given representation on k types, extend to new type d:
1. Use A/B/C partition to classify where d^u lands relative to existing grid
2. If B non-empty: d has rational relation to existing values
3. If B empty: use Archimedean property to pin down d as limit
4. Both cases give d a unique position on the linear scale

**Result**: Θ : α → ℝ with additivity Θ(x⊕y) = Θ(x) + Θ(y).

**Commutativity**: From additivity + injectivity:
  Θ(x⊕y) = Θ(x) + Θ(y) = Θ(y) + Θ(x) = Θ(y⊕x)
  ⟹ x⊕y = y⊕x by injectivity of Θ
-/

/-! ### Layer A: Structural Extension (K&S Appendix A, equation after line 1456)

**Inductive step**: Extend a k-type grid representation by a new atom.

This captures the two major cases from Appendix A:
* Case B non-empty: the new atom is rationally related to the existing grid.
* Case B empty: the new atom is pinned as a limit via the accuracy lemma.

Following the paper, when we extend from k atom types {a, b, c, ...} to k+1 types
by adding new atom d, the extended evaluation satisfies:

    μ(F', r₁,...,rₖ; t) = μ(F, r₁,...,rₖ) ⊕ d^t

This is the key structural property (K&S line 1456 in paper).
-/

/-- Extend an atom family F of k types to k+1 types by appending new atom d.
The new atom becomes the last index (position k). -/
def extendAtomFamily {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d) :
    AtomFamily α (k + 1) where
  atoms := fun i =>
    if h : i.val < k then
      -- Old atoms: use castSucc embedding
      F.atoms ⟨i.val, h⟩
    else
      -- New atom at position k
      d
  pos := fun i => by
    by_cases h : i.val < k
    · simp only [h, ↓reduceIte]
      exact F.pos ⟨i.val, h⟩
    · simp only [h, ↓reduceIte]
      exact hd

/-- The extended family preserves old atoms at positions < k -/
lemma extendAtomFamily_old {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d)
    (i : Fin k) :
    (extendAtomFamily F d hd).atoms ⟨i.val, Nat.lt_succ_of_lt i.isLt⟩ = F.atoms i := by
  simp only [extendAtomFamily]
  have h : i.val < k := i.isLt
  simp only [h, ↓reduceIte]
  congr

/-- The extended family has the new atom at position k -/
lemma extendAtomFamily_new {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d) :
    (extendAtomFamily F d hd).atoms ⟨k, Nat.lt_succ_self k⟩ = d := by
  simp only [extendAtomFamily]
  have h : ¬ k < k := Nat.lt_irrefl k
  exact dif_neg h

/-- Any `AtomFamily` on `k+1` types which agrees with `extendAtomFamily` on all indices
is equal to it. This is the key helper for rewriting `mu F'` in extension proofs. -/
lemma AtomFamily.eq_extendAtomFamily_of_old_new {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d)
    (F' : AtomFamily α (k + 1))
    (hF'_old : ∀ i : Fin k,
      F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.isLt⟩ = F.atoms i)
    (hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = d) :
    F' = extendAtomFamily F d hd := by
  cases F' with
  | mk atoms' pos' =>
    have hatoms : atoms' = (extendAtomFamily F d hd).atoms := by
      funext i
      by_cases hi : i.val < k
      · -- old index
        let i' : Fin k := ⟨i.val, hi⟩
        have hi_eq : i = ⟨i'.val, Nat.lt_succ_of_lt i'.isLt⟩ := by
          ext; rfl
        -- use the provided old-atom agreement, then the known behavior of `extendAtomFamily`
        calc
          atoms' i = atoms' ⟨i'.val, Nat.lt_succ_of_lt i'.isLt⟩ := by
            simpa [hi_eq]
          _ = F.atoms i' := by
            simpa using (hF'_old i')
          _ = (extendAtomFamily F d hd).atoms ⟨i'.val, Nat.lt_succ_of_lt i'.isLt⟩ := by
            symm
            simpa using (extendAtomFamily_old F d hd i')
          _ = (extendAtomFamily F d hd).atoms i := by
            simpa [hi_eq]
      · -- new index: must be the last one
        have hik : i.val = k := by omega
        have hi_eq : i = ⟨k, Nat.lt_succ_self k⟩ := by
          ext; exact hik
        subst hi_eq
        -- at the last index, `extendAtomFamily` selects the new atom `d`
        simpa [extendAtomFamily, Nat.lt_irrefl] using hF'_new
    cases hatoms
    have hpos : pos' = (extendAtomFamily F d hd).pos := by
      apply Subsingleton.elim
    cases hpos
    rfl

/-- Split a multiplicity vector for k+1 types into old part (first k coords) and new part (last coord).
This represents the split: (r₁,...,rₖ; t) where t is the last coordinate. -/
def splitMulti {k : ℕ} (r : Multi (k + 1)) : Multi k × ℕ :=
  (fun i => r ⟨i.val, Nat.lt_succ_of_lt i.isLt⟩, r ⟨k, Nat.lt_succ_self k⟩)

/-- Reconstruct a (k+1)-multiplicity from old part and new last coordinate -/
def joinMulti {k : ℕ} (r_old : Multi k) (t : ℕ) : Multi (k + 1) :=
  fun i => if h : i.val < k then r_old ⟨i.val, h⟩ else t

/-- Splitting and joining are inverses -/
lemma splitMulti_joinMulti {k : ℕ} (r_old : Multi k) (t : ℕ) :
    splitMulti (joinMulti r_old t) = (r_old, t) := by
  unfold splitMulti joinMulti
  -- After unfolding, goal is a pair equality
  apply Prod.ext
  · -- First component: show the functions are equal
    funext i
    have hi : i.val < k := i.isLt
    exact dif_pos hi
  · -- Second component: show (joinMulti r_old t) ⟨k, ...⟩ = t
    have h : ¬ k < k := Nat.lt_irrefl k
    simp only []
    exact dif_neg h

/-- Joining and splitting are inverses (reverse direction) -/
lemma joinMulti_splitMulti {k : ℕ} (r : Multi (k + 1)) :
    let (r_old, t) := splitMulti r
    joinMulti r_old t = r := by
  unfold splitMulti joinMulti
  ext i
  by_cases hi : i.val < k
  · simp [hi]
  · simp [hi]
    have hiv : i.val = k := by omega
    have h_i_eq : i = ⟨k, Nat.lt_succ_self k⟩ := by ext; exact hiv
    rw [h_i_eq]

/-- splitMulti distributes over pointwise addition of multiplicities. -/
lemma splitMulti_add {k : ℕ} (r s : Multi (k + 1)) :
    splitMulti (fun i => r i + s i) = ((fun i => (splitMulti r).1 i + (splitMulti s).1 i),
                                        (splitMulti r).2 + (splitMulti s).2) := by
  unfold splitMulti; rfl

/-- joinMulti distributes over pointwise addition of multiplicities. -/
lemma joinMulti_add {k : ℕ} (r_old s_old : Multi k) (t_r t_s : ℕ) :
    (fun i => joinMulti r_old t_r i + joinMulti s_old t_s i) =
    joinMulti (fun i => r_old i + s_old i) (t_r + t_s) := by
  unfold joinMulti
  ext i
  by_cases hi : i.val < k
  · simp [hi]
  · simp [hi]

/-- Helper: folding over `Fin (k+1)` splits into the first `k` indices and the final `last`. -/
private lemma foldl_fin_succ_split {k : ℕ} (f : α → Fin (k + 1) → α) (acc : α) :
    List.foldl f acc (List.finRange (k + 1)) =
    f
      (List.foldl f acc ((List.finRange k).map (Fin.castAdd 1)))
      (Fin.last k) := by
  classical
  -- Use the canonical ordered enumeration of `Fin (k+1)`
  have hmapFun : (Fin.castSucc : Fin k → Fin (k + 1)) = Fin.castAdd 1 := by
    funext i; ext; rfl
  have hbase :
      List.foldl f acc (List.finRange (k + 1)) =
        f (List.foldl f acc ((List.finRange k).map Fin.castSucc)) (Fin.last k) := by
    simp [List.finRange_succ_last, List.foldl_append]
  simpa [hmapFun] using hbase

/-- **Key Structural Lemma** (K&S paper, line 1456):

When extending from k types to k+1 types, the evaluation of μ on the extended family
splits into old part ⊕ new part:

    μ(F', r₁,...,rₖ; t) = μ(F, r₁,...,rₖ) ⊕ d^t

This is the foundation for the inductive construction. The proof follows from the
definition of μ as a fold and the split of indices.
-/
lemma mu_extend_last {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d)
    (r_old : Multi k) (t : ℕ) :
    mu (extendAtomFamily F d hd) (joinMulti r_old t) =
    op (mu F r_old) (iterate_op d t) := by
  let F' := extendAtomFamily F d hd
  let r' := joinMulti r_old t
  unfold mu

  -- Strategy: Show that processing each index in Fin (k+1) gives the right contribution
  -- We'll use induction on the list structure or reason about the fold directly

  -- Key observations:
  have hF'_old : ∀ i : Fin k, F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.isLt⟩ = F.atoms i :=
    extendAtomFamily_old F d hd
  have hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = d :=
    extendAtomFamily_new F d hd
  have hr'_old : ∀ i : Fin k, r' ⟨i.val, Nat.lt_succ_of_lt i.isLt⟩ = r_old i := by
    intro i
    show (joinMulti r_old t) ⟨i.val, Nat.lt_succ_of_lt i.isLt⟩ = r_old i
    unfold joinMulti
    exact dif_pos i.isLt
  have hr'_new : r' ⟨k, Nat.lt_succ_self k⟩ = t := by
    show (joinMulti r_old t) ⟨k, Nat.lt_succ_self k⟩ = t
    unfold joinMulti
    have : ¬ k < k := Nat.lt_irrefl k
    exact dif_neg this

  -- Use the fold splitting lemma
  let f : α → Fin (k + 1) → α := fun acc i => op acc (iterate_op (F'.atoms i) (r' i))

  -- Apply foldl_fin_succ_split
  have hsplit := foldl_fin_succ_split f ident

  -- Simplify the LHS using hsplit
  conv_lhs => rw [hsplit]

  -- Now we need to show that the mapped fold equals mu F r_old
  have hmap_fold :
      List.foldl f ident
        (List.map (Fin.castAdd 1) (List.finRange k)) =
      mu F r_old := by
    -- Key: for each i : Fin k, F'.atoms (lift i) = F.atoms i and r' (lift i) = r_old i
    -- So folding over the mapped list with f is the same as folding over the original list

    -- Define the original function for mu F r_old
    let g : α → Fin k → α := fun acc i => op acc (iterate_op (F.atoms i) (r_old i))

    -- Show that f on lifted indices equals g on original indices
    have hfg : ∀ (acc : α) (i : Fin k),
        f acc (Fin.castAdd 1 i) = g acc i := by
      intro acc i
      -- Work with an explicit constructor form for `i`
      cases i with
      | mk i_val i_lt =>
        have h_atom' :
            F'.atoms ⟨i_val, Nat.lt_trans i_lt (Nat.lt_succ_self k)⟩ =
              F.atoms ⟨i_val, i_lt⟩ := by
          simpa using hF'_old ⟨i_val, i_lt⟩
        have h_r' :
            r' ⟨i_val, Nat.lt_trans i_lt (Nat.lt_succ_self k)⟩ =
              r_old ⟨i_val, i_lt⟩ := by
          simpa using hr'_old ⟨i_val, i_lt⟩
        simp [f, g, h_atom', h_r']

    -- Use List.foldl_map and the equivalence
    unfold mu
    -- The goal is to show the folds are equal
    -- We'll use induction on the list

    -- Generalized helper: for any accumulator
    have h_gen : ∀ (acc : α) (l : List (Fin k)),
        List.foldl f acc (List.map (Fin.castAdd 1) l) =
        List.foldl g acc l := by
      intro acc l
      induction l generalizing acc with
      | nil => rfl
      | cons hd tl ih =>
        simp only [List.map_cons, List.foldl_cons]
        rw [hfg]
        exact ih _

    exact h_gen ident (List.finRange k)

  rw [hmap_fold]

  -- Simplify the last step application
  -- After the fold, we apply f to the index ⟨k, ...⟩
  suffices f (mu F r_old) ⟨k, Nat.lt_succ_self k⟩ = op (mu F r_old) (iterate_op d t) by
    exact this

  unfold f
  -- After unfolding: op (mu F r_old) (iterate_op (F'.atoms ⟨k, ...⟩) (r' ⟨k, ...⟩))
  -- Use hF'_new: F'.atoms ⟨k, ...⟩ = d
  -- Use hr'_new: r' ⟨k, ...⟩ = t
  rw [hF'_new, hr'_new]
  -- Goal is now: op (mu F r_old) (iterate_op d t) = op (mu F r_old) (iterate_op d t)
  -- which is definitionally equal

/-- `mu_extend_last` for an *arbitrary* extension family `F'` that agrees with `F` on the
first `k` atoms and has new atom `d` at index `k`. -/
lemma mu_extend_last_of_old_new {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d)
    (F' : AtomFamily α (k + 1))
    (hF'_old : ∀ i : Fin k,
      F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.is_lt⟩ = F.atoms i)
    (hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = d)
    (r_old : Multi k) (t : ℕ) :
    mu F' (joinMulti r_old t) = op (mu F r_old) (iterate_op d t) := by
  have hF_eq := AtomFamily.eq_extendAtomFamily_of_old_new F d hd F' hF'_old hF'_new
  -- Reduce to the definitional extension family so `mu_extend_last` applies.
  simpa [hF_eq] using (mu_extend_last F d hd r_old t)

/-! ### Layer B: Value Assignment and Θ' Construction

Following K&S Appendix A, once we have the extended family F', we need to:
1. Choose δ (the representation value for the new atom d):
   - Case B non-empty: δ = common statistic from B witnesses
   - Case B empty: δ = limit value from accuracy lemma
2. Define Θ' on kGrid F' via: Θ'(μ(F', r_old, t)) := Θ(μ(F, r_old)) + t * δ
3. Prove Θ' satisfies MultiGridRep requirements (strict mono, additive, normalized)
-/

/-- When B is empty, A is non-empty (zero multiplicity is always in A). -/
lemma extensionSetA_nonempty_of_B_empty {k : ℕ} (F : AtomFamily α k) (d : α) (hd : ident < d)
    (hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u) :
    ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u := by
  -- Take zero multiplicity and u = 1
  refine ⟨fun _ => 0, 1, Nat.one_pos, ?_⟩
  simp only [extensionSetA, Set.mem_setOf_eq]
  -- μ(F, 0) = ident < d = d^1
  have : mu F (fun _ => 0) = ident := mu_zero (F := F)
  rw [this, iterate_op_one]
  exact hd

/-- When B is empty and k ≥ 1, C is non-empty (by Archimedean property). -/
lemma extensionSetC_nonempty_of_B_empty {k : ℕ} (F : AtomFamily α k) (hk : k ≥ 1) (d : α) (hd : ident < d)
    (hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u) :
    ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u := by
  -- Pick any atom from F (exists since k ≥ 1)
  have : 0 < k := hk
  let i₀ : Fin k := ⟨0, this⟩
  let a := F.atoms i₀
  have ha : ident < a := F.pos i₀
  -- By Archimedean property, ∃ N such that d < a^N
  obtain ⟨N, hN⟩ := bounded_by_iterate a ha d
  -- Take r = unitMulti i₀ N and u = 1
  refine ⟨unitMulti i₀ N, 1, Nat.one_pos, ?_⟩
  simp only [extensionSetC, Set.mem_setOf_eq]
  -- d^1 = d < a^N = μ(F, unitMulti i₀ N)
  rw [iterate_op_one]
  have : mu F (unitMulti i₀ N) = iterate_op a N := mu_unitMulti F i₀ N
  rw [this]
  exact hN

/-- Choose the representation value δ for the new atom d.
This is the Θ-value we assign to d in the extended representation. -/
noncomputable def chooseδ {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1) (R : MultiGridRep F)
    (d : α) (hd : ident < d) : ℝ :=
  if hB : ∃ r u, 0 < u ∧ r ∈ extensionSetB F d u then
    -- Case B non-empty: use common statistic
    B_common_statistic R d hd hB
  else
    -- Case B empty: use B_empty_delta
    have hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u := fun r u hu hr => hB ⟨r, u, hu, hr⟩
    have hA : ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u :=
      extensionSetA_nonempty_of_B_empty F d hd hB_empty
    have hC : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u :=
      extensionSetC_nonempty_of_B_empty F hk d hd hB_empty
    B_empty_delta R d hd hB_empty hA hC

/-! ### ZQuantized: A (Strong) Quantization Hypothesis

`ZQuantized F R δ` says every k-grid value of `R.Θ_grid` is an integer multiple of a *fixed*
step `δ`. This property is useful for “mesh collapse” lemmas (closing a width-`2δ` window to an
exact integer).

Important: in the B-empty branch, `chooseδ` is defined as a `sSup` of A-statistics. In general,
there is no reason for this newly chosen `δ := chooseδ hk R d hd` to be commensurate with the
existing k-grid values, so `ZQuantized F R (chooseδ hk R d hd)` should not be treated as an
automatic inductive invariant of the extension step.

See `Mettapedia/ProbabilityTheory/KnuthSkilling/AppendixA/Counterexamples/ZQuantizedBEmpty.lean`
for a concrete additive model where `B` is empty and `ZQuantized F R (chooseδ …)` fails.

See `Mettapedia/ProbabilityTheory/KnuthSkilling/AppendixA/Counterexamples/ZQuantizedBNonempty.lean`
for a concrete additive model where `B` is **nonempty** but `ZQuantized_chooseδ_if_B_nonempty` still fails (so
the “rational δ” branch needs something weaker than full `ZQuantized`).
-/

/-- ZQuantized: Every Θ-value on the k-grid is an integer multiple of δ.
This is the key inductive invariant that closes the floor-bracket. -/
def ZQuantized {k : ℕ} (F : AtomFamily α k) (R : MultiGridRep F) (δ : ℝ) : Prop :=
  ∀ r : Multi k, ∃ m : ℤ, R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ = (m : ℝ) * δ

/-- Cast bookkeeping for the ZQuantized induction step:
turn `m*δ + t*δ` into `(m+t)*δ` where `m : ℤ` and `t : ℕ`. -/
lemma zquantized_cast_add (m : ℤ) (t : ℕ) (δ : ℝ) :
    (m : ℝ) * δ + (t : ℝ) * δ = ((m + (t : ℤ)) : ℝ) * δ := by
  have ht' : (t : ℝ) = ((t : ℤ) : ℝ) := by
    simpa using (Int.cast_ofNat t : ((t : ℤ) : ℝ) = (t : ℝ)).symm
  calc
    (m : ℝ) * δ + (t : ℝ) * δ = ((m : ℝ) + (t : ℝ)) * δ := by
      simp [add_mul]
    _ = ((m : ℝ) + ((t : ℤ) : ℝ)) * δ := by
      -- Avoid `simp [ht']` here: it can loop because `Int.cast_ofNat` is simp-normalizing.
      simpa using congrArg (fun x : ℝ => ((m : ℝ) + x) * δ) ht'
    _ = ((m + (t : ℤ)) : ℝ) * δ := by
      simpa using congrArg (fun x : ℝ => x * δ) (Int.cast_add m (t : ℤ)).symm

/-- If every Θ on the k-grid is an integer multiple of δ, then differences are too. -/
lemma ZQuantized_diff
    {k : ℕ} {F : AtomFamily α k} {R : MultiGridRep F} {δ : ℝ}
    (hQZ : ZQuantized F R δ)
    (r s : Multi k) :
    ∃ m : ℤ,
      R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ -
      R.Θ_grid ⟨mu F s, mu_mem_kGrid F s⟩ = (m : ℝ) * δ := by
  rcases hQZ r with ⟨mr, hmr⟩
  rcases hQZ s with ⟨ms, hms⟩
  refine ⟨mr - ms, ?_⟩
  rw [hmr, hms, Int.cast_sub, sub_mul]

/-- Collapse the ±δ bracket to the unique integer.
If an integer multiple of δ lies strictly between ((Δ-1)·δ) and ((Δ+1)·δ),
then it must be exactly Δ·δ. -/
lemma int_multiple_eq_of_tight_bounds
    {δ : ℝ} (hδ : 0 < δ) {Δ : ℕ} {m : ℤ}
    {x : ℝ} (hx : x = (m : ℝ) * δ)
    (hlo : ((Δ : ℝ) - 1) * δ < x)
    (hhi : x < ((Δ : ℝ) + 1) * δ) :
    m = (Δ : ℤ) := by
  -- Divide strict inequalities by δ > 0
  rw [hx] at hlo hhi
  have hlo' : (Δ : ℝ) - 1 < (m : ℝ) := by
    have := (mul_lt_mul_iff_left₀ hδ).1 hlo
    linarith
  have hhi' : (m : ℝ) < (Δ : ℝ) + 1 := by
    have := (mul_lt_mul_iff_left₀ hδ).1 hhi
    linarith
  -- Now (Δ-1) < m < (Δ+1) in ℝ
  -- Since m is an integer and Δ is a natural number, the only possibility is m = Δ
  have h₁ : m < (Δ : ℤ) + 1 := by
    have : (m : ℝ) < ((Δ : ℤ) + 1 : ℤ) := by
      simp only [Int.cast_add, Int.cast_one, Int.cast_natCast]
      exact hhi'
    exact Int.cast_lt.mp this
  have h₂ : (Δ : ℤ) - 1 < m := by
    have : ((Δ : ℤ) - 1 : ℤ) < (m : ℝ) := by
      simp only [Int.cast_sub, Int.cast_one, Int.cast_natCast]
      exact hlo'
    exact Int.cast_lt.mp this
  omega

/-- Integer-multiple collapses inside a width-2δ window.
    If x is an integer multiple of δ and lies strictly between (Δ-1)·δ and (Δ+1)·δ,
    then x = Δ·δ exactly. This is the key "mesh collapse" lemma. -/
lemma intmul_eq_in_2δ_window
    {δ x : ℝ} {Δ : ℤ}
    (hδ : 0 < δ)
    (hZ : ∃ m : ℤ, x = (m : ℝ) * δ)
    (hlo : ((Δ : ℝ) - 1) * δ < x)
    (hhi : x < ((Δ : ℝ) + 1) * δ) :
    x = (Δ : ℝ) * δ := by
  rcases hZ with ⟨m, rfl⟩
  have : m = Δ := by
    by_contra hne
    have hm_lt : m ≤ Δ - 1 ∨ Δ + 1 ≤ m := by
      have := lt_trichotomy m Δ
      rcases this with hlt | hEQ | hgt
      · -- `Int.le_of_lt_add_one` wants `m < (Δ - 1) + 1`; rewrite using `sub_add_cancel`.
        have hlt' : m < (Δ - 1) + 1 := by
          simpa [sub_add_cancel] using hlt
        exact Or.inl (Int.le_of_lt_add_one hlt')      -- m ≤ Δ - 1
      · exact (hne hEQ).elim
      · exact Or.inr (Int.add_one_le_of_lt hgt)      -- Δ + 1 ≤ m
    rcases hm_lt with hle | hge
    · have : (m : ℝ) * δ ≤ ((Δ : ℝ) - 1) * δ := by
        have : (m : ℝ) ≤ (Δ : ℝ) - 1 := by exact_mod_cast hle
        exact mul_le_mul_of_nonneg_right this (le_of_lt hδ)
      exact (not_lt_of_ge this hlo).elim
    · have : ((Δ : ℝ) + 1) * δ ≤ (m : ℝ) * δ := by
        have : (Δ : ℝ) + 1 ≤ (m : ℝ) := by exact_mod_cast hge
        exact mul_le_mul_of_nonneg_right this (le_of_lt hδ)
      exact (not_lt_of_ge this hhi).elim
  simpa [this]

/- **ABC Correspondence Theorem** (K&S Appendix A, Section 3.2):
    The ZQuantized integer m exactly characterizes region membership.

    If θr - θs = m*δ, then:
    - m < u ↔ r is in A-region relative to s at level u (mu F r < op (mu F s) (d^u))
    - m = u ↔ r is on B-boundary relative to s at level u (mu F r = op (mu F s) (d^u))
    - m > u ↔ r is in C-region relative to s at level u (mu F r > op (mu F s) (d^u))

    This correspondence is the fundamental link between Θ-space and algebra space.
    It follows from the construction of δ via chooseδ and the representation axioms.

    **PROOF STRATEGY**:
    1. By trichotomy on α, exactly one of {<, =, >} holds for: mu F r vs op (mu F s) (d^u)
    2. **B-case (m = u ↔ equality)**: Use delta_shift_equiv. If mu F r = op (mu F s) (d^u),
       this is exactly a trade with Δ = u, so Θ(r) - Θ(s) = u*δ, hence m = u.
       Converse: if m = u, by trichotomy + cases 3,4 (which give m≠u), we have equality.
    3. **A-case (m < u ↔ strict less)**: If mu F r < op (mu F s) (d^u), then r is in
       extensionSetA F d v for some v > u (by shift). The A-bound gives Θ(r)/v ≤ δ.
       Combined with C-bound on s, ZQuantized gives m < u. Converse by trichotomy.
    4. **C-case (m > u ↔ strict greater)**: Symmetric to A-case.

    The key lemmas are: delta_shift_equiv, trade_shift_A/C, chooseδ properties (hδA, hδC, hδB),
    and intmul_eq_in_2δ_window for mesh collapse.
-/

/-! ### Theta' Helper Lemmas

These lemmas establish key properties of the extended representation Θ':
1. δ > 0 (chooseδ is always positive)
2. Theta'_increment_t: Incrementing t increases Θ' by exactly δ
3. Theta'_strictMono_same_t: With fixed t, Θ' is strictly monotone in the old part

These are used to complete the extend_grid_rep_with_atom proof.
-/

/-- δ is positive in both branches of `chooseδ`. -/
lemma delta_pos {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F)
    (d : α) (hd : ident < d) :
    0 < chooseδ hk R d hd := by
  classical
  unfold chooseδ
  split_ifs with hB
  · -- B ≠ ∅: δ = B_common_statistic = Θ(d^u)/u with u>0
    -- Extract a concrete B-witness without destroying hB
    have ⟨r,u,hu,hr⟩ := hB
    have hstat :
      B_common_statistic R d hd hB = separationStatistic R r u hu :=
      B_common_statistic_eq_any_witness R IH d hd hB r u hu hr
    -- Expand the statistic and use strict monotonicity + Θ(ident)=0
    simp [hstat, separationStatistic]
    -- Since ident < d^u, strict monotonicity of Θ_grid gives Θ(d^u) > Θ(ident)=0
    -- Key: hr : r ∈ extensionSetB means mu F r = iterate_op d u
    have h_mu_eq : mu F r = iterate_op d u := by simpa [extensionSetB] using hr
    -- So ident < mu F r (via ident < d^u = mu F r)
    have h_ident_lt : ident < mu F r := by
      rw [h_mu_eq]
      exact iterate_op_pos d hd u hu
    have hθ : R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩
              > R.Θ_grid ⟨ident, ident_mem_kGrid F⟩ :=
      R.strictMono h_ident_lt
    have huℝ : 0 < (u : ℝ) := Nat.cast_pos.mpr hu
    have : 0 < R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ :=
      by simpa [R.ident_eq_zero] using hθ
    exact div_pos this huℝ
  · -- B = ∅: B_empty_delta lies strictly between A and C statistics
    have hC : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u :=
      extensionSetC_nonempty_of_B_empty F hk d hd
        (by intro r u hu hr; exact hB ⟨r,u,hu,hr⟩)
    rcases hC with ⟨r,u,hu,hrC⟩
    have hposC : 0 < separationStatistic R r u hu := by
      -- In C, d^u < μ F r ⇒ Θ(d^u) < Θ(μ F r)
      have hμ : iterate_op d u < mu F r := by simpa [extensionSetC] using hrC
      -- d^u is in kGrid F because ident is, and we can use monotonicity
      -- Actually, we just need to show Θ(mu F r) - Θ(ident) > 0 since Θ is strictly monotone
      have huℝ : 0 < (u : ℝ) := Nat.cast_pos.mpr hu
      -- By strict monotonicity and ident < d^u < mu F r
      have h_ident_lt : ident < mu F r := by
        calc ident < iterate_op d u := iterate_op_pos d hd u hu
          _ < mu F r := hμ
      have hθ_pos : 0 < R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := by
        have hθ : R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ >
                  R.Θ_grid ⟨ident, ident_mem_kGrid F⟩ :=
          R.strictMono h_ident_lt
        simpa [R.ident_eq_zero] using hθ
      simp [separationStatistic]
      exact div_pos hθ_pos huℝ
    -- Key: By Archimedean property, the same r is in A(N) for large enough N
    -- So B_empty_delta ≥ Θ(mu F r)/N > 0
    have hθ_pos : 0 < R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := by
      have h_ident_lt : ident < mu F r := by
        have hμ : iterate_op d u < mu F r := by simpa [extensionSetC] using hrC
        calc ident < iterate_op d u := iterate_op_pos d hd u hu
          _ < mu F r := hμ
      have hθ : R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ >
                R.Θ_grid ⟨ident, ident_mem_kGrid F⟩ :=
        R.strictMono h_ident_lt
      simpa [R.ident_eq_zero] using hθ
    -- Use Archimedean to find N with mu F r < d^N (so r ∈ A(N))
    obtain ⟨N, hN_bound⟩ := bounded_by_iterate d hd (mu F r)
    have hN_pos : 0 < N := by
      by_contra h_not
      push_neg at h_not
      have : N = 0 := Nat.eq_zero_of_le_zero h_not
      subst this
      simp [iterate_op_zero] at hN_bound
      exact absurd hN_bound (not_lt.mpr (ident_le (mu F r)))
    have hrA : r ∈ extensionSetA F d N := by simpa [extensionSetA] using hN_bound
    have hN_stat_pos : 0 < R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / N := by
      have hNℝ : 0 < (N : ℝ) := Nat.cast_pos.mpr hN_pos
      exact div_pos hθ_pos hNℝ
    -- B_empty_delta = sSup {A-statistics} ≥ Θ(mu F r)/N > 0
    have h_stat_in : R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / N ∈
      {s : ℝ | ∃ r' u', 0 < u' ∧ r' ∈ extensionSetA F d u' ∧
        s = R.Θ_grid ⟨mu F r', mu_mem_kGrid F r'⟩ / u'} := by
      exact ⟨r, N, hN_pos, hrA, rfl⟩
    unfold B_empty_delta
    exact lt_csSup_of_lt
      (by {
        -- Bounded above by the C-statistic (r, u) using separation_property
        use separationStatistic R r u hu
        intro s ⟨r', u', hu', hrA', hs⟩
        subst hs
        -- Every A-statistic is < every C-statistic by separation_property
        exact le_of_lt (separation_property R H IH hd hu' hrA' hu hrC)
      })
      (by exact h_stat_in)
      hN_stat_pos

/-- chooseδ satisfies the A-bound: all A-statistics are ≤ δ. -/
lemma chooseδ_A_bound {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F) (d : α) (hd : ident < d) :
    ∀ r u (hu : 0 < u), r ∈ extensionSetA F d u →
      separationStatistic R r u hu ≤ chooseδ hk R d hd := by
  intro r u hu hrA
  unfold chooseδ
  split_ifs with hB_exists
  · -- B ≠ ∅: δ = B_common_statistic
    -- The B-statistic is the boundary separating A from C
    -- All A-statistics are < B-statistic by separation_property_A_B
    have hB_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetB F d u := hB_exists
    rcases hB_nonempty with ⟨rB, uB, huB, hrB⟩
    have h_B_eq : B_common_statistic R d hd hB_exists = separationStatistic R rB uB huB :=
      B_common_statistic_eq_any_witness R IH d hd hB_exists rB uB huB hrB
    rw [h_B_eq]
    exact le_of_lt (separation_property_A_B R H hd hu hrA huB hrB)
  · -- B = ∅: δ = B_empty_delta = sSup of A-statistics
    -- So A-stat ≤ sSup(A-statistics) = δ by definition
    have hB_empty : ∀ r' u', 0 < u' → r' ∉ extensionSetB F d u' :=
      fun r' u' hu' hr' => hB_exists ⟨r', u', hu', hr'⟩
    have hA_nonempty : ∃ r' u', 0 < u' ∧ r' ∈ extensionSetA F d u' :=
      extensionSetA_nonempty_of_B_empty F d hd hB_empty
    have hC_nonempty : ∃ r' u', 0 < u' ∧ r' ∈ extensionSetC F d u' :=
      extensionSetC_nonempty_of_B_empty F hk d hd hB_empty
    -- B_empty_delta is defined as sSup of A-statistics
    -- So our A-stat is ≤ sSup by le_csSup
    have h_in_set : separationStatistic R r u hu ∈
        {s : ℝ | ∃ r' u', 0 < u' ∧ r' ∈ extensionSetA F d u' ∧
          s = R.Θ_grid ⟨mu F r', mu_mem_kGrid F r'⟩ / u'} := by
      use r, u, hu, hrA
      rfl
    have h_bdd : BddAbove {s : ℝ | ∃ r' u', 0 < u' ∧ r' ∈ extensionSetA F d u' ∧
        s = R.Θ_grid ⟨mu F r', mu_mem_kGrid F r'⟩ / u'} := by
      obtain ⟨rC, uC, huC, hrC⟩ := hC_nonempty
      use separationStatistic R rC uC huC
      intro s ⟨r', u', hu', hrA', hs⟩
      subst hs
      exact le_of_lt (separation_property R H IH hd hu' hrA' huC hrC)
    simp only [separationStatistic]
    exact le_csSup h_bdd h_in_set

/-- chooseδ satisfies the C-bound: δ ≤ all C-statistics. -/
lemma chooseδ_C_bound {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F) (d : α) (hd : ident < d) :
    ∀ r u (hu : 0 < u), r ∈ extensionSetC F d u →
      chooseδ hk R d hd ≤ separationStatistic R r u hu := by
  intro r u hu hrC
  unfold chooseδ
  split_ifs with hB_exists
  · -- B ≠ ∅: δ = B_common_statistic
    -- The B-statistic is the boundary separating A from C
    -- B-statistic < C-statistics by separation_property_B_C
    have hB_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetB F d u := hB_exists
    rcases hB_nonempty with ⟨rB, uB, huB, hrB⟩
    have h_B_eq : B_common_statistic R d hd hB_exists = separationStatistic R rB uB huB :=
      B_common_statistic_eq_any_witness R IH d hd hB_exists rB uB huB hrB
    rw [h_B_eq]
    exact le_of_lt (separation_property_B_C R H hd huB hrB hu hrC)
  · -- B = ∅: δ = B_empty_delta = sSup of A-statistics
    -- sSup(A) ≤ C-stat by separation_property (all A < all C)
    have hB_empty : ∀ r' u', 0 < u' → r' ∉ extensionSetB F d u' :=
      fun r' u' hu' hr' => hB_exists ⟨r', u', hu', hr'⟩
    have hA_nonempty : ∃ r' u', 0 < u' ∧ r' ∈ extensionSetA F d u' :=
      extensionSetA_nonempty_of_B_empty F d hd hB_empty
    have hC_nonempty : ∃ r' u', 0 < u' ∧ r' ∈ extensionSetC F d u' :=
      extensionSetC_nonempty_of_B_empty F hk d hd hB_empty
    -- sSup(A-stats) ≤ C-stat because all A-stats < C-stat (separation)
    apply csSup_le
    · -- Set is nonempty
      obtain ⟨rA, uA, huA, hrA⟩ := hA_nonempty
      use R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ / uA
      exact ⟨rA, uA, huA, hrA, rfl⟩
    · -- Every element is ≤ the C-statistic
      intro s ⟨r', u', hu', hrA', hs⟩
      subst hs
      simp only [separationStatistic]
      exact le_of_lt (separation_property R H IH hd hu' hrA' hu hrC)

/-- chooseδ satisfies the B-bound: all B-statistics equal δ. -/
lemma chooseδ_B_bound {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (d : α) (hd : ident < d) :
    ∀ r u (hu : 0 < u), r ∈ extensionSetB F d u →
      separationStatistic R r u hu = chooseδ hk R d hd := by
  intro r u hu hrB
  unfold chooseδ
  split_ifs with hB_exists
  · -- B ≠ ∅: δ = B_common_statistic
    -- B_common_statistic equals any B-witness's statistic
    exact (B_common_statistic_eq_any_witness R IH d hd hB_exists r u hu hrB).symm
  · -- B = ∅: Contradiction - we have r ∈ B but B is empty!
    exfalso
    exact hB_exists ⟨r, u, hu, hrB⟩

/-! ### Uniqueness Hammer: δ is uniquely determined by its specification

The key insight (from GPT-5 Pro): Instead of fighting Classical.choose opacity,
we prove that ANY value satisfying the A/B/C bounds MUST equal chooseδ.
This gives path-independence "for free" - if two extension paths both produce
valid δ values, they must be equal because the specification is unique.

**DeltaSpec** captures exactly what δ must satisfy:
1. All A-statistics are ≤ δ (upper bound from A-region)
2. δ ≤ all C-statistics (lower bound from C-region)
3. All B-statistics equal δ (exact match on B-boundary)
-/

/-- The specification that any valid δ must satisfy. -/
def DeltaSpec {k : ℕ} (F : AtomFamily α k) (R : MultiGridRep F)
    (d : α) (hd : ident < d) (v : ℝ) : Prop :=
  (∀ r u (hu : 0 < u), r ∈ extensionSetA F d u → separationStatistic R r u hu ≤ v) ∧
  (∀ r u (hu : 0 < u), r ∈ extensionSetC F d u → v ≤ separationStatistic R r u hu) ∧
  (∀ r u (hu : 0 < u), r ∈ extensionSetB F d u → separationStatistic R r u hu = v)

/-- chooseδ satisfies the DeltaSpec. -/
lemma chooseδ_spec {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F) (d : α) (hd : ident < d) :
    DeltaSpec F R d hd (chooseδ hk R d hd) := by
  refine ⟨?hA, ?hC, ?hB⟩
  · -- A-bound
    exact chooseδ_A_bound hk R IH H d hd
  · -- C-bound
    exact chooseδ_C_bound hk R IH H d hd
  · -- B-bound
    intro r u hu hrB
    exact chooseδ_B_bound hk R IH d hd r u hu hrB

/-- Any two values satisfying DeltaSpec are equal (the uniqueness hammer).

The proof splits on B nonempty vs B empty:
- B nonempty: Both values equal the B-statistic, hence equal each other
- B empty: Both are squeezed between A-stats (below) and C-stats (above).
  The accuracy lemma shows A-stats and C-stats get arbitrarily close,
  so the squeeze forces equality. -/
lemma DeltaSpec_unique {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F)
    (d : α) (hd : ident < d) {v w : ℝ}
    (hv : DeltaSpec F R d hd v) (hw : DeltaSpec F R d hd w) :
    v = w := by
  -- Case split on B nonempty vs B empty
  by_cases hB : ∃ r u, 0 < u ∧ r ∈ extensionSetB F d u
  · -- B ≠ ∅: Both v and w equal the common B-statistic
    rcases hB with ⟨r, u, hu, hrB⟩
    -- v equals B-stat
    have hv_eq : separationStatistic R r u hu = v := hv.2.2 r u hu hrB
    -- w equals B-stat
    have hw_eq : separationStatistic R r u hu = w := hw.2.2 r u hu hrB
    rw [← hv_eq, hw_eq]
  · -- B = ∅: Use the squeeze argument
    -- We have: all A-stats ≤ v ≤ all C-stats
    --          all A-stats ≤ w ≤ all C-stats
    -- And: for any ε > 0, there exist A-stat and C-stat with C - A < ε
    -- Therefore v and w are both squeezed to the same value.
    push_neg at hB
    have hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u := hB

    -- Get bounds from both specs
    have hA_v := hv.1
    have hC_v := hv.2.1
    have hA_w := hw.1
    have hC_w := hw.2.1

    -- Standard squeeze: show |v - w| = 0
    by_contra h_ne
    push_neg at h_ne

    -- Get the accuracy: for any ε > 0, there are A,C stats within ε
    have hA_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u :=
      extensionSetA_nonempty_of_B_empty F d hd hB_empty
    have hC_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u :=
      extensionSetC_nonempty_of_B_empty F hk d hd hB_empty

    -- Take ε = |v - w|
    have hε : 0 < |v - w| := abs_pos.mpr (sub_ne_zero.mpr h_ne)

    -- From A/C bounds: v is between some A-stat and some C-stat
    -- From separation_property: all A-stats < all C-stats
    -- So: max(A-stats) ≤ v ≤ min(C-stats) and max(A-stats) ≤ w ≤ min(C-stats)
    -- Hence v and w are both in the interval [sup(A), inf(C)]
    -- And this interval shrinks to a point (by accuracy lemma / B_empty_delta construction)

    -- More direct: v ≤ C-stat for all C, w ≥ A-stat for all A
    -- If v > w: pick C-stat < v (but v ≤ all C-stats, contradiction)
    -- If w > v: pick A-stat > v... but wait, we need more careful argument

    -- Key: Both v and w lie in [sup(A-stats), inf(C-stats)]
    -- Since B = ∅, this is a single point (or empty, but we have nonemptiness)
    -- Actually, when B = ∅, sup(A) = inf(C) by the Dedekind cut property

    -- Let's use the existing B_empty_delta structure
    -- B_empty_delta = sSup(A-stats), and all C-stats are ≥ this sup

    -- From hA_v: all A-stats ≤ v
    -- From hC_v: v ≤ all C-stats
    -- Together: v is in the interval [sup(A-stats), inf(C-stats)]
    -- But when B = ∅, this interval is actually a single point (or A-stats approach C-stats)

    -- The chooseδ when B = ∅ is defined as B_empty_delta = sSup(A-stats)
    -- We need to show: sSup(A-stats) = sInf(C-stats) when B = ∅

    -- Alternative approach: use that v and w both satisfy the spec
    -- Since chooseδ = sSup(A-stats), and A-stats ≤ v ≤ C-stats,
    -- and A-stats ≤ w ≤ C-stats, with sup(A) ≤ v,w ≤ inf(C)
    -- and separation_property shows sup(A) = inf(C) when B = ∅

    -- Actually the key is: For any ε > 0, we can find A-stat and C-stat
    -- such that C-stat - A-stat < ε. This is the "accuracy" property.
    -- With v between them: A-stat ≤ v ≤ C-stat, so v ∈ [A-stat, C-stat]
    -- Similarly for w. Taking ε → 0, both v and w converge to the same point.

    -- For now, use the squeeze:
    -- Pick any A-witness and C-witness
    have hA_nonempty' := hA_nonempty
    have hC_nonempty' := hC_nonempty
    rcases hA_nonempty' with ⟨rA, uA, huA, hrA⟩
    rcases hC_nonempty' with ⟨rC, uC, huC, hrC⟩

    have h1 : separationStatistic R rA uA huA ≤ v := hA_v rA uA huA hrA
    have h2 : v ≤ separationStatistic R rC uC huC := hC_v rC uC huC hrC
    have h3 : separationStatistic R rA uA huA ≤ w := hA_w rA uA huA hrA
    have h4 : w ≤ separationStatistic R rC uC huC := hC_w rC uC huC hrC

    -- From separation_property: A-stat < C-stat
    have h_sep : separationStatistic R rA uA huA < separationStatistic R rC uC huC :=
      separation_property R H IH hd huA hrA huC hrC

    -- Both v and w are in the interval (A-stat, C-stat)
    -- To show v = w, we use the fact that the interval width can be made arbitrarily small

    -- For any pair (A-witness, C-witness), the width is C-stat - A-stat
    -- The infimum of these widths is 0 (by the accuracy property)
    -- Therefore both v and w must equal the common limit point

    -- Use the B_empty_delta construction: δ = sSup(A-stats)
    -- And sSup(A-stats) = sInf(C-stats) when B = ∅ (by the accuracy property)

    -- Direct calculation: v ∈ [sup(A), inf(C)] and w ∈ [sup(A), inf(C)]
    -- If sup(A) = inf(C), then v = w = this common value

    -- The key lemma we need: when B = ∅, sSup(A-stats) = sInf(C-stats)
    -- This follows from separation_property and the density argument

    -- Use accuracy_lemma to derive contradiction
    -- Key: for any ε > 0, there exist A-stat and C-stat with gap < ε
    -- Since |v - w| > 0, take ε = |v - w| / 2
    -- Then find A'/C' with gap < ε
    -- Both v and w lie in [A'-stat, C'-stat], so |v - w| ≤ gap < |v - w| / 2
    -- Contradiction!

    have hε_half : 0 < |v - w| / 2 := by linarith

    -- Get tight witnesses from accuracy_lemma
    obtain ⟨rA', uA', huA', hrA', rC', uC', huC', hrC', h_gap⟩ :=
      accuracy_lemma R d hd hB_empty hA_nonempty hC_nonempty (|v - w| / 2) hε_half

    -- Both v and w are bounded by these witnesses
    have h1' : separationStatistic R rA' uA' huA' ≤ v := hA_v rA' uA' huA' hrA'
    have h2' : v ≤ separationStatistic R rC' uC' huC' := hC_v rC' uC' huC' hrC'
    have h3' : separationStatistic R rA' uA' huA' ≤ w := hA_w rA' uA' huA' hrA'
    have h4' : w ≤ separationStatistic R rC' uC' huC' := hC_w rC' uC' huC' hrC'

    -- So |v - w| ≤ gap
    have h_vw_tight : |v - w| ≤ separationStatistic R rC' uC' huC' - separationStatistic R rA' uA' huA' := by
      rw [abs_le]
      constructor <;> linarith

    -- But gap < |v - w| / 2, so |v - w| < |v - w| / 2, contradiction
    linarith

/-- If v satisfies DeltaSpec, then v = chooseδ.

This is the main hammer for path-independence:
Any construction that produces a valid δ (satisfying the A/B/C bounds)
must produce exactly chooseδ. -/
lemma delta_unique {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F)
    (d : α) (hd : ident < d) {v : ℝ}
    (hv : DeltaSpec F R d hd v) :
    v = chooseδ hk R d hd := by
  have hw := chooseδ_spec hk R IH H d hd
  exact DeltaSpec_unique hk R IH H d hd hv hw

/-! ### δ-Monotonicity: Extension Preserves or Increases δ

When we extend a family F₁ with atom y to get F₂, and then want to add another
atom x to both, the δ value for x can only stay the same or increase.

**Key insight**: The A/B/C witnesses for x embed from F₁ into F₂:
- B-witnesses embed: (r, u) with μ r = x^u in F₁ gives (r, 0) with same μ in F₂
- A-witnesses embed similarly
- C-witnesses embed similarly

The separation statistics are preserved under embedding because:
- Θ values on the old grid are preserved by extension formula
- The ratio Θ(r)/u is unchanged

Therefore:
- If B_{F₁}(x) ≠ ∅: same B-witness exists in F₂, same B-statistic, same δ
- If B_{F₁}(x) = ∅ but B_{F₂}(x) ≠ ∅: new B-witness gives δ' ≥ sSup(A_{F₁}) = δ
- If both B = ∅: larger A-set in F₂ gives sSup(A_{F₂}) ≥ sSup(A_{F₁})

In all cases: chooseδ(F₁, x) ≤ chooseδ(F₂, x)
-/

/-- **δ-monotonicity**: Extending the base family can only increase the δ value.

This is the key lemma that allows us to connect the global Θ definition
(using 2-atom families) with larger families (like 3-atom families for
proving order and additivity).

The proof relies on the embedding of A/B/C witnesses and the uniqueness
of δ satisfying the DeltaSpec. -/
lemma chooseδ_monotone_family
    {k : ℕ} (hk : k ≥ 1) {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F) (H : GridComm F) (y : α) (hy : ident < y)
    {F' : AtomFamily α (k + 1)} (R' : MultiGridRep F')
    (hF'_old : ∀ i : Fin k, F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.is_lt⟩ = F.atoms i)
    (hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = y)
    (hR'_extends : ∀ (r : Multi k),
        R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ =
        R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩)
    (hk' : k + 1 ≥ 1) (IH' : GridBridge F') (H' : GridComm F')
    (x : α) (hx : ident < x) :
    chooseδ hk R x hx ≤ chooseδ hk' R' x hx := by
  -- The proof uses the fact that A/B/C witnesses embed from F into F'
  -- and the separation statistics are preserved.

  -- Let δ := chooseδ hk R x hx and δ' := chooseδ hk' R' x hx
  set δ := chooseδ hk R x hx
  set δ' := chooseδ hk' R' x hx

  -- Get the DeltaSpec for δ'
  have hδ'_spec := chooseδ_spec hk' R' IH' H' x hx

  -- We'll show δ satisfies the A-bound from F' (after embedding)
  -- and use the fact that δ' is the unique value satisfying DeltaSpec for F'

  -- Case split on B-nonempty for F
  by_cases hB : ∃ r u, 0 < u ∧ r ∈ extensionSetB F x u
  · -- B ≠ ∅ for F: δ = B_common_statistic
    -- The B-witness (r, u) embeds into F' as (r, 0) with same μ-value
    -- By hR'_extends, the separation statistic is preserved
    -- So B ≠ ∅ for F' with the same statistic, hence δ = δ'
    rcases hB with ⟨r, u, hu, hrB⟩

    -- The B-witness membership: μ r = x^u
    have h_mu_B : mu F r = iterate_op x u := by
      simp only [extensionSetB, Set.mem_setOf_eq] at hrB
      exact hrB

    -- Embed into F': consider (r, 0) in F'
    -- μ F' (joinMulti r 0) = μ F r = x^u
    have h_mu_embed : mu F' (joinMulti r 0) = iterate_op x u := by
      have hμ0 : mu F' (joinMulti r 0) = mu F r := by
        simpa [iterate_op_zero, op_ident_right] using
          (mu_extend_last_of_old_new F y hy F' hF'_old hF'_new r 0)
      calc
        mu F' (joinMulti r 0) = mu F r := hμ0
        _ = iterate_op x u := h_mu_B

    -- So (joinMulti r 0) ∈ extensionSetB F' x u
    have hrB' : joinMulti r 0 ∈ extensionSetB F' x u := h_mu_embed

    -- Both δ and δ' equal the B-statistic
    have hδ_eq : separationStatistic R r u hu = δ := by
      simpa [δ] using chooseδ_B_bound hk R IH x hx r u hu hrB
    have hδ'_eq : separationStatistic R' (joinMulti r 0) u hu = δ' := by
      simpa [δ'] using chooseδ_B_bound hk' R' IH' x hx (joinMulti r 0) u hu hrB'

    -- The statistics are equal by hR'_extends
    have h_stat_eq : separationStatistic R' (joinMulti r 0) u hu =
                     separationStatistic R r u hu := by
      simp only [separationStatistic]
      have := hR'_extends r
      rw [this]

    have h_eq : δ = δ' := by
      calc
        δ = separationStatistic R r u hu := (hδ_eq).symm
        _ = separationStatistic R' (joinMulti r 0) u hu := (h_stat_eq).symm
        _ = δ' := hδ'_eq
    exact le_of_eq h_eq

  · -- B = ∅ for F: δ = sSup(A-stats from F)
    -- Either B ≠ ∅ for F' (new B-witness involving y), or B = ∅ for F'
    -- In either case, δ' ≥ all A-stats from F, so δ' ≥ δ

    push_neg at hB
    have hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F x u := hB

    -- Get A-bound: all A-stats from F are ≤ δ
    have hA := chooseδ_A_bound hk R IH H x hx

    -- The A-stats from F are also ≤ δ' because:
    -- 1. If B ≠ ∅ for F': δ' = B-stat ≥ all A-stats (including embedded ones)
    -- 2. If B = ∅ for F': δ' = sSup(A-stats from F') ≥ sSup(embedded A-stats from F)

    -- Key: Show δ satisfies the A-bound from DeltaSpec for F' (on embedded witnesses)
    -- Then since δ' is the unique value satisfying DeltaSpec for F', and
    -- δ satisfies the A-part, we get δ ≤ δ'

    -- More precisely: δ' ≥ all A-stats from F' ⊇ embedded A-stats from F
    -- And δ = sSup(A-stats from F) ≤ any upper bound ≤ δ'

    -- The formal proof requires tracking the embedding carefully.
    -- The key property is: hR'_extends ensures statistics are preserved.

    -- For any A-witness (r, u) in F with μ r < x^u, the embedding (r, 0) gives:
    -- μ F' (joinMulti r 0) = μ F r < x^u
    -- So (joinMulti r 0) ∈ extensionSetA F' x u
    -- And separationStatistic R' (joinMulti r 0) u hu = separationStatistic R r u hu

    -- Since δ' ≥ all A-stats from F', it's ≥ all embedded A-stats from F
    -- So δ' ≥ sSup(A-stats from F) = δ (when B = ∅ for F)

    -- Show δ ≤ δ' using that all A-stats from F are ≤ δ'
    have h_δ_le : δ ≤ δ' := by
      -- δ = sSup(A-stats from F) since B = ∅
      -- We need: this sup ≤ δ'

      -- It suffices to show: all A-stats from F are ≤ δ'
      -- Because then sSup ≤ the common upper bound

      have hA' := chooseδ_A_bound hk' R' IH' H' x hx

      -- δ' ≥ all A-stats from F', which includes embedded A-stats from F
      -- So δ' is an upper bound for all A-stats from F

      -- The formal argument uses:
      -- 1. Every A-stat from F corresponds to an A-stat from F' with same value
      -- 2. δ' ≥ all A-stats from F'
      -- 3. Therefore δ' ≥ all A-stats from F
      -- 4. Since δ = sSup(A-stats from F), δ ≤ δ'

      -- For the embedding, we need to show that the extension preserves the statistics.
      -- This is where hR'_extends is crucial.

      -- The formal proof requires showing that for every r ∈ A(F, x, u),
      -- the embedding joinMulti r 0 ∈ A(F', x, u) and the statistics match.
      -- This is the "witness embedding" property.

      -- Key: μ F' (joinMulti r 0) = μ F r via the extension formula
      have h_mu_eq : ∀ r : Multi k, mu F' (joinMulti r 0) = mu F r := by
        intro r_wit
        simpa [iterate_op_zero, op_ident_right] using
          (mu_extend_last_of_old_new F y hy F' hF'_old hF'_new r_wit 0)

      -- Helper: For any A-witness (r, u), the embedded witness has same statistic
      have h_embed_stat : ∀ r u (hu : 0 < u), r ∈ extensionSetA F x u →
          separationStatistic R r u hu ≤ δ' := by
        intro r_wit u_wit hu_wit hr_wit_A
        -- The embedding joinMulti r_wit 0 is in extensionSetA F' x u_wit
        have hr_wit_A' : joinMulti r_wit 0 ∈ extensionSetA F' x u_wit := by
          simp only [extensionSetA, Set.mem_setOf_eq]
          rw [h_mu_eq]
          simp only [extensionSetA, Set.mem_setOf_eq] at hr_wit_A
          exact hr_wit_A
        -- The statistic is preserved
        have h_stat_eq : separationStatistic R r_wit u_wit hu_wit =
                         separationStatistic R' (joinMulti r_wit 0) u_wit hu_wit := by
          simp only [separationStatistic]
          have := hR'_extends r_wit
          rw [this]
        -- Apply δ' A-bound
        have h_bound := hA' (joinMulti r_wit 0) u_wit hu_wit hr_wit_A'
        rw [h_stat_eq]
        exact h_bound

      -- Now use csSup_le: δ = sSup(A-stats from F) and δ' bounds all of them
      -- The definition of chooseδ when B=∅ uses B_empty_delta which is sSup
      -- We need to show the sSup ≤ δ'

      -- Since B = ∅ for F, chooseδ returns B_empty_delta which is sSup of A-stats
      simp only [δ, chooseδ]
      split_ifs with hB'
      · -- If B ≠ ∅ for some other reason (shouldn't happen, we already know B = ∅)
        exfalso
        rcases hB' with ⟨r_B, u_B, hu_B, hr_B⟩
        exact hB_empty r_B u_B hu_B hr_B
      · -- B = ∅: δ = sSup(A-stats)
        unfold B_empty_delta
        apply csSup_le
        · -- Nonempty: A is nonempty when B = ∅
          obtain ⟨rA, uA, huA, hrA⟩ := extensionSetA_nonempty_of_B_empty F x hx hB_empty
          use R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ / uA
          use rA, uA, huA, hrA
        · -- Upper bound: each element ≤ δ'
          intro s hs
          rcases hs with ⟨r_s, u_s, hu_s, hr_s_A, rfl⟩
          exact h_embed_stat r_s u_s hu_s hr_s_A

    exact h_δ_le

/-- **Path independence when B ≠ ∅**: If B ≠ ∅ for the base family, then chooseδ is preserved
when extending the family. This is the key to proving additivity in the x ≠ y case.

When B ≠ ∅ for (R, x), the B-witnesses embed into any extension R' with the same
separation statistic, so chooseδ(R, x) = chooseδ(R', x). -/
lemma chooseδ_eq_of_B_nonempty
    {k : ℕ} (hk : k ≥ 1) {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F) (H : GridComm F) (y : α) (hy : ident < y)
    {F' : AtomFamily α (k + 1)} (R' : MultiGridRep F')
    (hF'_old : ∀ i : Fin k, F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.is_lt⟩ = F.atoms i)
    (hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = y)
    (hR'_extends : ∀ (r : Multi k),
        R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ =
        R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩)
    (hk' : k + 1 ≥ 1) (IH' : GridBridge F') (H' : GridComm F')
    (x : α) (hx : ident < x)
    (hB : ∃ r u, 0 < u ∧ r ∈ extensionSetB F x u) :
    chooseδ hk R x hx = chooseδ hk' R' x hx := by
  -- When B ≠ ∅ for F, the B-witness embeds into F' with same statistic
  rcases hB with ⟨r, u, hu, hrB⟩

  -- The B-witness membership: μ r = x^u
  have h_mu_B : mu F r = iterate_op x u := by
    simp only [extensionSetB, Set.mem_setOf_eq] at hrB
    exact hrB

  -- Embed into F': (joinMulti r 0) has same μ-value
  have h_mu_embed : mu F' (joinMulti r 0) = iterate_op x u := by
    have hμ0 : mu F' (joinMulti r 0) = mu F r := by
      simpa [iterate_op_zero, op_ident_right] using
        (mu_extend_last_of_old_new F y hy F' hF'_old hF'_new r 0)
    calc
      mu F' (joinMulti r 0) = mu F r := hμ0
      _ = iterate_op x u := h_mu_B

  -- So (joinMulti r 0) ∈ extensionSetB F' x u
  have hrB' : joinMulti r 0 ∈ extensionSetB F' x u := h_mu_embed

  -- Both chooseδ values equal the B-statistic
  have hδ_eq := chooseδ_B_bound hk R IH x hx r u hu hrB
  have hδ'_eq := chooseδ_B_bound hk' R' IH' x hx (joinMulti r 0) u hu hrB'

  -- The statistics are equal by hR'_extends
  have h_stat_eq : separationStatistic R' (joinMulti r 0) u hu =
                   separationStatistic R r u hu := by
    simp only [separationStatistic]
    have := hR'_extends r
    rw [this]

  rw [← hδ_eq, ← hδ'_eq, h_stat_eq]

/-! ### Path Independence Bridge: Extension Value Satisfies Base Spec

This is the KEY lemma for path independence (GPT-5 Pro's insight):
When we extend F to F' by adding atom d, the value that R' assigns to d
satisfies the DeltaSpec relative to the BASE family (F, R, d).

By uniqueness (`delta_unique`), this means R'.Θ_grid(d) = chooseδ(R, d).

This gives path independence "for free" - any extension path that constructs
a valid representation will assign the same value to d, because that value
is uniquely determined by the A/B/C specification.
-/

/-- **Extension value satisfies base spec** (the path independence bridge).

When we extend F → F' by adding atom d, the value R'.Θ_grid(d) that the
extended representation assigns to d satisfies the DeltaSpec for (F, R, d).

Combined with `delta_unique`, this proves: R'.Θ_grid(d) = chooseδ(F, R, d),
which is the core of path independence. -/
lemma ext_value_satisfies_base_spec
    {k : ℕ} (hk : k ≥ 1) {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F) (H : GridComm F) (d : α) (hd : ident < d)
    {F' : AtomFamily α (k + 1)} (R' : MultiGridRep F')
    (hF'_old : ∀ i : Fin k, F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.is_lt⟩ = F.atoms i)
    (hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = d)
    (hR'_extends : ∀ (r : Multi k) (t : ℕ),
        R'.Θ_grid ⟨mu F' (joinMulti r t), mu_mem_kGrid F' (joinMulti r t)⟩ =
        R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ + (t : ℝ) * chooseδ hk R d hd) :
    let v := R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1), mu_mem_kGrid F' _⟩
    DeltaSpec F R d hd v := by
  intro v
  classical
  have h_unit_1 : unitMulti ⟨k, Nat.lt_succ_self k⟩ 1 = joinMulti (fun _ => 0) 1 := by
    ext i
    by_cases hi : i.val < k
    · have : i ≠ ⟨k, Nat.lt_succ_self k⟩ := by
        intro hEq
        have : (i.val : ℕ) = k := by simpa using congrArg Fin.val hEq
        exact (Nat.ne_of_lt hi) this
      simp [unitMulti, joinMulti, hi, this]
    · have hik : i.val = k := by omega
      have hi_eq : i = ⟨k, Nat.lt_succ_self k⟩ := by ext; exact hik
      subst hi_eq
      simp [unitMulti, joinMulti, Nat.lt_irrefl]

  have hv : v = chooseδ hk R d hd := by
    have hv_def :
        v =
          R'.Θ_grid
            ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1),
              mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1)⟩ := rfl
    rw [hv_def, h_unit_1]
    have h_ext := hR'_extends (fun _ => 0) 1
    have h0 :
        R.Θ_grid ⟨mu F (fun _ => 0), mu_mem_kGrid F (fun _ => 0)⟩ = 0 := by
      have hx :
          (⟨mu F (fun _ => 0), mu_mem_kGrid F (fun _ => 0)⟩ : {x // x ∈ kGrid F}) =
            ⟨ident, ident_mem_kGrid F⟩ := by
        ext; simp [mu_zero (F := F)]
      simpa [hx] using R.ident_eq_zero
    simpa [h0, add_zero] using h_ext

  rw [hv]
  exact chooseδ_spec hk R IH H d hd

  /-
  refine ⟨?hA, ?hC, ?hB⟩

  · -- A-bound: For r ∈ A (mu r < d^u), show separationStatistic R r u ≤ v
    intro r u hu hrA
    -- hrA : mu F r < iterate_op d u
    -- We need: R.Θ_grid(r) / u ≤ v

    -- In F', we can compare mu F' (joinMulti r 0) < mu F' (unitMulti ⟨k,...⟩ u)
    -- because:
    --   mu F' (joinMulti r 0) = mu F r  (by extension formula with t=0)
    --   mu F' (unitMulti ⟨k,...⟩ u) = d^u (by mu_unitMulti)

    -- Algebraic inequality in F'
    have h_mu_r : mu F' (joinMulti r 0) = mu F r := by
      simpa [iterate_op_zero, op_ident_right] using
        (mu_extend_last_of_old_new F d hd F' hF'_old hF'_new r 0)

    have h_mu_du : mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) = iterate_op d u := by
      have := mu_unitMulti F' ⟨k, Nat.lt_succ_self k⟩ u
      rw [hF'_new] at this
      exact this

    have h_lt_F' : mu F' (joinMulti r 0) < mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) := by
      rw [h_mu_r, h_mu_du]
      exact hrA

    -- Apply R'.strictMono
    have h_theta_lt :
        R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ <
          R'.Θ_grid
            ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u),
              mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)⟩ := by
      apply R'.strictMono
      -- `<` on the subtype reduces to `<` on `α`
      change
        mu F' (joinMulti r 0) < mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)
      exact h_lt_F'

    -- Rewrite using extension formulas
    have h_theta_r :
        R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ =
          R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := by
      have := hR'_extends r 0
      simpa using this

    have h_theta_du :
        R'.Θ_grid
            ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u),
              mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)⟩ =
          (u : ℝ) * chooseδ hk R d hd := by
      -- `unitMulti (last) u` is exactly `joinMulti 0 u`.
      have h_eq : unitMulti ⟨k, Nat.lt_succ_self k⟩ u = joinMulti (fun _ => 0) u := by
        ext i
        by_cases hi : i.val < k
        · have : i ≠ ⟨k, Nat.lt_succ_self k⟩ := by
            intro hEq
            have : (i.val : ℕ) = k := by simpa using congrArg Fin.val hEq
            exact (Nat.ne_of_lt hi) this
          simp [unitMulti, joinMulti, hi, this]
        · have hik : i.val = k := by omega
          have hi_eq : i = ⟨k, Nat.lt_succ_self k⟩ := by ext; exact hik
          subst hi_eq
          simp [unitMulti, joinMulti, Nat.lt_irrefl]
      -- Reduce to the extension equation at `(0,u)` and use `Θ(ident)=0`.
      rw [h_eq]
      have h_ext := hR'_extends (fun _ => 0) u
      have h0 : R.Θ_grid ⟨mu F (fun _ => 0), mu_mem_kGrid F (fun _ => 0)⟩ = 0 := by
        have hx :
            (⟨mu F (fun _ => 0), mu_mem_kGrid F (fun _ => 0)⟩ : {x // x ∈ kGrid F}) =
              ⟨ident, ident_mem_kGrid F⟩ := by
          ext; simp [mu_zero (F := F)]
        simpa [hx] using R.ident_eq_zero
      simpa [h0, add_zero] using h_ext

    -- Now: R.Θ_grid(r) < u * δ
    -- Therefore: R.Θ_grid(r) / u < δ
    have h_ineq :
        R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ < (u : ℝ) * chooseδ hk R d hd := by
      calc
        R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩
            = R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ := h_theta_r.symm
        _ < R'.Θ_grid
              ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u),
                mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)⟩ := h_theta_lt
        _ = (u : ℝ) * chooseδ hk R d hd := h_theta_du

    -- Divide by u (which is positive)
    have hu_pos : (0 : ℝ) < (u : ℝ) := Nat.cast_pos.mpr hu
    have hδ_pos : 0 < chooseδ hk R d hd := delta_pos hk R IH H d hd

    have h_lt : separationStatistic R r u hu < v := by
      calc separationStatistic R r u hu
          = R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / (u : ℝ) := rfl
        _ < ((u : ℝ) * chooseδ hk R d hd) / (u : ℝ) := by
              exact div_lt_div_of_pos_right h_ineq hu_pos
        _ = chooseδ hk R d hd := by field_simp
        _ = v := by
          -- v is defined as R'.Θ_grid(d) where d = F'.atoms ⟨k,...⟩
          -- which equals R'.Θ_grid(unitMulti ⟨k,...⟩ 1)
          -- which equals 1 * δ by extension formula
          have h_v_eq : v = R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1), _⟩ := rfl
          rw [h_v_eq]
          have h_unit_1 : unitMulti ⟨k, Nat.lt_succ_self k⟩ 1 = joinMulti (fun _ => 0) 1 := by
            ext i; simp [unitMulti, joinMulti]
            by_cases h : i.val = k <;> simp [h]
          rw [h_unit_1]
          have := hR'_extends (fun _ => 0) 1
          simp [R.ident_eq_zero] at this
          exact this.symm
    exact le_of_lt h_lt

  · -- C-bound: For r ∈ C (d^u < mu r), show v ≤ separationStatistic R r u
    intro r u hu hrC
    -- hrC : iterate_op d u < mu F r
    -- We need: v ≤ R.Θ_grid(r) / u

    -- Similar to A-bound but inequality flipped
    have h_mu_r : mu F' (joinMulti r 0) = mu F r := by
      simpa [iterate_op_zero, op_ident_right] using
        (mu_extend_last_of_old_new F d hd F' hF'_old hF'_new r 0)

    have h_mu_du : mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) = iterate_op d u := by
      have := mu_unitMulti F' ⟨k, Nat.lt_succ_self k⟩ u
      rw [hF'_new] at this
      exact this

    have h_lt_F' : mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) < mu F' (joinMulti r 0) := by
      rw [h_mu_r, h_mu_du]
      exact hrC

    have h_theta_lt :
        R'.Θ_grid
            ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u),
              mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)⟩ <
          R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ := by
      apply R'.strictMono
      change
        mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) < mu F' (joinMulti r 0)
      exact h_lt_F'

    have h_theta_r :
        R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ =
          R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := by
      have := hR'_extends r 0
      simpa using this

    have h_theta_du :
        R'.Θ_grid
            ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u),
              mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)⟩ =
                       (u : ℝ) * chooseδ hk R d hd := by
      have h_eq : unitMulti ⟨k, Nat.lt_succ_self k⟩ u = joinMulti (fun _ => 0) u := by
        ext i; simp [unitMulti, joinMulti]
        by_cases h : i.val = k <;> simp [h]
      rw [h_eq]
      have := hR'_extends (fun _ => 0) u
      simp [R.ident_eq_zero] at this
      exact this

    have h_ineq : (u : ℝ) * chooseδ hk R d hd < R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := by
      calc (u : ℝ) * chooseδ hk R d hd
          = R'.Θ_grid
              ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u),
                mu_mem_kGrid F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u)⟩ := h_theta_du.symm
        _ < R'.Θ_grid ⟨mu F' (joinMulti r 0), mu_mem_kGrid F' (joinMulti r 0)⟩ := h_theta_lt
        _ = R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := h_theta_r

    have hu_pos : (0 : ℝ) < (u : ℝ) := Nat.cast_pos.mpr hu

    calc v = chooseδ hk R d hd := by
            have h_v_eq : v = R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1), _⟩ := rfl
            rw [h_v_eq]
            have h_unit_1 : unitMulti ⟨k, Nat.lt_succ_self k⟩ 1 = joinMulti (fun _ => 0) 1 := by
              ext i; simp [unitMulti, joinMulti]
              by_cases h : i.val = k <;> simp [h]
            rw [h_unit_1]
            have := hR'_extends (fun _ => 0) 1
            simp [R.ident_eq_zero] at this
            exact this.symm
      _ = ((u : ℝ) * chooseδ hk R d hd) / (u : ℝ) := by field_simp
      _ < R.Θ_grid ⟨mu F r, _⟩ / (u : ℝ) := by exact div_lt_div_of_pos_right h_ineq hu_pos
      _ = separationStatistic R r u hu := rfl

  · -- B-case: For r ∈ B (mu r = d^u), show separationStatistic R r u = v
    intro r u hu hrB
    -- hrB : mu F r = iterate_op d u
    -- We need: R.Θ_grid(r) / u = v

    -- In F', mu F' (joinMulti r 0) = mu F r = d^u = mu F' (unitMulti ⟨k,...⟩ u)
    have h_mu_r : mu F' (joinMulti r 0) = mu F r := by
      simpa [iterate_op_zero, op_ident_right] using
        (mu_extend_last_of_old_new F d hd F' hF'_old hF'_new r 0)

    have h_mu_du : mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) = iterate_op d u := by
      have := mu_unitMulti F' ⟨k, Nat.lt_succ_self k⟩ u
      rw [hF'_new] at this
      exact this

    have h_eq_F' : mu F' (joinMulti r 0) = mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u) := by
      rw [h_mu_r, h_mu_du]
      exact hrB

    -- Therefore Θ-values are equal
    have h_theta_eq : R'.Θ_grid ⟨mu F' (joinMulti r 0), _⟩ =
                       R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u), _⟩ := by
      have : (⟨mu F' (joinMulti r 0), mu_mem_kGrid F' _⟩ : {x // x ∈ kGrid F'}) =
             ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u), mu_mem_kGrid F' _⟩ := by
        ext; exact h_eq_F'
      rw [this]

    -- Rewrite both sides using extension formulas
    have h_theta_r : R'.Θ_grid ⟨mu F' (joinMulti r 0), _⟩ = R.Θ_grid ⟨mu F r, _⟩ := by
      have := hR'_extends r 0
      simpa using this

    have h_theta_du : R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u), _⟩ =
                       (u : ℝ) * chooseδ hk R d hd := by
      have h_eq : unitMulti ⟨k, Nat.lt_succ_self k⟩ u = joinMulti (fun _ => 0) u := by
        ext i; simp [unitMulti, joinMulti]
        by_cases h : i.val = k <;> simp [h]
      rw [h_eq]
      have := hR'_extends (fun _ => 0) u
      simp [R.ident_eq_zero] at this
      exact this

    have hu_pos : (0 : ℝ) < (u : ℝ) := Nat.cast_pos.mpr hu

    calc separationStatistic R r u hu
        = R.Θ_grid ⟨mu F r, _⟩ / (u : ℝ) := rfl
      _ = R'.Θ_grid ⟨mu F' (joinMulti r 0), _⟩ / (u : ℝ) := by rw [← h_theta_r]
      _ = R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ u), _⟩ / (u : ℝ) := by rw [h_theta_eq]
      _ = ((u : ℝ) * chooseδ hk R d hd) / (u : ℝ) := by rw [h_theta_du]
      _ = chooseδ hk R d hd := by field_simp
      _ = v := by
          have h_v_eq : v = R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1), _⟩ := rfl
          rw [h_v_eq]
          have h_unit_1 : unitMulti ⟨k, Nat.lt_succ_self k⟩ 1 = joinMulti (fun _ => 0) 1 := by
            ext i; simp [unitMulti, joinMulti]
            by_cases h : i.val = k <;> simp [h]
          rw [h_unit_1]
          have := hR'_extends (fun _ => 0) 1
          simp [R.ident_eq_zero] at this
          exact this.symm

  -/

/-- **Path independence corollary**: The value assigned by any extension equals chooseδ.

This is the immediate consequence of ext_value_satisfies_base_spec + delta_unique.
Any representation R' that extends R by adding d must assign the value chooseδ(R, d) to d. -/
lemma ext_value_eq_chooseδ
    {k : ℕ} (hk : k ≥ 1) {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F) (H : GridComm F) (d : α) (hd : ident < d)
    {F' : AtomFamily α (k + 1)} (R' : MultiGridRep F')
    (hF'_old : ∀ i : Fin k, F'.atoms ⟨i.val, Nat.lt_succ_of_lt i.is_lt⟩ = F.atoms i)
    (hF'_new : F'.atoms ⟨k, Nat.lt_succ_self k⟩ = d)
    (hR'_extends : ∀ (r : Multi k) (t : ℕ),
        R'.Θ_grid ⟨mu F' (joinMulti r t), mu_mem_kGrid F' (joinMulti r t)⟩ =
        R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ + (t : ℝ) * chooseδ hk R d hd) :
    R'.Θ_grid ⟨mu F' (unitMulti ⟨k, Nat.lt_succ_self k⟩ 1), mu_mem_kGrid F' _⟩ =
    chooseδ hk R d hd := by
  have spec := ext_value_satisfies_base_spec hk R IH H d hd R' hF'_old hF'_new hR'_extends
  exact delta_unique hk R IH H d hd spec

/-! ### δ-Scaling: chooseδ(d²) = 2 * chooseδ(d)

When we compute δ for extending with d² = d⊕d, it equals twice the δ for extending with d.

**Key insight**: B-witnesses scale appropriately:
- If (r, u) is a B-witness for d (mu r = d^u), then (scaleMult 2 r, u) is a B-witness for d² (mu(2r) = (d^u)² = (d²)^u)
- The separation statistic doubles: θ(2r)/u = 2θ(r)/u = 2δ

For B = ∅ case:
- A-witnesses for d² correspond to A-witnesses for d at even levels
- By accuracy argument, sSup at even levels equals sSup at all levels
- Therefore δ_{d²} = 2 * δ_d
-/

/-- The positivity of iterate_op d 2 = d ⊕ d. -/
lemma iterate_op_two_pos (d : α) (hd : ident < d) : ident < iterate_op d 2 := by
  have h2 : ident < op d d := by
    calc ident = op ident ident := (op_ident_left ident).symm
      _ < op ident d := op_strictMono_right ident hd
      _ < op d d := op_strictMono_left d hd
  have h_iter2 : op d d = iterate_op d 2 := by
    -- `op (d^1) (d^1) = d^(1+1)` and `d^1 = d`.
    simpa [iterate_op_one] using (iterate_op_add d 1 1)
  simpa [h_iter2] using h2

/-- **δ-scaling lemma**: chooseδ for d² equals twice chooseδ for d.

This is the key to proving additivity in the x = y case:
- Θ(x ⊕ x) is defined using chooseδ(R₁, x⊕x)
- We need this to equal 2 * Θ(x) = 2 * chooseδ(R₁, x)
-/
lemma chooseδ_square_scaling {k : ℕ} {F : AtomFamily α k} (hk : k ≥ 1)
    (R : MultiGridRep F) (IH : GridBridge F) (H : GridComm F) (d : α) (hd : ident < d) :
    chooseδ hk R (iterate_op d 2) (iterate_op_two_pos d hd) = 2 * chooseδ hk R d hd := by
  set δ := chooseδ hk R d hd with hδ
  set d2 := iterate_op d 2

  -- The key is that both δ2 and 2*δ satisfy DeltaSpec for d2
  -- By uniqueness (DeltaSpec_unique), they must be equal

  -- We'll show 2*δ satisfies DeltaSpec for d2, hence 2*δ = δ2 by uniqueness
  suffices h : DeltaSpec F R d2 (iterate_op_two_pos d hd) (2 * δ) by
    have h2 := chooseδ_spec hk R IH H d2 (iterate_op_two_pos d hd)
    exact DeltaSpec_unique hk R IH H d2 (iterate_op_two_pos d hd) h2 h

  -- Get the DeltaSpec for δ
  have hδ_spec : DeltaSpec F R d hd δ := by
    simpa [hδ] using chooseδ_spec hk R IH H d hd

  -- We need to verify DeltaSpec for 2*δ:
  -- (1) All A-stats for d2 are ≤ 2δ
  -- (2) 2δ ≤ all C-stats for d2
  -- (3) All B-stats for d2 equal 2δ

  refine ⟨?hA, ?hC, ?hB⟩

  -- (1) A-bound: A-witnesses for d2 correspond to A-witnesses for d at even levels
  case hA =>
    intro r u hu hr_A
    -- r ∈ extensionSetA F d2 u means mu r < d2^u = d^{2u}
    simp only [extensionSetA, Set.mem_setOf_eq] at hr_A
    -- So (r, 2u) is an A-witness for d
    have hr_A_d : r ∈ extensionSetA F d (2 * u) := by
      simp only [extensionSetA, Set.mem_setOf_eq]
      have : iterate_op d2 u = iterate_op d (2 * u) := by
        simp only [d2]
        rw [iterate_op_mul]
      rw [← this]
      exact hr_A
    have h2u_pos : 0 < 2 * u := by omega
    -- A-stat for (r, u) in d2: θr / u
    -- A-stat for (r, 2u) in d: θr / (2u)
    -- Relation: stat(d2, r, u) = 2 * stat(d, r, 2u)
    have h_stat_rel : separationStatistic R r u hu = 2 * separationStatistic R r (2 * u) h2u_pos := by
      have hu_ne : (u : ℝ) ≠ 0 := by exact_mod_cast (Nat.ne_of_gt hu)
      have h2u_ne : ((2 * u : ℕ) : ℝ) ≠ 0 := by exact_mod_cast (Nat.ne_of_gt h2u_pos)
      simp [separationStatistic, Nat.cast_mul, div_eq_mul_inv]
      field_simp [hu_ne, h2u_ne]
    -- Apply δ's A-bound: A-stat(d, r, 2u) ≤ δ
    have h_bound := hδ_spec.1 r (2 * u) h2u_pos hr_A_d
    -- So A-stat(d2, r, u) = 2 * A-stat(d, r, 2u) ≤ 2δ
    rw [h_stat_rel]
    linarith

  -- (2) C-bound: C-witnesses for d2 correspond to C-witnesses for d at even levels
  case hC =>
    intro r u hu hr_C
    -- r ∈ extensionSetC F d2 u means mu r > d2^u = d^{2u}
    simp only [extensionSetC, Set.mem_setOf_eq] at hr_C
    -- So (r, 2u) is a C-witness for d
    have hr_C_d : r ∈ extensionSetC F d (2 * u) := by
      simp only [extensionSetC, Set.mem_setOf_eq]
      have : iterate_op d2 u = iterate_op d (2 * u) := by
        simp only [d2]
        rw [iterate_op_mul]
      rw [← this]
      exact hr_C
    have h2u_pos : 0 < 2 * u := by omega
    -- C-stat for (r, u) in d2: θr / u
    -- C-stat for (r, 2u) in d: θr / (2u)
    -- Relation: stat(d2, r, u) = 2 * stat(d, r, 2u)
    have h_stat_rel : separationStatistic R r u hu = 2 * separationStatistic R r (2 * u) h2u_pos := by
      have hu_ne : (u : ℝ) ≠ 0 := by exact_mod_cast (Nat.ne_of_gt hu)
      have h2u_ne : ((2 * u : ℕ) : ℝ) ≠ 0 := by exact_mod_cast (Nat.ne_of_gt h2u_pos)
      simp [separationStatistic, Nat.cast_mul, div_eq_mul_inv]
      field_simp [hu_ne, h2u_ne]
    -- Apply δ's C-bound: δ ≤ C-stat(d, r, 2u)
    have h_bound := hδ_spec.2.1 r (2 * u) h2u_pos hr_C_d
    -- So 2δ ≤ 2 * C-stat(d, r, 2u) = C-stat(d2, r, u)
    rw [h_stat_rel]
    linarith

  -- (3) B-bound: B-witnesses for d2 correspond to B-witnesses for d at even levels
  case hB =>
    intro r u hu hr_B
    -- r ∈ extensionSetB F d2 u means mu r = d2^u = d^{2u}
    simp only [extensionSetB, Set.mem_setOf_eq] at hr_B
    -- So (r, 2u) is a B-witness for d
    have hr_B_d : r ∈ extensionSetB F d (2 * u) := by
      simp only [extensionSetB, Set.mem_setOf_eq]
      have : iterate_op d2 u = iterate_op d (2 * u) := by
        simp only [d2]
        rw [iterate_op_mul]
      rw [← this]
      exact hr_B
    have h2u_pos : 0 < 2 * u := by omega
    -- B-stat for (r, u) in d2: θr / u
    -- B-stat for (r, 2u) in d: θr / (2u)
    -- Relation: B-stat(d2, r, u) = 2 * B-stat(d, r, 2u)
    have h_stat_rel : separationStatistic R r u hu = 2 * separationStatistic R r (2 * u) h2u_pos := by
      have hu_ne : (u : ℝ) ≠ 0 := by exact_mod_cast (Nat.ne_of_gt hu)
      have h2u_ne : ((2 * u : ℕ) : ℝ) ≠ 0 := by exact_mod_cast (Nat.ne_of_gt h2u_pos)
      simp [separationStatistic, Nat.cast_mul, div_eq_mul_inv]
      field_simp [hu_ne, h2u_ne]
    -- Apply δ's B-bound: B-stat(d, r, 2u) = δ
    have h_bound := hδ_spec.2.2 r (2 * u) h2u_pos hr_B_d
    -- So B-stat(d2, r, u) = 2 * B-stat(d, r, 2u) = 2δ
    calc
      separationStatistic R r u hu
          = 2 * separationStatistic R r (2 * u) h2u_pos := h_stat_rel
      _ = 2 * δ := by simpa [h_bound]


end Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA
