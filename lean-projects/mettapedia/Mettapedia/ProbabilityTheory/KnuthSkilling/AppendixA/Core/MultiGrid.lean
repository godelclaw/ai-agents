import Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA.Core.Prelude

set_option linter.unnecessarySimpa false
set_option linter.unusedSimpArgs false
set_option linter.unusedVariables false
set_option linter.unusedSectionVars false

namespace Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA

open Classical KnuthSkillingAlgebra

variable {α : Type*} [KnuthSkillingAlgebra α]

/-! ## Phase 2: A/B/C Partition for New Types

**Reference**: K&S Appendix A, Section A.3.2 "Separation"

The A/B/C partition is used to extend the representation from k types to k+1 types.
Given an existing grid of values μ(r,...,t) = ra + ... + tc for k atom types,
and a new type d, we partition old values relative to new targets:

- **Set A**: Old values that lie below new targets: μ(r,...,t) < μ(r₀,...,t₀; u)
- **Set B**: Old values that equal new targets: μ(r,...,t) = μ(r₀,...,t₀; u)
- **Set C**: Old values that lie above new targets: μ(r,...,t) > μ(r₀,...,t₀; u)

The repetition lemma shows these partitions are consistent across multiplicities.

**Case B non-empty**: The new type's value d is rationally related to existing values.
All members of B share a common statistic ((r-r₀)a+...+(t-t₀)c)/u = d.

**Case B empty**: The new type's value is determined as a limit δ via the Archimedean
property. The accuracy lemma shows δ can be found to arbitrary precision.
-/

/-- Multiset valuation: value of "r of a and s of b and ... " using iterate_op.

For the one-type case, this is just iterate_op a r.
For multi-type, we need to track multiple base elements. -/
def multiset_val (a : α) (r : ℕ) : α := iterate_op a r

/-- The lowerRatioSet-style approach from RepTheorem, localized here.

For element x, this is the set of ratios n/m where a^n ≤ x^m.
This captures the "relative position" of x in the grid generated by a. -/
def relativePosition (a x : α) : Set ℝ :=
  {r | ∃ n m : ℕ, 0 < m ∧ iterate_op a n ≤ iterate_op x m ∧ r = (n : ℝ) / m}

/-- A/B/C sets for comparing old grid values to new targets.

Given reference element a > ident and target x, partition grid elements:
- A: elements below x
- B: elements equal to x
- C: elements above x -/
def setA (a x : α) : Set ℕ := {n | iterate_op a n < x}
def setB (a x : α) : Set ℕ := {n | iterate_op a n = x}
def setC (a x : α) : Set ℕ := {n | x < iterate_op a n}

/-- The A/B/C sets partition ℕ -/
lemma abc_partition (a x : α) : ∀ n : ℕ, n ∈ setA a x ∨ n ∈ setB a x ∨ n ∈ setC a x := by
  intro n
  rcases lt_trichotomy (iterate_op a n) x with hlt | heq | hgt
  · left; exact hlt
  · right; left; exact heq
  · right; right; exact hgt

/-- The A/B/C sets are mutually exclusive -/
lemma abc_disjoint (a x : α) :
    (setA a x ∩ setB a x = ∅) ∧
    (setB a x ∩ setC a x = ∅) ∧
    (setA a x ∩ setC a x = ∅) := by
  constructor
  · ext n; simp only [setA, setB, Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_empty_iff_false,
                      iff_false, not_and]
    intro hlt heq; exact absurd heq (ne_of_lt hlt)
  constructor
  · ext n; simp only [setB, setC, Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_empty_iff_false,
                      iff_false, not_and]
    intro heq hgt; exact absurd heq (ne_of_gt hgt)
  · ext n; simp only [setA, setC, Set.mem_inter_iff, Set.mem_setOf_eq, Set.mem_empty_iff_false,
                      iff_false, not_and]
    intro hlt hgt
    have h : iterate_op a n < iterate_op a n := lt_trans hlt hgt
    exact absurd h (lt_irrefl _)

/-- If x is itself on the grid, setA is bounded above by that index. -/
lemma setA_bddAbove_of_setB_nonempty (a : α) (ha : ident < a) (x : α)
    (hB : ∃ n, iterate_op a n = x) :
    ∃ N, ∀ n ∈ setA a x, n ≤ N := by
  rcases hB with ⟨N, rfl⟩
  refine ⟨N, ?_⟩
  intro n hn
  have hlt : iterate_op a n < iterate_op a N := hn
  have hmono : Monotone (iterate_op a) := (grid_strictMono a ha).monotone
  have hnot : ¬ N ≤ n := by
    intro hle
    have hge : iterate_op a N ≤ iterate_op a n := hmono hle
    exact (not_lt_of_ge hge) hlt
  have hltNat : n < N := lt_of_not_ge hnot
  exact le_of_lt hltNat

/-- Each n belongs to exactly one of A, B, or C for a fixed target x. -/
lemma mem_A_or_B_or_C_unique (a x : α) (n : ℕ) :
    (n ∈ setA a x ∧ n ∉ setB a x ∧ n ∉ setC a x) ∨
    (n ∉ setA a x ∧ n ∈ setB a x ∧ n ∉ setC a x) ∨
    (n ∉ setA a x ∧ n ∉ setB a x ∧ n ∈ setC a x) := by
  classical
  rcases lt_trichotomy (iterate_op a n) x with hlt | heq | hgt
  · left
    refine ⟨hlt, ?_, ?_⟩
    · have hB : iterate_op a n ≠ x := ne_of_lt hlt
      simpa [setB] using hB
    · have hC : ¬ x < iterate_op a n := by
        intro hcontr
        exact (lt_asymm hlt hcontr).elim
      simpa [setC] using hC
  · right
    left
    refine ⟨?_, ?_, ?_⟩
    · simp [setA, heq]
    · simp [setB, heq]
    · simp [setC, heq]
  · right
    right
    refine ⟨?_, ?_, ?_⟩
    · have hA : ¬ iterate_op a n < x := by
        intro hcontr
        exact (lt_asymm hcontr hgt).elim
      simpa [setA] using hA
    · have hB : iterate_op a n ≠ x := ne_of_gt hgt
      simpa [setB] using hB
    · exact hgt

/-! ## Phase 3 (scaffolding): Multi-type grid skeleton

Following Appendix A, we package the “k atom types with multiplicities”
construction into a small reusable API. This is intentionally lean: it only
provides the data structures and a canonical fold-based evaluator `mu`.
The heavy separation and accuracy arguments will build on top of this. -/

open Finset

/-- A family of `k` atom types, each strictly above `ident`. -/
structure AtomFamily (α : Type*) [KnuthSkillingAlgebra α] (k : ℕ) where
  atoms : Fin k → α
  pos : ∀ i : Fin k, ident < atoms i

/-- Multiplicity vector for `k` atom types. -/
abbrev Multi (k : ℕ) := Fin k → ℕ

/-- Canonical valuation of a multiplicity vector: fold the appropriate iterates
    of each atom in the family using the Knuth–Skilling operation.

    Note: we use `foldl` to avoid any commutativity requirement on `op`. The
    order over `Finset.univ` for `Fin k` is deterministic. -/
noncomputable def mu {α : Type*} [KnuthSkillingAlgebra α] {k : ℕ}
    (F : AtomFamily α k) (r : Multi k) : α :=
  (List.finRange k).foldl (fun acc i => op acc (iterate_op (F.atoms i) (r i))) ident

/-- Convenience: the one-type atom family for a fixed `a`. -/
def singletonAtomFamily (a : α) (ha : ident < a) : AtomFamily α 1 :=
  { atoms := fun _ => a
    pos := by intro _; exact ha }

/-- For the singleton atom family, `mu` reduces to the usual one-type iterate. -/
lemma mu_singleton (a : α) (ha : ident < a) (n : ℕ) :
    mu (singletonAtomFamily (α:=α) a ha) (fun _ => n) = iterate_op a n := by
  -- `Fin 1` has exactly one element, so the foldl is a single step.
  classical
  simp [mu, singletonAtomFamily, List.finRange_succ, List.finRange_zero, op_ident_left]

/-- Update a single coordinate of a multiplicity vector. -/
def updateMulti {k : ℕ} (r : Multi k) (i : Fin k) (n : ℕ) : Multi k :=
  fun j => if j = i then n else r j

lemma updateMulti_self {k : ℕ} (r : Multi k) (i : Fin k) (n : ℕ) :
    updateMulti r i n i = n := by simp [updateMulti]

lemma updateMulti_other {k : ℕ} (r : Multi k) (i : Fin k) (n : ℕ) {j : Fin k} (hj : j ≠ i) :
    updateMulti r i n j = r j := by simp [updateMulti, hj]

/-- `mu` is coordinatewise monotone in the multiplicity vector. -/
lemma mu_mono (F : AtomFamily α k) {r s : Multi k} (h : ∀ i, r i ≤ s i) :
    mu F r ≤ mu F s := by
  classical
  let l : List (Fin k) := List.finRange k
  -- Generalize to arbitrary starting accumulators to induct over the list.
  have aux :
      ∀ (l : List (Fin k)) (acc₁ acc₂ : α), acc₁ ≤ acc₂ →
        List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (r i))) acc₁ l ≤
        List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (s i))) acc₂ l := by
    intro l
    induction l with
    | nil =>
      intro acc₁ acc₂ hacc
      simpa [List.foldl] using hacc
    | cons i t ih =>
      intro acc₁ acc₂ hacc
      have h_iter_le : iterate_op (F.atoms i) (r i) ≤ iterate_op (F.atoms i) (s i) :=
        (grid_strictMono (F.atoms i) (F.pos i)).monotone (h i)
      have h_acc_step :
          op acc₁ (iterate_op (F.atoms i) (r i)) ≤
          op acc₂ (iterate_op (F.atoms i) (s i)) := by
        have h_left := op_mono_left (iterate_op (F.atoms i) (r i)) hacc
        have h_right := op_mono_right acc₂ h_iter_le
        exact le_trans h_left h_right
      simpa [List.foldl, List.foldl_cons] using ih _ _ h_acc_step
  have h_base := aux l ident ident (le_rfl : (ident : α) ≤ ident)
  simpa [mu, l] using h_base

/-- Monotonicity in a single coordinate, keeping others fixed. -/
lemma mu_mono_coord (F : AtomFamily α k) (i : Fin k) (r : Multi k) :
    Monotone (fun n => mu F (updateMulti r i n)) := by
  intro m n hmn
  refine mu_mono (F:=F) (r:=updateMulti r i m) (s:=updateMulti r i n) ?_
  intro j
  by_cases hj : j = i
  · subst hj; simpa [updateMulti] using hmn
  · simp [updateMulti, hj]

/-- Folding with fixed right arguments is strictly monotone in the accumulator. -/
lemma fold_strictMono_left (F : AtomFamily α k) (vals : Multi k)
    (l : List (Fin k)) (hnd : l.Nodup) :
    StrictMono (fun acc : α =>
      List.foldl (fun a j => op a (iterate_op (F.atoms j) (vals j))) acc l) := by
  classical
  induction l with
  | nil =>
    -- identity function is strictly monotone
    simpa [List.foldl] using (strictMono_id : StrictMono (fun x : α => x))
  | cons j t ih =>
    have hstep : StrictMono (fun acc : α => op acc (iterate_op (F.atoms j) (vals j))) :=
      op_strictMono_left _
    have htail : StrictMono (fun acc : α =>
      List.foldl (fun a j => op a (iterate_op (F.atoms j) (vals j))) acc t) :=
      ih (List.nodup_cons.mp hnd).2
    -- composition preserves strictness
    exact htail.comp hstep

/-- Foldl congr: if functions agree on list elements, foldls are equal. -/
lemma foldl_congr_on_list {β : Type*} (f g : α → β → α) (init : α) (l : List β)
    (h : ∀ x ∈ l, ∀ acc, f acc x = g acc x) :
    List.foldl f init l = List.foldl g init l := by
  induction l generalizing init with
  | nil => rfl
  | cons x t ih =>
    simp only [List.foldl_cons]
    have hx_mem : x ∈ x :: t := List.mem_cons_self
    rw [h x hx_mem init]
    have h_tail : ∀ y ∈ t, ∀ acc, f acc y = g acc y := fun y hy acc =>
      h y (List.mem_cons_of_mem x hy) acc
    exact ih (g init x) h_tail

/-- μ of the all-zero multiplicity vector evaluates to `ident`. -/
lemma mu_zero {k : ℕ} (F : AtomFamily α k) :
    mu F (fun _ => 0) = ident := by
  classical
  have hfold :
      ∀ l : List (Fin k),
        List.foldl (fun acc j => op acc (iterate_op (F.atoms j) 0)) ident l = ident := by
    intro l
    induction l with
    | nil => simp
    | cons j tl ih =>
        simp [iterate_op_zero, op_ident_right, ih]
  simpa [mu] using hfold (List.finRange k)

/-- Unit vector: n in position i, 0 elsewhere. -/
def unitMulti {k : ℕ} (i : Fin k) (n : ℕ) : Multi k :=
  fun j => if j = i then n else 0

/-- Helper: fold over indices with unitMulti evaluates to the target iterate.
    This tracks the accumulator through the fold.

    For j ∈ l with j ≠ i: contributes iterate_op (F.atoms j) 0 = ident, so acc unchanged.
    For j = i: contributes iterate_op (F.atoms i) n.

    The result depends on whether i is in the list:
    - If i ∈ l: result = op acc (iterate_op (F.atoms i) n)
    - If i ∉ l: result = acc (all contributions are ident)
-/
private lemma foldl_unitMulti_aux {k : ℕ} (F : AtomFamily α k) (i : Fin k) (n : ℕ)
    (l : List (Fin k)) (hnd : l.Nodup) (acc : α) :
    List.foldl (fun a j => op a (iterate_op (F.atoms j) (unitMulti i n j))) acc l =
    if i ∈ l then op acc (iterate_op (F.atoms i) n) else acc := by
  induction l generalizing acc with
  | nil =>
    simp only [List.foldl_nil, List.not_mem_nil, ↓reduceIte]
  | cons hd tl ih =>
    simp only [List.foldl_cons, List.mem_cons]
    by_cases hi : hd = i
    · -- hd = i: this is the special index
      -- unitMulti i n hd = n (since hd = i)
      have h_val : unitMulti i n hd = n := by simp only [unitMulti, hi, ↓reduceIte]
      simp only [h_val]
      -- Since l is nodup and hd = i, i ∉ tl
      have hi_not_in_tl : i ∉ tl := by
        intro hmem
        have hnodup := (List.nodup_cons.mp hnd).1
        rw [hi] at hnodup
        exact hnodup hmem
      -- For the tail, since i ∉ tl, the fold just returns the accumulator
      rw [ih (List.nodup_cons.mp hnd).2]
      simp only [hi_not_in_tl, ↓reduceIte, hi, true_or]
    · -- hd ≠ i: this index contributes ident
      have hne : hd ≠ i := hi
      have h_val : unitMulti i n hd = 0 := by
        simp only [unitMulti, hne, ↓reduceIte]
      rw [h_val, iterate_op_zero, op_ident_right]
      rw [ih (List.nodup_cons.mp hnd).2]
      -- Goal: if i ∈ tl then op acc ... else acc = if hd = i ∨ i ∈ tl then op acc ... else acc
      -- Since hd ≠ i, the conditions are equivalent
      -- Note: List.mem_cons produces `i = hd ∨ i ∈ tl`, not `hd = i ∨ ...`
      have hne_symm : i ≠ hd := Ne.symm hne
      by_cases h_in_tl : i ∈ tl
      · -- i ∈ tl: both conditions are true
        simp only [h_in_tl, ↓reduceIte, Or.inr h_in_tl, hne_symm, false_or]
      · -- i ∉ tl: since i ≠ hd, i = hd ∨ i ∈ tl is false
        simp only [h_in_tl, ↓reduceIte, or_false]
        -- Goal: acc = if i = hd then op acc ... else acc
        rw [if_neg hne_symm]

/-- μ of a unit vector equals the corresponding iterate.
    This is key for reducing multi-type to single-type arguments.

    **Proof idea**: The fold processes indices in order. At index i, we get F.atoms i ^ n.
    At all other indices j ≠ i, we get F.atoms j ^ 0 = ident, which disappears via op_ident_right.
    So the result is ident ⊕ (F.atoms i ^ n) = F.atoms i ^ n.
-/
lemma mu_unitMulti {k : ℕ} (F : AtomFamily α k) (i : Fin k) (n : ℕ) :
    mu F (unitMulti i n) = iterate_op (F.atoms i) n := by
  unfold mu
  have hi_in : i ∈ List.finRange k := by simp
  have hnd : (List.finRange k).Nodup := List.nodup_finRange _
  rw [foldl_unitMulti_aux F i n (List.finRange k) hnd ident, if_pos hi_in, op_ident_left]

/-- Helper: strict inequality of folds when one input differs at a specific index.
    The fold diverges at that index, and strict monotonicity of subsequent steps preserves it.

    This version uses an explicit starting accumulator to handle the inductive case. -/
lemma foldl_lt_of_diff_at_index_aux (F : AtomFamily α k) (m n : ℕ) (r : Multi k) (idx : Fin k)
    (hmn : m < n) (l : List (Fin k)) (hl : idx ∈ l) (hnd : l.Nodup) (init : α) :
    List.foldl (fun acc j => op acc (iterate_op (F.atoms j) (updateMulti r idx m j))) init l <
    List.foldl (fun acc j => op acc (iterate_op (F.atoms j) (updateMulti r idx n j))) init l := by
  classical
  induction l generalizing init with
  | nil => exact absurd hl List.not_mem_nil
  | cons hd tl ih =>
    simp only [List.foldl_cons]
    by_cases hji : hd = idx
    · -- hd = idx: the divergence happens here
      -- Since idx ∉ tl (from nodup), updateMulti agrees on all elements of tl
      have hidx_not_in_tl : idx ∉ tl := by
        rw [← hji]; exact (List.nodup_cons.mp hnd).1
      -- Simplify the starting accumulators
      have h_acc_m : updateMulti r idx m hd = m := by rw [hji]; exact updateMulti_self r idx m
      have h_acc_n : updateMulti r idx n hd = n := by rw [hji]; exact updateMulti_self r idx n
      -- The strict inequality at this step
      have h_iter_lt : iterate_op (F.atoms hd) m < iterate_op (F.atoms hd) n := by
        rw [hji]; exact grid_strictMono (F.atoms idx) (F.pos idx) hmn
      have h_step_lt : op init (iterate_op (F.atoms hd) m) < op init (iterate_op (F.atoms hd) n) :=
        op_strictMono_right init h_iter_lt
      -- Rewrite the accumulators
      rw [h_acc_m, h_acc_n]
      -- For the tail, updateMulti r idx m and updateMulti r idx n agree on all elements
      -- since idx ∉ tl (and hd = idx implies hd ∉ tl)
      have h_tail_eq_m : ∀ acc',
          List.foldl (fun a j => op a (iterate_op (F.atoms j) (updateMulti r idx m j))) acc' tl =
          List.foldl (fun a j => op a (iterate_op (F.atoms j) (r j))) acc' tl := fun acc' => by
        apply foldl_congr_on_list
        intro j hj _acc
        have hjne : j ≠ idx := by
          intro heq
          rw [← hji] at heq
          have : hd ∈ tl := heq ▸ hj
          exact (List.nodup_cons.mp hnd).1 this
        simp [updateMulti, hjne]
      have h_tail_eq_n : ∀ acc',
          List.foldl (fun a j => op a (iterate_op (F.atoms j) (updateMulti r idx n j))) acc' tl =
          List.foldl (fun a j => op a (iterate_op (F.atoms j) (r j))) acc' tl := fun acc' => by
        apply foldl_congr_on_list
        intro j hj _acc
        have hjne : j ≠ idx := by
          intro heq
          rw [← hji] at heq
          have : hd ∈ tl := heq ▸ hj
          exact (List.nodup_cons.mp hnd).1 this
        simp [updateMulti, hjne]
      rw [h_tail_eq_m, h_tail_eq_n]
      -- Now both folds use the same function (r, not updateMulti), and starting acc differs
      have hnd' : tl.Nodup := (List.nodup_cons.mp hnd).2
      exact fold_strictMono_left F r tl hnd' h_step_lt
    · -- hd ≠ idx: both sides make the same step at hd, recurse on tail
      have h_same : updateMulti r idx m hd = updateMulti r idx n hd := by simp [updateMulti, hji]
      rw [h_same]
      have hidx_in_tl : idx ∈ tl := by
        cases hl with
        | head => exact absurd rfl hji
        | tail _ ht => exact ht
      have hnd' : tl.Nodup := (List.nodup_cons.mp hnd).2
      exact ih hidx_in_tl hnd' _

/-- Strict inequality of folds when one input differs at a specific index.
    Specialization to starting from `ident`. -/
lemma foldl_lt_of_diff_at_index (F : AtomFamily α k) (m n : ℕ) (r : Multi k) (idx : Fin k)
    (hmn : m < n) (l : List (Fin k)) (hl : idx ∈ l) (hnd : l.Nodup) :
    List.foldl (fun acc j => op acc (iterate_op (F.atoms j) (updateMulti r idx m j))) ident l <
    List.foldl (fun acc j => op acc (iterate_op (F.atoms j) (updateMulti r idx n j))) ident l :=
  foldl_lt_of_diff_at_index_aux F m n r idx hmn l hl hnd ident

/-- Strict monotonicity in a single coordinate, keeping others fixed.

When m < n, the vectors `updateMulti r i m` and `updateMulti r i n` differ only at coordinate i.
The fold `mu` processes all coordinates including i, where it computes strictly different values
(since `iterate_op` is strictly monotone). The subsequent fold steps preserve this strict
inequality via `op_strictMono_left`. -/
lemma mu_strictMono_coord (F : AtomFamily α k) (i : Fin k) (r : Multi k) :
    StrictMono (fun n => mu F (updateMulti r i n)) := by
  intro m n hmn
  unfold mu
  have hi_mem : i ∈ List.finRange k := by simp
  have hnd : (List.finRange k).Nodup := List.nodup_finRange _
  exact foldl_lt_of_diff_at_index F m n r i hmn _ hi_mem hnd

/-! ## Multi-type grid and representation scaffolding -/

/-- Grid generated by an atom family: values reachable as μ(F, r). -/
def kGrid {k : ℕ} (F : AtomFamily α k) : Set α := {x | ∃ r : Multi k, x = mu F r}

/-- Every μ-value lies on the k-grid. -/
lemma mu_mem_kGrid {k : ℕ} (F : AtomFamily α k) (r : Multi k) : mu F r ∈ kGrid F :=
  ⟨r, rfl⟩

/-- `ident` is always on the k-grid (take the zero multiplicity vector). -/
lemma ident_mem_kGrid {k : ℕ} (F : AtomFamily α k) : ident ∈ kGrid F := by
  have hmem : mu F (fun _ => 0) ∈ kGrid F := mu_mem_kGrid (F:=F) (r:=fun _ => 0)
  simpa [mu_zero (F:=F)] using hmem

/-- Representation data restricted to the μ-grid of an atom family. -/
structure MultiGridRep {k : ℕ} (F : AtomFamily α k) where
  /-- Representation on grid points μ(F, r). -/
  Θ_grid : {x // x ∈ kGrid F} → ℝ
  /-- Strict monotonicity on the grid. -/
  strictMono : StrictMono Θ_grid
  /-- Additivity along the grid. -/
  add : ∀ (r s : Multi k),
    Θ_grid ⟨mu F (fun i => r i + s i), mu_mem_kGrid (F:=F) (r:=fun i => r i + s i)⟩ =
    Θ_grid ⟨mu F r, mu_mem_kGrid (F:=F) r⟩ +
    Θ_grid ⟨mu F s, mu_mem_kGrid (F:=F) s⟩
  /-- Normalization: Θ(ident) = 0. -/
  ident_eq_zero :
    Θ_grid ⟨ident, ident_mem_kGrid (F:=F)⟩ = 0

/-- Commutativity on the μ-grid generated by an atom family F.

This is the **key inductive hypothesis** in the K&S Appendix A proof structure:
- Base (k=1): Single atom type, commutativity trivial (op a^m ⊕ a^n = a^{m+n} = a^n ⊕ a^m)
- Step (k→k+1): ASSUME k-grid is commutative, prove (k+1)-grid has representation,
                 then DERIVE (k+1)-grid commutativity from Θ' additivity + injectivity

Once GridComm F is established, we can prove the crucial bridge lemma:
  mu F (scaleMult n r) = iterate_op (mu F r) n
which enables all the separation/shift/strict-mono arguments. -/
structure GridComm {k : ℕ} (F : AtomFamily α k) : Prop where
  /-- Grid elements commute under op. -/
  comm : ∀ r s : Multi k, op (mu F r) (mu F s) = op (mu F s) (mu F r)

/-- For k=1 (single atom), the grid is trivially commutative.
The grid is {a^n : n ∈ ℕ}, and a^m ⊕ a^n = a^{m+n} = a^n ⊕ a^m. -/
lemma gridComm_of_k_eq_one {F : AtomFamily α 1} : GridComm F := ⟨by
  intro r s
  -- For k=1, mu F r = a^{r 0} for the single atom a = F.atoms 0
  -- Use calc to prove commutativity step by step
  unfold mu
  simp only [List.finRange_succ, List.finRange_zero, List.foldl_cons, List.foldl_nil, op_ident_left]
  -- Goal: iterate_op (F.atoms i) (r i) ⊕ iterate_op (F.atoms j) (s j) = iterate_op (F.atoms j) (s j) ⊕ iterate_op (F.atoms i) (r i)
  -- Both i and j are the unique element of Fin 1, so they equal each other
  let i₀ : Fin 1 := ⟨0, by decide⟩
  have hr_def : r = fun _ => r i₀ := by ext i; exact congrArg r (Fin.eq_zero i)
  have hs_def : s = fun _ => s i₀ := by ext i; exact congrArg s (Fin.eq_zero i)
  -- Rewrite using these
  calc op (iterate_op (F.atoms i₀) (r i₀)) (iterate_op (F.atoms i₀) (s i₀))
      = iterate_op (F.atoms i₀) (r i₀ + s i₀) := by rw [← iterate_op_add]
    _ = iterate_op (F.atoms i₀) (s i₀ + r i₀) := by rw [Nat.add_comm]
    _ = op (iterate_op (F.atoms i₀) (s i₀)) (iterate_op (F.atoms i₀) (r i₀)) := by rw [iterate_op_add]
⟩

/-!
### TODO: Thread `GridComm`/`GridBridge` through extensions

The global Θ-construction later in this file builds larger atom families by repeatedly
calling `extend_grid_rep_with_atom`.  In the Knuth–Skilling induction, one should also
transport `GridComm` (and hence `GridBridge`) across the k→k+1 step using additivity +
injectivity of the representation.

We intentionally do *not* expose a helper lemma like:

`gridComm_of_k_ge_one (hk : k ≥ 1) : GridComm F`

because it would be nonconstructive at this stage: for k>1, commutativity on the μ-grid
is not available without completing the k→k+1 extension step and then deriving it from
Θ′ additivity + injectivity (as K&S do).
-/

/-! ## Multi-type A/B/C partition using `mu` -/

/-- Set A for multi-type grid: multiplicities whose value is below the target x. -/
def multiSetA (F : AtomFamily α k) (x : α) : Set (Multi k) := {r | mu F r < x}

/-- Set B for multi-type grid: multiplicities whose value equals the target x. -/
def multiSetB (F : AtomFamily α k) (x : α) : Set (Multi k) := {r | mu F r = x}

/-- Set C for multi-type grid: multiplicities whose value is above the target x. -/
def multiSetC (F : AtomFamily α k) (x : α) : Set (Multi k) := {r | x < mu F r}

/-- The multi-type A/B/C sets partition the multiplicity grid. -/
lemma multi_abc_partition (F : AtomFamily α k) (x : α) (r : Multi k) :
    r ∈ multiSetA F x ∨ r ∈ multiSetB F x ∨ r ∈ multiSetC F x := by
  unfold multiSetA multiSetB multiSetC
  rcases lt_trichotomy (mu F r) x with hlt | heq | hgt
  · exact Or.inl hlt
  · exact Or.inr (Or.inl heq)
  · exact Or.inr (Or.inr hgt)

/-- The multi-type A/B/C sets are pairwise disjoint. -/
lemma multi_abc_disjoint (F : AtomFamily α k) (x : α) :
    (multiSetA F x ∩ multiSetB F x = ∅) ∧
    (multiSetB F x ∩ multiSetC F x = ∅) ∧
    (multiSetA F x ∩ multiSetC F x = ∅) := by
  constructor
  · ext r; constructor
    · intro h; rcases h with ⟨hA, hB⟩
      have hlt' : mu F r < mu F r := by
        have hlt : mu F r < x := by simpa [multiSetA] using hA
        have heq : mu F r = x := by simpa [multiSetB] using hB
        simpa [heq] using hlt
      exact (lt_irrefl _ hlt').elim
    · intro h; cases h
  constructor
  · ext r; constructor
    · intro h; rcases h with ⟨hB, hC⟩
      have hlt' : mu F r < mu F r := by
        have heq : mu F r = x := by simpa [multiSetB] using hB
        have hgt : x < mu F r := by simpa [multiSetC] using hC
        simpa [heq] using hgt
      exact (lt_irrefl _ hlt').elim
    · intro h; cases h
  · ext r; constructor
    · intro h; rcases h with ⟨hA, hC⟩
      have hlt : mu F r < mu F r := by
        have hltA : mu F r < x := by simpa [multiSetA] using hA
        have hgtC : x < mu F r := by simpa [multiSetC] using hC
        exact lt_trans hltA hgtC
      exact (lt_irrefl _ hlt).elim
    · intro h; cases h

/-- Each multiplicity vector belongs to exactly one of A, B, or C. -/
lemma multi_mem_A_or_B_or_C_unique (F : AtomFamily α k) (x : α) (r : Multi k) :
    (r ∈ multiSetA F x ∧ r ∉ multiSetB F x ∧ r ∉ multiSetC F x) ∨
    (r ∉ multiSetA F x ∧ r ∈ multiSetB F x ∧ r ∉ multiSetC F x) ∨
    (r ∉ multiSetA F x ∧ r ∉ multiSetB F x ∧ r ∈ multiSetC F x) := by
  classical
  rcases multi_abc_partition (F:=F) x r with hA | hB | hC
  · left
    refine ⟨hA, ?_, ?_⟩
    · intro hB'
      have := multi_abc_disjoint (F:=F) x
      have hABempty := this.1
      have : r ∈ (multiSetA F x ∩ multiSetB F x) := ⟨hA, hB'⟩
      have : r ∈ (∅ : Set (Multi k)) := by simpa [hABempty] using this
      simpa using this
    · intro hC'
      have := multi_abc_disjoint (F:=F) x
      have hACempty := this.2.2
      have : r ∈ (multiSetA F x ∩ multiSetC F x) := ⟨hA, hC'⟩
      have : r ∈ (∅ : Set (Multi k)) := by simpa [hACempty] using this
      simpa using this
  · right; left
    refine ⟨?_, hB, ?_⟩
    · intro hA
      have := multi_abc_disjoint (F:=F) x
      have hABempty := this.1
      have : r ∈ (multiSetA F x ∩ multiSetB F x) := ⟨hA, hB⟩
      have : r ∈ (∅ : Set (Multi k)) := by simpa [hABempty] using this
      simpa using this
    · intro hC'
      have := multi_abc_disjoint (F:=F) x
      have hBCempty := this.2.1
      have : r ∈ (multiSetB F x ∩ multiSetC F x) := ⟨hB, hC'⟩
      have : r ∈ (∅ : Set (Multi k)) := by simpa [hBCempty] using this
      simpa using this
  · right; right
    refine ⟨?_, ?_, hC⟩
    · intro hA
      have := multi_abc_disjoint (F:=F) x
      have hACempty := this.2.2
      have : r ∈ (multiSetA F x ∩ multiSetC F x) := ⟨hA, hC⟩
      have : r ∈ (∅ : Set (Multi k)) := by simpa [hACempty] using this
      simpa using this
    · intro hB
      have := multi_abc_disjoint (F:=F) x
      have hBCempty := this.2.1
      have : r ∈ (multiSetB F x ∩ multiSetC F x) := ⟨hB, hC⟩
      have : r ∈ (∅ : Set (Multi k)) := by simpa [hBCempty] using this
      simpa using this

/-! ### k = 1 specialization

Relate the k-type grid back to the one-type grid to reuse the base case.
-/

/-- Evaluate μ for the singleton atom family directly as an iterate. -/
lemma mu_singleton_eval (a : α) (ha : ident < a) (r : Multi 1) :
    mu (singletonAtomFamily (α:=α) a ha) r = iterate_op a (r ⟨0, by decide⟩) := by
  classical
  have hfun : r = fun _ : Fin 1 => r ⟨0, by decide⟩ := by
    funext i
    fin_cases i
    rfl
  -- Rewrite r as the unique constant function on Fin 1.
  conv_lhs => rw [hfun]
  simp [mu_singleton]

/-- For a singleton atom family, the k-grid coincides with the one-type grid. -/
lemma kGrid_singleton_eq_grid (a : α) (ha : ident < a) :
    kGrid (singletonAtomFamily (α:=α) a ha) = grid a := by
  ext x
  constructor
  · rintro ⟨r, rfl⟩
    classical
    let n : ℕ := r ⟨0, by decide⟩
    have hr : mu (singletonAtomFamily (α:=α) a ha) r = iterate_op a n :=
      mu_singleton_eval (a:=a) (ha:=ha) r
    exact ⟨n, hr⟩
  · rintro ⟨n, rfl⟩
    refine ⟨(fun _ : Fin 1 => n), ?_⟩
    simp [mu_singleton]

/-- Transport a one-type grid representation to the singleton atom family. -/
noncomputable def OneTypeGridRep.toMulti (a : α) (ha : ident < a) (R : OneTypeGridRep a ha) :
    MultiGridRep (singletonAtomFamily (α:=α) a ha) := by
  classical
  let F : AtomFamily α 1 := singletonAtomFamily (α:=α) a ha
  have hset : kGrid F = grid a := kGrid_singleton_eq_grid (a:=a) (ha:=ha)
  let toGrid : {x // x ∈ kGrid F} → {x // x ∈ grid a} := fun x =>
    ⟨x.val, by simpa [hset] using x.property⟩
  refine
    { Θ_grid := fun x => R.Θ_grid (toGrid x)
      , strictMono := ?_
      , add := ?_
      , ident_eq_zero := ?_ }
  · intro x y hxy
    have hxy' : toGrid x < toGrid y := hxy
    simpa using (R.strictMono hxy')
  · intro r s
    classical
    let m : ℕ := r ⟨0, by decide⟩
    let n : ℕ := s ⟨0, by decide⟩
    have hr : mu F r = iterate_op a m := mu_singleton_eval (a:=a) (ha:=ha) r
    have hs : mu F s = iterate_op a n := mu_singleton_eval (a:=a) (ha:=ha) s
    have hsum : mu F (fun i : Fin 1 => r i + s i) = iterate_op a (m + n) := by
      have hdefault : (fun i : Fin 1 => r i + s i) ⟨0, by decide⟩ = m + n := by
        simp [m, n]
      have h_eval := mu_singleton_eval (a:=a) (ha:=ha) (r:=fun i : Fin 1 => r i + s i)
      simpa [hdefault] using h_eval
    have hmem_r : mu F r ∈ kGrid F := mu_mem_kGrid (F:=F) r
    have hmem_s : mu F s ∈ kGrid F := mu_mem_kGrid (F:=F) s
    have hmem_sum : mu F (fun i : Fin 1 => r i + s i) ∈ kGrid F :=
      mu_mem_kGrid (F:=F) (r:=fun i : Fin 1 => r i + s i)
    calc
      (fun x => R.Θ_grid (toGrid x))
          ⟨mu F (fun i : Fin 1 => r i + s i), hmem_sum⟩
          = R.Θ_grid ⟨iterate_op a (m + n), by
              have : mu F (fun i : Fin 1 => r i + s i) ∈ grid a := by
                simpa [hset] using hmem_sum
              simpa [hsum] using this⟩ := by
                simp [toGrid, hset, hsum]
      _ = R.Θ_grid ⟨iterate_op a m, by
              have : mu F r ∈ grid a := by simpa [hset] using hmem_r
              simpa [hr] using this⟩ +
          R.Θ_grid ⟨iterate_op a n, by
              have : mu F s ∈ grid a := by simpa [hset] using hmem_s
              simpa [hs] using this⟩ := R.add m n
      _ = (fun x => R.Θ_grid (toGrid x)) ⟨mu F r, hmem_r⟩ +
          (fun x => R.Θ_grid (toGrid x)) ⟨mu F s, hmem_s⟩ := by
            simp [toGrid, hset, hr, hs]
  · -- ident corresponds to the zero multiplicity vector on the k-grid
    simp [toGrid, hset, ident_mem_kGrid, R.ident_eq_zero]

/-! ## Phase 3: Separation Statistic and Case B Non-Empty

**Reference**: K&S Appendix A, Section A.3.3

The separation statistic σ(r, u) = Θ(μ(F, r)) / u captures the "candidate value"
for a new atom d based on witness r ∈ B(u) (meaning μ(F, r) = d^u).

**Key theorem**: All B-witnesses give the same statistic value, so Θ(d) is well-defined.

The proof uses:
1. Additivity of Θ on the k-grid: Θ(μ(F, n·r)) = n · Θ(μ(F, r))
2. Order structure to show: if μ(F, r) = d^u, then μ(F, n·r) = d^{nu}
3. Consistency: witnesses r ∈ B(u) and r' ∈ B(u') give same Θ(d)
-/

/-- Scale a multiplicity vector by a natural number. -/
def scaleMult {k : ℕ} (n : ℕ) (r : Multi k) : Multi k := fun i => n * r i

@[simp]
lemma scaleMult_one {k : ℕ} (r : Multi k) : scaleMult 1 r = r := by
  ext i; simp [scaleMult]

@[simp]
lemma scaleMult_zero {k : ℕ} (r : Multi k) : scaleMult 0 r = fun _ => 0 := by
  ext i; simp [scaleMult]

lemma scaleMult_add {k : ℕ} (m n : ℕ) (r : Multi k) :
    scaleMult (m + n) r = fun i => scaleMult m r i + scaleMult n r i := by
  ext i; simp [scaleMult, Nat.add_mul]

lemma scaleMult_succ {k : ℕ} (n : ℕ) (r : Multi k) :
    scaleMult (n + 1) r = fun i => scaleMult n r i + r i := by
  ext i; simp [scaleMult, Nat.add_mul, Nat.add_comm]

/-- For singleton atom family (k=1), scaling multiplicities equals iterating.
    This is the key lemma that doesn't require commutativity for k=1. -/
lemma mu_scaleMult_eq_iterate_singleton (a : α) (ha : ident < a) (r : Multi 1) (n : ℕ) :
    mu (singletonAtomFamily (α := α) a ha) (scaleMult n r) =
    iterate_op (mu (singletonAtomFamily (α := α) a ha) r) n := by
  classical
  let F := singletonAtomFamily (α := α) a ha
  -- r is essentially a single natural number: r 0 (using 0 : Fin 1)
  -- μ(F, r) = a^{r 0}
  have hr : mu F r = iterate_op a (r 0) := mu_singleton_eval a ha r
  -- μ(F, n·r) = a^{n * r 0}
  have hscale_full : scaleMult n r = fun _ : Fin 1 => n * r 0 := by
    funext i
    simp only [scaleMult, Fin.eq_zero i]
  have hnr : mu F (scaleMult n r) = iterate_op a (n * r 0) := by
    rw [hscale_full]
    exact mu_singleton a ha (n * r 0)
  -- (μ(F, r))^n = (a^{r 0})^n = a^{(r 0) * n} = a^{n * r 0}
  have hiter : iterate_op (mu F r) n = iterate_op a (n * r 0) := by
    rw [hr]
    rw [iterate_op_mul]
    congr 1
    ring
  rw [hnr, hiter]

/-- Scaling a unit vector hits the expected coordinate. -/
lemma scaleMult_unitMulti_one {k : ℕ} (i : Fin k) (m : ℕ) :
    scaleMult m (unitMulti i 1) = unitMulti i m := by
  ext j
  by_cases hj : j = i
  · subst hj
    simp [scaleMult, unitMulti]
  · simp [scaleMult, unitMulti, hj]

/-- Θ is additive under scaling: Θ(μ(F, n·r)) = n · Θ(μ(F, r)).
    This follows from MultiGridRep.add by induction. -/
lemma Theta_scaleMult {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (r : Multi k) (n : ℕ) :
    R.Θ_grid ⟨mu F (scaleMult n r), mu_mem_kGrid F (scaleMult n r)⟩ =
    n * R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ := by
  induction n with
  | zero =>
    simp only [scaleMult_zero, Nat.zero_eq, Nat.cast_zero, zero_mul]
    have h0 : mu F (fun _ => 0) = ident := mu_zero (F := F)
    have hmem : mu F (fun _ => 0) ∈ kGrid F := mu_mem_kGrid F _
    calc R.Θ_grid ⟨mu F (fun _ => 0), hmem⟩
        = R.Θ_grid ⟨ident, by rw [← h0]; exact hmem⟩ := by
            simp only [h0]
      _ = 0 := R.ident_eq_zero
  | succ n ih =>
    have h_sum : scaleMult (n + 1) r = fun i => scaleMult n r i + r i := scaleMult_succ n r
    have hmem_sum := mu_mem_kGrid F (scaleMult (n + 1) r)
    have hmem_n := mu_mem_kGrid F (scaleMult n r)
    have hmem_r := mu_mem_kGrid F r
    -- The key fact is that mu F (scaleMult (n + 1) r) = mu F (fun i => scaleMult n r i + r i)
    have h_mu_eq : mu F (scaleMult (n + 1) r) = mu F (fun i => scaleMult n r i + r i) := by
      congr 1
    -- Use R.add to split into sum
    have hadd := R.add (scaleMult n r) r
    -- Show mu F (scaleMult (n + 1) r) = mu F (scaleMult n r) + mu F r via hadd
    calc R.Θ_grid ⟨mu F (scaleMult (n + 1) r), hmem_sum⟩
        = R.Θ_grid ⟨mu F (fun i => scaleMult n r i + r i), mu_mem_kGrid F _⟩ := by
            simp only [h_mu_eq]
      _ = R.Θ_grid ⟨mu F (scaleMult n r), hmem_n⟩ + R.Θ_grid ⟨mu F r, hmem_r⟩ := by
            convert hadd using 2
      _ = n * R.Θ_grid ⟨mu F r, hmem_r⟩ + R.Θ_grid ⟨mu F r, hmem_r⟩ := by rw [ih]
      _ = (n + 1 : ℕ) * R.Θ_grid ⟨mu F r, hmem_r⟩ := by
            simp only [Nat.cast_add, Nat.cast_one]; ring

/-- Θ on a unit vector scales linearly with the multiplicity. -/
lemma Theta_unitMulti {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (i : Fin k) (n : ℕ) :
    R.Θ_grid ⟨mu F (unitMulti i n), mu_mem_kGrid F (unitMulti i n)⟩ =
      n * R.Θ_grid ⟨mu F (unitMulti i 1), mu_mem_kGrid F (unitMulti i 1)⟩ := by
  have h := Theta_scaleMult (R := R) (r := unitMulti i 1) n
  have hμ :
      mu F (scaleMult n (unitMulti i 1)) = mu F (unitMulti i n) := by
    simpa [scaleMult_unitMulti_one] using rfl
  simpa [hμ] using h

/-! ### Θ as a finite linear combination of atom-values -/

/-- The Θ-value of each atom (as a unit multiplicity). -/
noncomputable def thetaAtom {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F) (i : Fin k) : ℝ :=
  R.Θ_grid ⟨mu F (unitMulti i 1), mu_mem_kGrid F (unitMulti i 1)⟩

/-- Restrict a multiplicity vector to a finite set of indices. -/
def restrictMulti {k : ℕ} (r : Multi k) (S : Finset (Fin k)) : Multi k :=
  fun i => if i ∈ S then r i else 0

lemma restrictMulti_univ {k : ℕ} (r : Multi k) :
    restrictMulti r Finset.univ = r := by
  ext i
  simp [restrictMulti]

lemma restrictMulti_insert {k : ℕ} (r : Multi k) (S : Finset (Fin k)) (i : Fin k) (hi : i ∉ S) :
    restrictMulti r (insert i S) = fun j => restrictMulti r S j + unitMulti i (r i) j := by
  ext j
  by_cases hj : j = i
  · subst hj
    simp [restrictMulti, unitMulti, hi]
  · have : j ∈ insert i S ↔ j ∈ S := by
      simp [hj, hi]
    simp [restrictMulti, unitMulti, hj, this]

/-- Θ on the μ-grid is a finite linear combination of the atom Θ-values. -/
lemma Theta_eq_sum_mul_thetaAtom {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F) (r : Multi k) :
    R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ =
      ∑ i : Fin k, (r i : ℝ) * thetaAtom (F := F) R i := by
  classical
  let target : Finset (Fin k) → ℝ :=
    fun S =>
      R.Θ_grid ⟨mu F (restrictMulti r S), mu_mem_kGrid F (restrictMulti r S)⟩
  have hstep :
      ∀ S : Finset (Fin k),
        target S = ∑ i ∈ S, (r i : ℝ) * thetaAtom (F := F) R i := by
    intro S
    refine Finset.induction_on S ?base ?step
    · -- `restrictMulti r ∅` is the zero multiplicity, so `μ = ident` and `Θ = 0`.
      have hrestrict : restrictMulti r (∅ : Finset (Fin k)) = (fun _ : Fin k => 0) := by
        ext i
        simp [restrictMulti]
      have hμ : mu F (restrictMulti r (∅ : Finset (Fin k))) = ident := by
        simpa [hrestrict] using (mu_zero (F := F))
      have hsub :
          (⟨mu F (restrictMulti r (∅ : Finset (Fin k))),
              mu_mem_kGrid F (restrictMulti r (∅ : Finset (Fin k)))⟩ :
              {x // x ∈ kGrid F}) =
            ⟨ident, ident_mem_kGrid (F := F)⟩ := by
        ext
        simpa [hμ]
      simpa [target, thetaAtom, hsub] using R.ident_eq_zero
    · intro i S hi hIH
      have hrestrict := restrictMulti_insert (r := r) S i hi
      have hadd := R.add (restrictMulti r S) (unitMulti i (r i))
      have hmu :
          mu F (fun j => restrictMulti r S j + unitMulti i (r i) j) =
            mu F (restrictMulti r (insert i S)) := by
        congr 1
        simpa [hrestrict]
      have hθ_unit :
          R.Θ_grid ⟨mu F (unitMulti i (r i)), mu_mem_kGrid F (unitMulti i (r i))⟩ =
            (r i : ℝ) * thetaAtom (F := F) R i := by
        have h := Theta_unitMulti (R := R) (F := F) i (r i)
        simpa [thetaAtom, mul_comm, mul_left_comm, mul_assoc] using h
      have :
          target (insert i S) =
            target S + (r i : ℝ) * thetaAtom (F := F) R i := by
        have hadd' :
            R.Θ_grid ⟨mu F (fun j => restrictMulti r S j + unitMulti i (r i) j), mu_mem_kGrid F _⟩ =
              R.Θ_grid ⟨mu F (restrictMulti r S), mu_mem_kGrid F _⟩ +
                R.Θ_grid ⟨mu F (unitMulti i (r i)), mu_mem_kGrid F _⟩ := by
          simpa [Pi.add_apply] using hadd
        simpa [target, hmu, hrestrict, hθ_unit] using hadd'
      simpa [Finset.sum_insert, hi, hIH, this, add_comm, add_left_comm, add_assoc] using this
  have := hstep Finset.univ
  simpa [target, restrictMulti_univ, Finset.sum_sigma'] using this

/-- **IMPORTANT CAVEAT** (per GPT-5.1 Pro):

The global identity μ(F, n·r) = (μ(F, r))^n is **FALSE in GENERAL** without commutativity!

For multi-type families with k > 1:
  - μ(F, n·r) = a^{n·r₁} ⊕ b^{n·r₂} ⊕ ... (direct evaluation)
  - (μ(F, r))^n = (a^{r₁} ⊕ b^{r₂} ⊕ ...)^n (iterate the combined value)

These need NOT be equal in a non-commutative algebra!

**Where it DOES hold:**
1. k=0: Both sides are ident (proven below)
2. k=1: Trivial via `mu_scaleMult_eq_iterate_singleton`
3. **B-case** (k>1): When μ(F, r) = d^u for external d, the order/Θ structure forces
   equality (see `mu_scaleMult_iterate_B` below)

This lemma keeps the k=0 case for completeness. The k≥1 general case is REMOVED
because it's mathematically false. Use `mu_scaleMult_iterate_B` for B-case proofs.
-/
lemma mu_scaleMult_iterate_k0 (F : AtomFamily α 0) (r : Multi 0) (n : ℕ) :
    mu F (scaleMult n r) = iterate_op (mu F r) n := by
  -- Fin 0 is empty, so all multiplicities are zero and both sides are ident.
  have hident : ∀ m, iterate_op (ident : α) m = ident := by
    intro m
    induction m with
    | zero => simp [iterate_op_zero]
    | succ m ih =>
        simp [iterate_op, ih, op_ident_left]
  cases n <;> simp [mu, scaleMult, hident]

/-! ## GridBridge: The Inductive Hypothesis Capsule

The GridBridge structure captures the KEY inductive hypothesis for the k→k+1
induction in K&S Appendix A: the "grid bridge" property μ(n·r) = (μr)^n.

**Architecture** (per GPT-5.1 Pro):
- In the k→k+1 step, we ASSUME GridBridge for the old k-grid (F)
- We USE this assumption in separation_property, delta_shift_equiv, etc.
- We DERIVE GridBridge for the new (k+1)-grid (F') at the END of the step

This breaks the circularity: we don't try to prove the bridge from scratch;
we inherit it as the IH and pass it forward.
-/

/-- **Inductive hypothesis capsule**: the "grid bridge" property on a k-atom family F. -/
structure GridBridge {k : ℕ} (F : AtomFamily α k) : Prop where
  /-- The bridge: μ(n·r) = (μr)^n for all multi-indices r and scalars n. -/
  bridge : ∀ (r : Multi k) (n : ℕ),
    mu F (scaleMult n r) = iterate_op (mu F r) n

/-- GridBridge for k=0 is trivial (both sides are ident since Fin 0 is empty). -/
instance gridBridge_k0 (F : AtomFamily α 0) : GridBridge F :=
  ⟨fun r n => mu_scaleMult_iterate_k0 F r n⟩

/-- GridBridge for singleton atom family (k=1).
    This doesn't require commutativity - it's the base case for induction. -/
instance gridBridge_singleton (a : α) (ha : ident < a) :
    GridBridge (singletonAtomFamily (α := α) a ha) :=
  ⟨fun r n => mu_scaleMult_eq_iterate_singleton a ha r n⟩

/-- GridBridge for any k=1 family.
    For k=1, all multiplicities reduce to a single atom, making the bridge trivial.
    The proof mirrors mu_scaleMult_eq_iterate_singleton using F.atoms 0.

    TODO: Complete this proof - it follows the same pattern as the singleton case
    but requires showing that mu for any k=1 family equals the singleton formula. -/
lemma gridBridge_of_k_eq_one {F : AtomFamily α 1} : GridBridge F := by
  constructor
  intro r n
  classical
  -- For k=1, μ is essentially a single iterate: μ(F, r) = (F.atoms 0)^{r 0}
  -- because Fin 1 has exactly one element.
  let a := F.atoms ⟨0, by decide⟩

  -- Step 1: Show mu F r = iterate_op a (r 0)
  have hr : mu F r = iterate_op a (r ⟨0, by decide⟩) := by
    -- Fin 1 has one element, so foldl over finRange 1 = [0] is one step
    simp only [mu, a]
    -- finRange 1 = [0]
    have hlist : List.finRange 1 = [⟨0, by decide⟩] := by native_decide
    simp only [hlist, List.foldl_cons, List.foldl_nil, op_ident_left]

  -- Step 2: Show mu F (scaleMult n r) = iterate_op a (n * r 0)
  have hscale : scaleMult n r = fun _ : Fin 1 => n * r ⟨0, by decide⟩ := by
    funext i
    fin_cases i
    simp [scaleMult]
  have hnr : mu F (scaleMult n r) = iterate_op a (n * r ⟨0, by decide⟩) := by
    simp only [mu, a]
    have hlist : List.finRange 1 = [⟨0, by decide⟩] := by native_decide
    simp only [hlist, List.foldl_cons, List.foldl_nil, op_ident_left, hscale]

  -- Step 3: Show iterate_op (mu F r) n = iterate_op a (n * r 0)
  have hiter : iterate_op (mu F r) n = iterate_op a (n * r ⟨0, by decide⟩) := by
    rw [hr, iterate_op_mul]
    congr 1
    ring

  -- Conclude
  rw [hnr, hiter]

/-!
### TODO: Thread `GridBridge` across extensions

Similarly, we do not provide a generic lemma `gridBridge_of_k_ge_one` yet.  In the intended
K&S induction, `GridBridge` is carried as an inductive hypothesis and re-established on the
(k+1)-grid at the end of `extend_grid_rep_with_atom`.
-/

/-- The separation statistic for a witness (r, u).
    This is the "candidate value" for Θ(d) if μ(F, r) = d^u. -/
noncomputable def separationStatistic {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (r : Multi k) (u : ℕ) (hu : 0 < u) : ℝ :=
  R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / u

/-- B-set for the extension: old multiplicities r such that μ(F, r) = d^u. -/
def extensionSetB {k : ℕ} (F : AtomFamily α k) (d : α) (u : ℕ) : Set (Multi k) :=
  {r | mu F r = iterate_op d u}

/-- A-set for the extension: old multiplicities r such that μ(F, r) < d^u. -/
def extensionSetA {k : ℕ} (F : AtomFamily α k) (d : α) (u : ℕ) : Set (Multi k) :=
  {r | mu F r < iterate_op d u}

/-- C-set for the extension: old multiplicities r such that μ(F, r) > d^u. -/
def extensionSetC {k : ℕ} (F : AtomFamily α k) (d : α) (u : ℕ) : Set (Multi k) :=
  {r | iterate_op d u < mu F r}

/-- The A/B/C sets partition the space of multiplicities. -/
lemma extension_abc_partition {k : ℕ} (F : AtomFamily α k) (d : α) (u : ℕ) (r : Multi k) :
    r ∈ extensionSetA F d u ∨ r ∈ extensionSetB F d u ∨ r ∈ extensionSetC F d u := by
  rcases lt_trichotomy (mu F r) (iterate_op d u) with hlt | heq | hgt
  · left; exact hlt
  · right; left; exact heq
  · right; right; exact hgt

/-! ### Key Lemma: Repetition preserves B-membership

If μ(F, r) = d^u (i.e., r ∈ B(u)), then μ(F, n·r) = d^{nu} (i.e., n·r ∈ B(nu)).

**Proof strategy** (from K&S Appendix A, Section A.3.2):

For k=1 (singleton family): This is trivial via `iterate_op_mul`.
  μ(F, r) = a^r, so μ(F, n·r) = a^{nr} = (a^r)^n = (μ(F, r))^n = (d^u)^n = d^{nu}.

For k > 1: The proof uses the ORDER STRUCTURE. We show that μ(F, n·r) and d^{nu}
cannot be different by using the Θ representation:
- Θ(μ(F, n·r)) = n * Θ(μ(F, r)) (by Theta_scaleMult)
- d^{nu} = (d^u)^n = (μ(F, r))^n (by iterate_op_mul and hr)
- If μ(F, n·r) ≠ (μ(F, r))^n, the Archimedean property + repetition lemma give contradiction.

The deep insight: even though μ(F, n·r) ≠ (μ(F, r))^n in general without commutativity,
when μ(F, r) = d^u for some EXTERNAL element d, the equality IS forced by the order structure.
-/

/-- Repetition lemma for k=1: direct proof via iterate_op_mul. -/
theorem repetition_preserves_B_singleton (a : α) (ha : ident < a)
    (d : α) (hd : ident < d) (r : Multi 1) (u : ℕ) (hu : 0 < u)
    (hr : r ∈ extensionSetB (singletonAtomFamily (α := α) a ha) d u) (n : ℕ) (hn : 0 < n) :
    scaleMult n r ∈ extensionSetB (singletonAtomFamily (α := α) a ha) d (n * u) := by
  simp only [extensionSetB, Set.mem_setOf_eq] at hr ⊢
  -- hr : mu F r = iterate_op d u
  -- goal: mu F (scaleMult n r) = iterate_op d (n * u)
  let F := singletonAtomFamily (α := α) a ha
  -- Use the k=1 scaling lemma
  have h1 : mu F (scaleMult n r) = iterate_op (mu F r) n :=
    mu_scaleMult_eq_iterate_singleton a ha r n
  -- (μ(F, r))^n = (d^u)^n = d^{nu} by iterate_op_mul
  have h2 : iterate_op (mu F r) n = iterate_op d (n * u) := by
    rw [hr]
    rw [iterate_op_mul]
    ring_nf
  rw [h1, h2]

/-- **B-case scaling lemma**: When μ(F, r) = d^u (i.e., r ∈ B), the equality
    μ(F, n·r) = (μ(F, r))^n holds due to the order/Θ structure.

    **Mathematical argument** (per GPT-5.1 Pro § 4.2):
    1. Let x = μ(F, r) = d^u and y = d^{nu} = x^n (by iterate_op_mul).
    2. Want to show: μ(F, n·r) = y.
    3. Θ(μ(F, n·r)) = n * Θ(μ(F, r)) = n * Θ(x) (by Theta_scaleMult).
    4. Θ(x^n) = n * Θ(x) (by iterate additivity on Θ).
    5. So μ(F, n·r) and x^n have the same Θ-value.
    6. Since Θ is strictly monotone (order isomorphism), they are equal.

    This is a **deep consequence** of the Appendix A order/representation machinery,
    NOT a primitive algebraic law. The key restriction: μ(F, r) must be a pure power
    d^u of an external element d.

    TODO: Complete the proof using Theta_scaleMult + strict monotonicity + trichotomy.
          This requires the full Θ construction from associativity_representation. -/
lemma mu_scaleMult_iterate_B
    {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F) (IH : GridBridge F)
    (d : α) (hd : ident < d) (r : Multi k) (u : ℕ) (hu : 0 < u)
    (hr : r ∈ extensionSetB F d u) (n : ℕ) (hn : 0 < n) :
    mu F (scaleMult n r) = iterate_op (mu F r) n := by
  -- In the B-case we can appeal directly to the inductive grid bridge.
  -- The bridge already states the desired scaling identity for every r,n.
  simpa using IH.bridge r n

/-- Repetition lemma (general k): If r ∈ B(u), then (n·r) ∈ B(nu).

    For general k > 1, this uses the B-case scaling lemma `mu_scaleMult_iterate_B`.
    The key is that μ(F, n·r) and (μ(F, r))^n have the same Θ-value in the B-case,
    and therefore must be equal by the order structure.

    **Mathematical argument** (from K&S Appendix A):
    1. hr gives: μ(F, r) = d^u
    2. By `mu_scaleMult_iterate_B`: μ(F, n·r) = (μ(F, r))^n = (d^u)^n
    3. By `iterate_op_mul`: (d^u)^n = d^{n*u}
    4. Therefore: μ(F, n·r) = d^{n*u}, i.e., (n·r) ∈ B(n*u)
-/
theorem repetition_preserves_B {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F)
    (d : α) (hd : ident < d) (r : Multi k) (u : ℕ) (hu : 0 < u)
    (hr : r ∈ extensionSetB F d u) (n : ℕ) (hn : 0 < n) :
    scaleMult n r ∈ extensionSetB F d (n * u) := by
  simp only [extensionSetB, Set.mem_setOf_eq] at hr ⊢
  -- hr : mu F r = iterate_op d u
  -- goal: mu F (scaleMult n r) = iterate_op d (n * u)
  -- Use the B-case scaling lemma
  have h_mu_scaled : mu F (scaleMult n r) = iterate_op (mu F r) n :=
    mu_scaleMult_iterate_B R IH d hd r u hu hr n hn
  have h_target : iterate_op d (n * u) = iterate_op (mu F r) n := by
    -- (d^u)^n = d^{n*u}
    have : iterate_op d (n * u) = iterate_op (iterate_op d u) n := by
      -- iterate_op_mul uses multiplication in the second argument
      simpa [Nat.mul_comm] using (iterate_op_mul d u n).symm
    -- replace iterate_op d u with mu F r
    simpa [hr] using this
  -- Combine both identities
  exact h_mu_scaled.trans h_target.symm

/-! ### Case B Non-Empty: All Witnesses Share Common Statistic

**Reference**: K&S Appendix A, Section A.3.3 (lines 1624-1704)

When B is non-empty, multiple witnesses (r, u) and (r', u') may exist with:
- μ(F, r) = d^u
- μ(F, r') = d^{u'}

The key theorem shows they all give the same "statistic" value:
  σ(r, u) = Θ(μ(F, r)) / u = Θ(μ(F, r')) / u' = σ(r', u')

This pins down Θ(d) uniquely: Θ(d) = σ(r, u) for ANY witness (r, u) ∈ B.

**Proof**: Scale both witnesses to a common denominator u*u':
1. (u'·r, u'·u) ∈ B by repetition_preserves_B
2. (u·r', u·u') ∈ B by repetition_preserves_B
3. Both have target d^{u*u'}, so μ(F, u'·r) = d^{u'u} = μ(F, u·r')
4. Apply Θ and use Theta_scaleMult to get the equality.
-/

/-- If two witnesses are in B, their separation statistics are equal.
    This is the key uniqueness result for Case B non-empty. -/
theorem B_witnesses_same_statistic {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F)
    (d : α) (hd : ident < d)
    (r : Multi k) (u : ℕ) (hu : 0 < u) (hr : r ∈ extensionSetB F d u)
    (r' : Multi k) (u' : ℕ) (hu' : 0 < u') (hr' : r' ∈ extensionSetB F d u') :
    separationStatistic R r u hu = separationStatistic R r' u' hu' := by
  unfold separationStatistic
  -- We need: Θ(μ(F, r)) / u = Θ(μ(F, r')) / u'
  -- Equivalently: u' * Θ(μ(F, r)) = u * Θ(μ(F, r'))

  -- Scale (r, u) by u' to get (u'·r, u'*u) in B(u'*u)
  have hr_scaled : scaleMult u' r ∈ extensionSetB F d (u' * u) :=
    repetition_preserves_B R IH d hd r u hu hr u' hu'

  -- Scale (r', u') by u to get (u·r', u*u') in B(u*u')
  have hr'_scaled : scaleMult u r' ∈ extensionSetB F d (u * u') :=
    repetition_preserves_B R IH d hd r' u' hu' hr' u hu

  -- Both have the same target: d^{u'*u} = d^{u*u'}
  simp only [extensionSetB, Set.mem_setOf_eq] at hr_scaled hr'_scaled
  -- hr_scaled : mu F (scaleMult u' r) = iterate_op d (u' * u)
  -- hr'_scaled : mu F (scaleMult u r') = iterate_op d (u * u')

  -- Since u' * u = u * u', the targets are equal
  have h_targets_eq : iterate_op d (u' * u) = iterate_op d (u * u') := by
    congr 1; ring

  -- Therefore μ(F, u'·r) = μ(F, u·r')
  have h_mu_eq : mu F (scaleMult u' r) = mu F (scaleMult u r') := by
    rw [hr_scaled, h_targets_eq, ← hr'_scaled]

  -- Apply Θ to both sides
  have h_Theta_eq : R.Θ_grid ⟨mu F (scaleMult u' r), mu_mem_kGrid F _⟩ =
                    R.Θ_grid ⟨mu F (scaleMult u r'), mu_mem_kGrid F _⟩ := by
    congr 1; ext; exact h_mu_eq

  -- Use Theta_scaleMult on both sides
  have h_lhs : R.Θ_grid ⟨mu F (scaleMult u' r), mu_mem_kGrid F _⟩ =
               u' * R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ :=
    Theta_scaleMult R r u'

  have h_rhs : R.Θ_grid ⟨mu F (scaleMult u r'), mu_mem_kGrid F _⟩ =
               u * R.Θ_grid ⟨mu F r', mu_mem_kGrid F r'⟩ :=
    Theta_scaleMult R r' u

  -- Combine: u' * Θ(μ(F, r)) = u * Θ(μ(F, r'))
  rw [h_lhs, h_rhs] at h_Theta_eq

  -- Convert to division form: Θ(μ(F, r)) / u = Θ(μ(F, r')) / u'
  field_simp
  linarith [h_Theta_eq]

/-- The common statistic value for all B-witnesses.
    When B is non-empty, this is the value we assign to Θ(d). -/
noncomputable def B_common_statistic {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (d : α) (hd : ident < d)
    (hB_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetB F d u) : ℝ :=
  -- Use Classical.choose to extract witness from existential
  let r := Classical.choose hB_nonempty
  let hu' := Classical.choose_spec hB_nonempty
  let u := Classical.choose hu'
  let hu_spec := Classical.choose_spec hu'
  let hu : 0 < u := hu_spec.1
  separationStatistic R r u hu

/-- The common statistic is independent of the witness choice. -/
theorem B_common_statistic_eq_any_witness {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (IH : GridBridge F) (d : α) (hd : ident < d)
    (hB_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetB F d u)
    (r : Multi k) (u : ℕ) (hu : 0 < u) (hr : r ∈ extensionSetB F d u) :
    B_common_statistic R d hd hB_nonempty = separationStatistic R r u hu := by
  -- B_common_statistic uses Classical.choose to pick a witness (r₀, u₀)
  -- We need to show its statistic equals the given witness (r, u)'s statistic
  unfold B_common_statistic
  -- Extract the chosen witness
  let r₀ := Classical.choose hB_nonempty
  let hu'_spec := Classical.choose_spec hB_nonempty
  let u₀ := Classical.choose hu'_spec
  let hu_spec := Classical.choose_spec hu'_spec
  have hu₀ : 0 < u₀ := hu_spec.1
  have hr₀ : r₀ ∈ extensionSetB F d u₀ := hu_spec.2
  -- Now apply B_witnesses_same_statistic to show they're equal
  exact B_witnesses_same_statistic R IH d hd r₀ u₀ hu₀ hr₀ r u hu hr

/-- Convenience wrapper around `Nat.findGreatest_eq_iff`.
    It provides the predicate at `findGreatest`, the bound, and maximality. -/
lemma findGreatest_crossing (P : ℕ → Prop) [DecidablePred P] (n : ℕ) (hP0 : P 0) :
    P (Nat.findGreatest P n) ∧ Nat.findGreatest P n ≤ n ∧
      ∀ k, Nat.findGreatest P n < k → k ≤ n → ¬ P k := by
  have h :=
    (Nat.findGreatest_eq_iff (P := P) (k := n) (m := Nat.findGreatest P n)).1 rfl
  have h_le : Nat.findGreatest P n ≤ n := h.1
  have h_pred_if_pos : Nat.findGreatest P n ≠ 0 → P (Nat.findGreatest P n) := h.2.1
  have h_max : ∀ k, Nat.findGreatest P n < k → k ≤ n → ¬ P k := by
    intro k hk hk_le
    exact h.2.2 hk hk_le
  have h_pred : P (Nat.findGreatest P n) := by
    by_cases h0 : Nat.findGreatest P n = 0
    · simpa [h0] using hP0
    · exact h_pred_if_pos h0
  exact ⟨h_pred, h_le, h_max⟩

/-! ### Case B Empty: Accuracy Lemma

**Reference**: K&S Appendix A, Section A.3.4 (lines 1706-1895)

When B is empty, there's a gap between sup(A) and inf(C).
We choose δ in this gap as the value for Θ(d).

The accuracy lemma shows that δ is determined arbitrarily precisely:
for any ε > 0, there exist (r, u) ∈ A and (r', u') ∈ C such that:
- σ(r', u') - σ(r, u) < ε

This uses the Archimedean property to find arbitrarily fine comparisons.
-/

/-- When B is empty, A and C partition the witnesses with a gap.
    We can choose δ in the gap as Θ(d). -/
noncomputable def B_empty_delta {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (d : α) (hd : ident < d)
    (hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u)
    (hA_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u)
    (hC_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u) : ℝ :=
  -- The supremum of A-statistics is a valid choice for δ
  -- In a complete construction, we'd define this as a Dedekind cut
  -- For now, we use sSup of the A-statistics (using Θ-values directly)
  sSup {s : ℝ | ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u ∧
                s = R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / u}

/-- Floor-bracket below: for δ>0 and θ≥0, `V := ⌊θ/δ⌋` gives `V•δ ≤ θ`. -/
lemma floor_bracket_le (δ θ : ℝ) (hδ : 0 < δ) (hθ : 0 ≤ θ) :
  (Nat.floor (θ / δ) : ℝ) * δ ≤ θ := by
  have h_nonneg : 0 ≤ θ / δ := div_nonneg hθ (le_of_lt hδ)
  have : (Nat.floor (θ / δ) : ℝ) ≤ θ / δ := Nat.floor_le h_nonneg
  calc (Nat.floor (θ / δ) : ℝ) * δ
      ≤ (θ / δ) * δ := by exact mul_le_mul_of_nonneg_right this (le_of_lt hδ)
    _ = θ           := by field_simp

/-- Floor-bracket above: for δ>0 and θ≥0, `θ < (V+1)•δ`. -/
lemma lt_floor_succ_bracket (δ θ : ℝ) (hδ : 0 < δ) (hθ : 0 ≤ θ) :
  θ < ((Nat.floor (θ / δ) + 1 : ℕ) : ℝ) * δ := by
  have h_nonneg : 0 ≤ θ / δ := div_nonneg hθ (le_of_lt hδ)
  -- Nat.lt_floor_add_one states: x < ⌊x⌋₊ + 1
  have h_lt : θ / δ < ⌊θ / δ⌋₊ + 1 := Nat.lt_floor_add_one (θ / δ)
  calc θ = (θ / δ) * δ := by field_simp
    _ < (⌊θ / δ⌋₊ + 1) * δ := by
      apply mul_lt_mul_of_pos_right h_lt hδ
    _ = ((Nat.floor (θ / δ) + 1 : ℕ) : ℝ) * δ := by norm_cast

/-- **Helper Lemma 0 (GPT-5 Pro)**: Swap middle elements using grid commutativity.
Given multi-index witnesses for grid membership, we can swap using associativity + commutativity. -/
lemma op_swap_right_on_grid {k : ℕ} {F : AtomFamily α k}
    (H : GridComm F) (r_x r_y r_z : Multi k)
    (hx : x = mu F r_x) (hy : y = mu F r_y) (hz : z = mu F r_z) :
    op (op x y) z = op (op x z) y := by
  subst hx hy hz
  calc op (op (mu F r_x) (mu F r_y)) (mu F r_z)
      = op (mu F r_x) (op (mu F r_y) (mu F r_z)) := op_assoc _ _ _
    _ = op (mu F r_x) (op (mu F r_z) (mu F r_y)) := by rw [H.comm r_y r_z]
    _ = op (op (mu F r_x) (mu F r_z)) (mu F r_y) := (op_assoc _ _ _).symm

/-- **Helper**: Iterates of atoms are grid members. -/
lemma iterate_atom_mem_kGrid {k : ℕ} (F : AtomFamily α k) (i : Fin k) (n : ℕ) :
    iterate_op (F.atoms i) n ∈ kGrid F := by
  use unitMulti i n
  exact (mu_unitMulti F i n).symm

/-- **Helper**: Folds with contributions from a multiplicity vector.
Two folds over the same list with the same function are equal. -/
private lemma mu_foldl_eq {k : ℕ} (F : AtomFamily α k) (r : Multi k)
    (l : List (Fin k)) (acc : α) :
    List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i))) acc l =
    List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i))) acc l := rfl

/-- **Helper**: Pull an iterate contribution past another using GridComm.
This is the core swap operation that enables reordering. -/
private lemma op_iterate_comm {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (i j : Fin k) (m n : ℕ) :
    op (iterate_op (F.atoms i) m) (iterate_op (F.atoms j) n) =
    op (iterate_op (F.atoms j) n) (iterate_op (F.atoms i) m) := by
  have hi : iterate_op (F.atoms i) m = mu F (unitMulti i m) := (mu_unitMulti F i m).symm
  have hj : iterate_op (F.atoms j) n = mu F (unitMulti j n) := (mu_unitMulti F j n).symm
  rw [hi, hj, H.comm (unitMulti i m) (unitMulti j n)]

/-- **Helper**: Pull an iterate contribution to the right of accumulator.
Key: op (op acc x) y = op (op acc y) x when x, y are grid elements. -/
private lemma op_op_comm_grid {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (acc : α) (i j : Fin k) (m n : ℕ) :
    op (op acc (iterate_op (F.atoms i) m)) (iterate_op (F.atoms j) n) =
    op (op acc (iterate_op (F.atoms j) n)) (iterate_op (F.atoms i) m) := by
  calc op (op acc (iterate_op (F.atoms i) m)) (iterate_op (F.atoms j) n)
      = op acc (op (iterate_op (F.atoms i) m) (iterate_op (F.atoms j) n)) := op_assoc _ _ _
    _ = op acc (op (iterate_op (F.atoms j) n) (iterate_op (F.atoms i) m)) := by
        rw [op_iterate_comm H i j m n]
    _ = op (op acc (iterate_op (F.atoms j) n)) (iterate_op (F.atoms i) m) := (op_assoc _ _ _).symm

/-- **Helper**: Pull one s-contribution through an r-fold using commutativity.
After folding r-contributions, we can move a single s-contribution past. -/
private lemma foldl_r_then_s {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (l : List (Fin k)) (r : Multi k) (j : Fin k) (n : ℕ) (acc : α) :
    op (List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i))) acc l)
       (iterate_op (F.atoms j) n) =
    List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i)))
       (op acc (iterate_op (F.atoms j) n)) l := by
  induction l generalizing acc with
  | nil => rfl
  | cons i tl ih =>
    simp only [List.foldl_cons]
    -- LHS = op (foldl ... (op acc (iter_r_i)) tl) (iter_s_j)
    -- RHS = foldl ... (op (op acc (iter_s_j)) (iter_r_i)) tl
    -- First, show we can swap iter_r_i and iter_s_j:
    have hswap : op (op acc (iterate_op (F.atoms i) (r i))) (iterate_op (F.atoms j) n) =
                 op (op acc (iterate_op (F.atoms j) n)) (iterate_op (F.atoms i) (r i)) :=
      op_op_comm_grid H acc i j (r i) n
    -- Now use IH
    calc op (List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i)))
               (op acc (iterate_op (F.atoms i) (r i))) tl) (iterate_op (F.atoms j) n)
        = List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i)))
               (op (op acc (iterate_op (F.atoms i) (r i))) (iterate_op (F.atoms j) n)) tl := ih _
      _ = List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i)))
               (op (op acc (iterate_op (F.atoms j) n)) (iterate_op (F.atoms i) (r i))) tl := by
          rw [hswap]

/-- **Carry lemma**: Starting the fold with an extra `j`-iterate is the same as
bumping the `j`-coordinate by `n`.

Key insight from GPT-5 Pro: Instead of splitting at j-1, we bubble the extra
iterate across the fold one head at a time, merge exponents when we hit j,
then use foldl_congr_on_list for the tail (since j can't appear again by nodup). -/
private lemma foldl_carry_unit {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (r : Multi k) (j : Fin k) (n : ℕ) :
    ∀ (l : List (Fin k)) (hnd : l.Nodup) (hj : j ∈ l) (acc : α),
      List.foldl (fun a i => op a (iterate_op (F.atoms i) (r i)))
        (op acc (iterate_op (F.atoms j) n)) l
      =
      List.foldl (fun a i => op a (iterate_op (F.atoms i) ((r + unitMulti j n) i)))
        acc l := by
  intro l hnd hj acc
  induction l generalizing acc with
  | nil =>
    simp at hj  -- j ∈ [] is impossible
  | cons i tl ih =>
    have hi_not_in_tl : i ∉ tl := (List.nodup_cons.mp hnd).1
    have hnd_tl : tl.Nodup := (List.nodup_cons.mp hnd).2
    have hj' : j = i ∨ j ∈ tl := by
      simpa [List.mem_cons] using hj
    cases hj' with
    | inl hji =>
      subst hji
      -- Now j is the head, and j ∉ tl by nodup
      have hj_not_in_tl : j ∉ tl := hi_not_in_tl
      simp only [List.foldl_cons]
      -- Merge the two j-contributions in the starting accumulator:
      have hstart :
          op (op acc (iterate_op (F.atoms j) n)) (iterate_op (F.atoms j) (r j)) =
            op acc (iterate_op (F.atoms j) ((r + unitMulti j n) j)) := by
        -- (acc ⊕ j^n) ⊕ j^{rj} = acc ⊕ (j^n ⊕ j^{rj}) = acc ⊕ j^{n+rj} = acc ⊕ j^{rj+n}
        rw [op_assoc]
        rw [iterate_op_add (F.atoms j) n (r j)]
        rw [Nat.add_comm n (r j)]
        simp [Pi.add_apply, unitMulti]
      -- Replace the LHS init accumulator by the RHS init accumulator
      rw [hstart]
      -- Tail: since j ∉ tl, the step functions agree on tl
      apply foldl_congr_on_list
      intro x hx acc'
      have hxne : x ≠ j := by
        intro hEq
        apply hj_not_in_tl
        simpa [hEq] using hx
      simp [Pi.add_apply, unitMulti, hxne]
    | inr hj_tl =>
      -- j is in tl; nodup forces i ≠ j
      have hij_ne : i ≠ j := by
        intro hEq
        apply hi_not_in_tl
        simpa [hEq] using hj_tl
      simp only [List.foldl_cons]
      -- Swap the head i-iterate past the carried j-iterate in the accumulator
      have hswap :
          op (op acc (iterate_op (F.atoms j) n)) (iterate_op (F.atoms i) (r i)) =
          op (op acc (iterate_op (F.atoms i) (r i))) (iterate_op (F.atoms j) n) := by
        simpa using op_op_comm_grid (H := H) (acc := acc) (i := j) (j := i) (m := n) (n := r i)
      rw [hswap]
      -- Now apply IH on the tail with accumulator advanced by the i-step
      have hih :=
        ih (acc := op acc (iterate_op (F.atoms i) (r i))) hnd_tl hj_tl
      -- RHS head uses (r + unitMulti j n) i = r i since i ≠ j
      have hi_eq : (r + unitMulti j n) i = r i := by
        simp [Pi.add_apply, unitMulti, hij_ne]
      simp only [List.foldl_cons, hi_eq]
      exact hih

/-- **Helper**: Adding a unit contribution to mu using GridComm.
The key insight is that mu F (r + unitMulti j n) has contribution r_j + n at index j,
which equals op (iter_j^{r_j}) (iter_j^n) = iter_j^{r_j + n} by iterate_op_add.
With GridComm, we can reorder to merge the contributions.

This is the KEY lemma that breaks the circularity in foldl_op_distrib_gen.

**Proof** (per GPT-5 Pro): Use foldl_r_then_s to pull the iterate to the start,
then foldl_carry_unit to merge at j and adjust the tail. -/
private lemma mu_add_unitMulti {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (r : Multi k) (j : Fin k) (n : ℕ) :
    op (mu F r) (iterate_op (F.atoms j) n) = mu F (r + unitMulti j n) := by
  classical
  unfold mu
  set l : List (Fin k) := List.finRange k with hl_def
  have hnd : l.Nodup := by simpa [l] using (List.nodup_finRange k)
  have hj : j ∈ l := by simp [l]
  -- Pull the extra iterate into the fold using foldl_r_then_s
  have hpull :=
    foldl_r_then_s (H := H) (l := l) (r := r) (j := j) (n := n) (acc := ident)
  -- Now carry it through and merge at j via foldl_carry_unit
  calc
    op (List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (r i))) ident l)
        (iterate_op (F.atoms j) n)
        =
      List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (r i)))
        (op ident (iterate_op (F.atoms j) n)) l := by
          simpa [l] using hpull
    _ =
      List.foldl (fun acc i => op acc (iterate_op (F.atoms i) ((r + unitMulti j n) i)))
        ident l := by
          simpa [l, op_ident_left] using
            (foldl_carry_unit (H := H) (r := r) (j := j) (n := n) l hnd hj ident)

/-- **Generalized Distribution Lemma**: When starting from op (mu F r_acc) (mu F s_acc),
the combined fold distributes into separate r and s folds.
This requires witness tracking for commutativity.

**Key insight**: We track that the accumulators are mu F of the "already processed" indices,
so we can apply GridComm to swap contributions. -/
private lemma foldl_op_distrib_gen {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (l : List (Fin k)) (r s r_acc s_acc : Multi k) :
    List.foldl (fun acc i => op acc (op (iterate_op (F.atoms i) (r i))
                                       (iterate_op (F.atoms i) (s i))))
       (op (mu F r_acc) (mu F s_acc)) l =
    op (List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (r i))) (mu F r_acc) l)
       (List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (s i))) (mu F s_acc) l) := by
  induction l generalizing r_acc s_acc with
  | nil => rfl
  | cons j tl ih =>
    simp only [List.foldl_cons]
    -- Key: Rewrite op (op (mu F r_acc) (mu F s_acc)) (op r_j s_j)
    -- as op (op (mu F r_acc) r_j) (op (mu F s_acc) s_j)
    have hreorder : op (op (mu F r_acc) (mu F s_acc))
                       (op (iterate_op (F.atoms j) (r j)) (iterate_op (F.atoms j) (s j))) =
                    op (op (mu F r_acc) (iterate_op (F.atoms j) (r j)))
                       (op (mu F s_acc) (iterate_op (F.atoms j) (s j))) := by
      let r_j := iterate_op (F.atoms j) (r j)
      let s_j := iterate_op (F.atoms j) (s j)
      have hr_j : r_j = mu F (unitMulti j (r j)) := (mu_unitMulti F j (r j)).symm
      calc op (op (mu F r_acc) (mu F s_acc)) (op r_j s_j)
          = op (mu F r_acc) (op (mu F s_acc) (op r_j s_j)) := op_assoc _ _ _
        _ = op (mu F r_acc) (op (op (mu F s_acc) r_j) s_j) := by rw [← op_assoc (mu F s_acc) r_j s_j]
        _ = op (mu F r_acc) (op (op r_j (mu F s_acc)) s_j) := by
            have hcomm : op (mu F s_acc) r_j = op r_j (mu F s_acc) := by
              rw [hr_j]; exact H.comm s_acc (unitMulti j (r j))
            rw [hcomm]
        _ = op (mu F r_acc) (op r_j (op (mu F s_acc) s_j)) := by rw [op_assoc r_j (mu F s_acc) s_j]
        _ = op (op (mu F r_acc) r_j) (op (mu F s_acc) s_j) := (op_assoc _ _ _).symm
    rw [hreorder]

    -- Now apply IH with updated witnesses
    -- Key observation: op (mu F r_acc) (iterate_op ...) = mu F (r_acc + unitMulti j ...)
    -- by mu_add_unitMulti (which uses GridComm)
    have hr_new : op (mu F r_acc) (iterate_op (F.atoms j) (r j)) =
                  mu F (r_acc + unitMulti j (r j)) := mu_add_unitMulti H r_acc j (r j)
    have hs_new : op (mu F s_acc) (iterate_op (F.atoms j) (s j)) =
                  mu F (s_acc + unitMulti j (s j)) := mu_add_unitMulti H s_acc j (s j)
    rw [hr_new, hs_new]
    exact ih (r_acc + unitMulti j (r j)) (s_acc + unitMulti j (s j))

/-- **Key Distribution Lemma**: Foldl of "op-pair" distributes as op of two foldls.
When all contributions commute pairwise (via GridComm), we can separate the fold of
(a^r ⊕ a^s) into op (fold of a^r) (fold of a^s).

This is a special case of foldl_op_distrib_gen starting from ident = mu F 0. -/
private lemma foldl_op_distrib {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (l : List (Fin k)) (r s : Multi k) :
    List.foldl (fun acc i => op acc (op (iterate_op (F.atoms i) (r i))
                                       (iterate_op (F.atoms i) (s i)))) ident l =
    op (List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (r i))) ident l)
       (List.foldl (fun acc i => op acc (iterate_op (F.atoms i) (s i))) ident l) := by
  -- The generalized version starts from op (mu F r_acc) (mu F s_acc).
  -- With r_acc = s_acc = 0, we have:
  --   mu F 0 = ident
  --   op (mu F 0) (mu F 0) = op ident ident = ident
  -- So we can use foldl_op_distrib_gen and simplify
  have hgen := foldl_op_distrib_gen H l r s (fun _ => 0) (fun _ => 0)
  -- Simplify: op (mu F 0) (mu F 0) = ident, mu F 0 = ident
  have h0 : mu F (fun _ => 0) = ident := mu_zero F
  simp only [h0, op_ident_left] at hgen
  exact hgen

/-- **Helper: mu is additive if the grid commutes.**

This is the key algebraic property: when GridComm holds, mu preserves addition.
The proof requires reordering the foldl terms using commutativity.

**Proof Strategy** (per GPT-5 Pro):
For F' = extendAtomFamily F d hd with k+1 atoms:
1. Use splitMulti/joinMulti to decompose multiplicities
2. Apply mu_extend_last to separate old and new parts
3. Get GridComm F from H' via gridComm_of_extended (Lemma 2)
4. Apply IH (mu_add_of_comm on F) for the old grid part
5. Use iterate_op_add for the new atom's contribution
6. Reorder using op_swap_right_on_grid (Lemma 0)

**Dependencies**: Blocks mu_scale_eq_iterate_of_comm, delta_shift_equiv (pure A/C),
and h_strictMono (t_x ≠ t_y cases). -/
lemma mu_add_of_comm {k : ℕ} {F : AtomFamily α k} (H : GridComm F)
    (r s : Multi k) : mu F (r + s) = op (mu F r) (mu F s) := by
  -- Strategy: Rewrite mu F (r+s) using iterate_op_add, then apply foldl_op_distrib.
  --
  -- Step 1: mu F (r+s) = foldl (λ acc i => op acc (iter_i^{(r+s)_i})) ident (finRange k)
  -- Step 2: By iterate_op_add: iter_i^{(r+s)_i} = op (iter_i^{r_i}) (iter_i^{s_i})
  -- Step 3: So mu F (r+s) = foldl (λ acc i => op acc (op (iter_r_i) (iter_s_i))) ident (finRange k)
  -- Step 4: By foldl_op_distrib: = op (foldl ... r ...) (foldl ... s ...)
  --                              = op (mu F r) (mu F s)

  -- First, show that the fold of (r+s) equals the fold of "paired" contributions
  have hfold_rw : mu F (r + s) =
      List.foldl (fun acc i => op acc (op (iterate_op (F.atoms i) (r i))
                                          (iterate_op (F.atoms i) (s i)))) ident
        (List.finRange k) := by
    unfold mu
    congr 1
    funext acc i
    -- Show: op acc (iter_i^{(r+s)_i}) = op acc (op (iter_i^{r_i}) (iter_i^{s_i}))
    have h_split : iterate_op (F.atoms i) ((r + s) i) =
                   op (iterate_op (F.atoms i) (r i)) (iterate_op (F.atoms i) (s i)) := by
      simp only [Pi.add_apply]
      exact (iterate_op_add (F.atoms i) (r i) (s i)).symm
    rw [h_split]

  rw [hfold_rw]

  -- Now apply foldl_op_distrib
  exact foldl_op_distrib H (List.finRange k) r s

/-- **Grid Bridge Lemma (with GridComm)**: μ(F, n·r) equals (μ(F, r))^n.

This is the KEY lemma that enables all separation/shift/strict-mono arguments.
It converts "grouped" compositions μ(F, n·r) to "interleaved" compositions (μ(F,r))^n.

**Proof**: By induction on n, using mu_add_of_comm for the step case. -/
lemma mu_scale_eq_iterate_of_comm {k : ℕ} {F : AtomFamily α k}
    (H : GridComm F) (r : Multi k) (n : ℕ) :
    mu F (scaleMult n r) = iterate_op (mu F r) n := by
  induction n with
  | zero =>
    -- Base: μ(0·r) = ident = (μ r)^0
    simp only [scaleMult_zero, mu_zero, iterate_op_zero]
  | succ n ih =>
    -- Step: scaleMult (n+1) r = scaleMult n r + r
    have h_split : scaleMult (n + 1) r = scaleMult n r + r := by
      ext i
      simp only [scaleMult, Pi.add_apply]
      ring
    rw [h_split, mu_add_of_comm H, ih]
    -- Goal: op (iterate_op (mu F r) n) (mu F r) = iterate_op (mu F r) (n + 1)
    -- Use iterate_op_add with m=n, n=1: op (iterate_op a n) (iterate_op a 1) = iterate_op a (n+1)
    calc op (iterate_op (mu F r) n) (mu F r)
        = op (iterate_op (mu F r) n) (iterate_op (mu F r) 1) := by rw [iterate_op_one]
      _ = iterate_op (mu F r) (n + 1) := iterate_op_add (mu F r) n 1

/-- **Grid Bridge Lemma (legacy)**: μ(F, n·r) equals (μ(F, r))^n.
    For k=1, this is proven via `mu_scaleMult_eq_iterate_singleton`.
    For k>1, this follows from the existence of the representation R,
    which implies commutativity on the grid.
    This is the inductive bootstrap step - the representation theorem ensures
    this equality holds on the grid. -/
lemma mu_scale_eq_iterate {k : ℕ} {F : AtomFamily α k} (_R : MultiGridRep F)
    (H : GridComm F) (r : Multi k) (n : ℕ) :
    mu F (scaleMult n r) = iterate_op (mu F r) n := by
  -- Case split on k
  match k with
  | 0 =>
    -- k=0: Both sides equal ident (empty grid)
    have h_lhs : mu F (scaleMult n r) = ident := by
      unfold mu
      simp [List.finRange_zero]
    have h_rhs : iterate_op (mu F r) n = ident := by
      have hmu : mu F r = ident := by unfold mu; simp [List.finRange_zero]
      rw [hmu]
      -- Now need: iterate_op ident n = ident
      -- Use a helper lemma to avoid context pollution in induction
      suffices h : ∀ m, iterate_op ident m = ident from h n
      intro m
      induction m with
      | zero => rfl
      | succ k hk => simp only [iterate_op, hk, op_ident_left]
    rw [h_lhs, h_rhs]
  | 1 =>
    -- k=1: Use mu_scaleMult_eq_iterate_singleton
    -- Extract the single atom
    let a := F.atoms ⟨0, by decide⟩
    have ha : ident < a := F.pos ⟨0, by decide⟩
    -- Show F equals singletonAtomFamily a
    have hF_eq : ∀ i : Fin 1, F.atoms i = a := fun i => by simp [a, Fin.eq_zero i]
    -- The result follows from the singleton case
    -- We need to connect F to singletonAtomFamily
    have hr : mu F r = iterate_op a (r ⟨0, by decide⟩) := by
      unfold mu
      simp [List.finRange_succ, List.finRange_zero, hF_eq, op_ident_left]
    have hscale : mu F (scaleMult n r) = iterate_op a (n * r ⟨0, by decide⟩) := by
      unfold mu
      simp [List.finRange_succ, List.finRange_zero, hF_eq, op_ident_left, scaleMult]
    have hiter : iterate_op (mu F r) n = iterate_op a (n * r ⟨0, by decide⟩) := by
      rw [hr, iterate_op_mul]
      ring_nf
    rw [hscale, hiter]
  | k + 2 =>
    -- k≥2: Use GridComm hypothesis which provides commutativity.
    -- This is the INDUCTIVE HYPOTHESIS from the k→k+1 induction.
    exact mu_scale_eq_iterate_of_comm H r n

/-- **Separation Property**: For any A-witness and C-witness, the A-statistic is strictly less than the C-statistic.

This is a key result from K&S Appendix A. The proof uses:
1. Repetition lemma to scale to common denominator
2. Strict monotonicity of Θ to preserve the ordering mu F rA < d^M < mu F rC
3. Division to get the statistic inequality

Mathematical sketch:
- rA ∈ A(uA) means: mu F rA < d^uA
- rC ∈ C(uC) means: mu F rC > d^uC
- Scale to M = uA · uC:
  - (mu F rA)^uC < d^M (by repetition)
  - d^M < (mu F rC)^uA (by repetition)
- Apply Θ and use additivity on iterates:
  - uC · Θ(mu F rA) < M · Θ(d) < uA · Θ(mu F rC)
- Divide to get: Θ(mu F rA)/uA < Θ(mu F rC)/uC
-/
lemma separation_property {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (H : GridComm F) (IH : GridBridge F) {d : α} (hd : ident < d)
    {rA : Multi k} {uA : ℕ} (huA : 0 < uA) (hrA : rA ∈ extensionSetA F d uA)
    {rC : Multi k} {uC : ℕ} (huC : 0 < uC) (hrC : rC ∈ extensionSetC F d uC) :
    separationStatistic R rA uA huA < separationStatistic R rC uC huC := by
  unfold separationStatistic extensionSetA extensionSetC at *
  -- Extract the key inequalities
  have hA_lt : mu F rA < iterate_op d uA := hrA
  have hC_gt : mu F rC > iterate_op d uC := hrC

  -- Use repetition to scale to common denominator Δ = uA * uC
  -- Key: compare scaled grid points, not iterate equality
  let Δ := uA * uC
  have hΔ_pos : 0 < Δ := Nat.mul_pos huA huC
  let mA := uC  -- Δ / uA = (uA * uC) / uA = uC
  let mC := uA  -- Δ / uC = (uA * uC) / uC = uA

  -- Step 1: Scale the inequalities using repetition_lemma_lt
  -- From μ(F,rA) < d^uA, get (μ(F,rA))^mA < d^(uA*mA) = d^Δ
  have hA_scaled : iterate_op (mu F rA) mA < iterate_op d Δ := by
    have : iterate_op (mu F rA) (1 * mA) < iterate_op d (uA * mA) :=
      repetition_lemma_lt (mu F rA) d 1 uA mA huC (by rwa [iterate_op_one])
    simpa [Nat.one_mul] using this

  -- From d^uC < μ(F,rC), get d^Δ < (μ(F,rC))^mC
  have hC_scaled : iterate_op d Δ < iterate_op (mu F rC) mC := by
    have : iterate_op d (uC * mC) < iterate_op (mu F rC) (1 * mC) :=
      repetition_lemma_lt d (mu F rC) uC 1 mC huA (by rwa [iterate_op_one])
    simp only [Nat.one_mul] at this
    convert this using 2
    ring  -- Δ = uA * uC = uC * uA = uC * mC

  -- Step 2: Transitivity gives (μ(F,rA))^mA < (μ(F,rC))^mC
  have h_iter_lt : iterate_op (mu F rA) mA < iterate_op (mu F rC) mC :=
    lt_trans hA_scaled hC_scaled

  -- Step 3: Use Theta_scaleMult to connect to grid points
  -- Θ(μ(F, mA · rA)) = mA · Θ(μ(F,rA))
  have hA_theta : R.Θ_grid ⟨mu F (scaleMult mA rA), mu_mem_kGrid F _⟩ =
                  mA * R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ :=
    Theta_scaleMult R rA mA

  have hC_theta : R.Θ_grid ⟨mu F (scaleMult mC rC), mu_mem_kGrid F _⟩ =
                  mC * R.Θ_grid ⟨mu F rC, mu_mem_kGrid F rC⟩ :=
    Theta_scaleMult R rC mC

  -- Step 4: Show mu F (scaleMult mA rA) < mu F (scaleMult mC rC)
  -- We need this to apply R.strictMono and get the Θ inequality

  have h_grid_lt : mu F (scaleMult mA rA) < mu F (scaleMult mC rC) := by
    -- Use GridBridge (the inductive hypothesis) directly!
    -- This is the key change per GPT-5.1 Pro: we ASSUME the bridge as IH,
    -- not derive it here. The IH is threaded from the k-grid to the (k+1)-grid.
    have hA_bridge : mu F (scaleMult mA rA) = iterate_op (mu F rA) mA :=
      IH.bridge rA mA
    have hC_bridge : mu F (scaleMult mC rC) = iterate_op (mu F rC) mC :=
      IH.bridge rC mC

    -- Rewrite grid points as iterates and apply h_iter_lt
    rw [hA_bridge, hC_bridge]
    exact h_iter_lt

  -- Step 5: Apply R.strictMono to get Θ inequality
  have h_Theta_lt : R.Θ_grid ⟨mu F (scaleMult mA rA), mu_mem_kGrid F _⟩ <
                    R.Θ_grid ⟨mu F (scaleMult mC rC), mu_mem_kGrid F _⟩ :=
    R.strictMono h_grid_lt

  -- Step 6: Substitute Theta_scaleMult and simplify
  rw [hA_theta, hC_theta] at h_Theta_lt
  -- Now have: mA * R.Θ_grid ⟨mu F rA, ...⟩ < mC * R.Θ_grid ⟨mu F rC, ...⟩
  -- which is: uC * Θ(rA) < uA * Θ(rC)

  -- Step 7: Divide both sides to get separation statistic inequality
  -- Note: separationStatistic was already unfolded at line 1338
  -- We have: mA * Θ(rA) < mC * Θ(rC) where mA = uC, mC = uA
  -- Dividing by (uA * uC): Θ(rA)/uA < Θ(rC)/uC
  have huA_pos_real : (0 : ℝ) < uA := Nat.cast_pos.mpr huA
  have huC_pos_real : (0 : ℝ) < uC := Nat.cast_pos.mpr huC

  -- Goal: Θ(rA)/uA < Θ(rC)/uC
  -- Using div_lt_div_iff₀: a/b < c/d ↔ a*d < c*b (for positive b, d)
  rw [div_lt_div_iff₀ huA_pos_real huC_pos_real]
  -- Goal is now: Θ(rA) * uC < Θ(rC) * uA
  -- h_Theta_lt is: mA * Θ(rA) < mC * Θ(rC) where mA = uC, mC = uA
  -- So h_Theta_lt is: uC * Θ(rA) < uA * Θ(rC)
  -- Use ring to reorder multiplication
  have h_rewrite : R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ * ↑uC =
                   (uC : ℝ) * R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ := by ring
  have h_rewrite' : R.Θ_grid ⟨mu F rC, mu_mem_kGrid F rC⟩ * ↑uA =
                    (uA : ℝ) * R.Θ_grid ⟨mu F rC, mu_mem_kGrid F rC⟩ := by ring
  rw [h_rewrite, h_rewrite']
  -- Now goal is: uC * Θ(rA) < uA * Θ(rC), which is exactly h_Theta_lt
  exact h_Theta_lt

/-- **Separation property (A < B)**: When B ≠ ∅, A-statistics are strictly less than B-statistics.

This is the key refinement of separation_property for the B ≠ ∅ case.
-/
lemma separation_property_A_B {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (H : GridComm F) {d : α} (hd : ident < d)
    {rA : Multi k} {uA : ℕ} (huA : 0 < uA) (hrA : rA ∈ extensionSetA F d uA)
    {rB : Multi k} {uB : ℕ} (huB : 0 < uB) (hrB : rB ∈ extensionSetB F d uB) :
    separationStatistic R rA uA huA < separationStatistic R rB uB huB := by
  -- Derive GridBridge from mu_scale_eq_iterate (same pattern as separation_property)
  have IH : GridBridge F := ⟨fun r n => mu_scale_eq_iterate R H r n⟩
  unfold separationStatistic extensionSetA extensionSetB at *
  -- Extract the key inequalities
  have hA_lt : mu F rA < iterate_op d uA := hrA
  have hB_eq : mu F rB = iterate_op d uB := hrB

  -- Scale to common denominator Δ = uA * uB
  let Δ := uA * uB
  have hΔ_pos : 0 < Δ := Nat.mul_pos huA huB
  let mA := uB  -- Δ / uA
  let mB := uA  -- Δ / uB

  -- Step 1: Scale A inequality
  -- From μ(F,rA) < d^uA, get (μ(F,rA))^mA < d^Δ
  have hA_scaled : iterate_op (mu F rA) mA < iterate_op d Δ := by
    have : iterate_op (mu F rA) (1 * mA) < iterate_op d (uA * mA) :=
      repetition_lemma_lt (mu F rA) d 1 uA mA huB (by rwa [iterate_op_one])
    simpa [Nat.one_mul] using this

  -- Step 2: Use B equality to get d^Δ = (μ(F,rB))^mB
  -- d^Δ = d^{uA*uB} = (d^uB)^uA = (μ(F,rB))^uA = (μ(F,rB))^mB
  have hB_scaled : iterate_op d Δ = iterate_op (mu F rB) mB := by
    calc iterate_op d Δ
        = iterate_op d (uA * uB) := rfl
      _ = iterate_op d (uB * uA) := by ring_nf
      _ = iterate_op (iterate_op d uB) uA := (iterate_op_mul d uB uA).symm
      _ = iterate_op (mu F rB) uA := by rw [hB_eq]
      _ = iterate_op (mu F rB) mB := rfl

  -- Step 3: Transitivity gives (μ(F,rA))^mA < (μ(F,rB))^mB
  have h_iter_lt : iterate_op (mu F rA) mA < iterate_op (mu F rB) mB := by
    rw [← hB_scaled]; exact hA_scaled

  -- Step 4: Use GridBridge (IH) and Θ to get statistic inequality
  have h_grid_lt : mu F (scaleMult mA rA) < mu F (scaleMult mB rB) := by
    have hA_bridge : mu F (scaleMult mA rA) = iterate_op (mu F rA) mA :=
      IH.bridge rA mA
    have hB_bridge : mu F (scaleMult mB rB) = iterate_op (mu F rB) mB :=
      IH.bridge rB mB
    rw [hA_bridge, hB_bridge]
    exact h_iter_lt

  have h_Theta_lt : R.Θ_grid ⟨mu F (scaleMult mA rA), mu_mem_kGrid F _⟩ <
                    R.Θ_grid ⟨mu F (scaleMult mB rB), mu_mem_kGrid F _⟩ :=
    R.strictMono h_grid_lt

  -- Step 5: Apply Theta_scaleMult
  have hA_theta : R.Θ_grid ⟨mu F (scaleMult mA rA), mu_mem_kGrid F _⟩ =
                  mA * R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ :=
    Theta_scaleMult R rA mA
  have hB_theta : R.Θ_grid ⟨mu F (scaleMult mB rB), mu_mem_kGrid F _⟩ =
                  mB * R.Θ_grid ⟨mu F rB, mu_mem_kGrid F rB⟩ :=
    Theta_scaleMult R rB mB

  rw [hA_theta, hB_theta] at h_Theta_lt

  -- Step 6: Divide to get statistic inequality
  have huA_pos_real : (0 : ℝ) < uA := Nat.cast_pos.mpr huA
  have huB_pos_real : (0 : ℝ) < uB := Nat.cast_pos.mpr huB

  rw [div_lt_div_iff₀ huA_pos_real huB_pos_real]
  have h_rewrite : R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ * ↑uB =
                   (uB : ℝ) * R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ := by ring
  have h_rewrite' : R.Θ_grid ⟨mu F rB, mu_mem_kGrid F rB⟩ * ↑uA =
                    (uA : ℝ) * R.Θ_grid ⟨mu F rB, mu_mem_kGrid F rB⟩ := by ring
  rw [h_rewrite, h_rewrite']
  exact h_Theta_lt

/-- **Separation property (B < C)**: When B ≠ ∅, B-statistics are strictly less than C-statistics.

This is the key refinement of separation_property for the B ≠ ∅ case.
-/
lemma separation_property_B_C {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (H : GridComm F) {d : α} (hd : ident < d)
    {rB : Multi k} {uB : ℕ} (huB : 0 < uB) (hrB : rB ∈ extensionSetB F d uB)
    {rC : Multi k} {uC : ℕ} (huC : 0 < uC) (hrC : rC ∈ extensionSetC F d uC) :
    separationStatistic R rB uB huB < separationStatistic R rC uC huC := by
  -- Derive GridBridge from mu_scale_eq_iterate (same pattern as separation_property)
  have IH : GridBridge F := ⟨fun r n => mu_scale_eq_iterate R H r n⟩
  unfold separationStatistic extensionSetB extensionSetC at *
  -- Extract the key inequalities
  have hB_eq : mu F rB = iterate_op d uB := hrB
  have hC_gt : mu F rC > iterate_op d uC := hrC

  -- Scale to common denominator Δ = uB * uC
  let Δ := uB * uC
  have hΔ_pos : 0 < Δ := Nat.mul_pos huB huC
  let mB := uC  -- Δ / uB
  let mC := uB  -- Δ / uC

  -- Step 1: Use B equality to get (μ(F,rB))^mB = d^Δ
  have hB_scaled : iterate_op (mu F rB) mB = iterate_op d Δ := by
    calc iterate_op (mu F rB) mB
        = iterate_op (mu F rB) uC := rfl
      _ = iterate_op (iterate_op d uB) uC := by rw [hB_eq]
      _ = iterate_op d (uB * uC) := iterate_op_mul d uB uC
      _ = iterate_op d Δ := rfl

  -- Step 2: Scale C inequality
  -- From d^uC < μ(F,rC), get d^Δ < (μ(F,rC))^mC
  have hC_scaled : iterate_op d Δ < iterate_op (mu F rC) mC := by
    have : iterate_op d (uC * mC) < iterate_op (mu F rC) (1 * mC) :=
      repetition_lemma_lt d (mu F rC) uC 1 mC huB (by rwa [iterate_op_one])
    simp only [Nat.one_mul] at this
    convert this using 2
    ring

  -- Step 3: Transitivity gives (μ(F,rB))^mB < (μ(F,rC))^mC
  have h_iter_lt : iterate_op (mu F rB) mB < iterate_op (mu F rC) mC := by
    rw [hB_scaled]; exact hC_scaled

  -- Step 4: Use GridBridge (IH) and Θ to get statistic inequality
  have h_grid_lt : mu F (scaleMult mB rB) < mu F (scaleMult mC rC) := by
    have hB_bridge : mu F (scaleMult mB rB) = iterate_op (mu F rB) mB :=
      IH.bridge rB mB
    have hC_bridge : mu F (scaleMult mC rC) = iterate_op (mu F rC) mC :=
      IH.bridge rC mC
    rw [hB_bridge, hC_bridge]
    exact h_iter_lt

  have h_Theta_lt : R.Θ_grid ⟨mu F (scaleMult mB rB), mu_mem_kGrid F _⟩ <
                    R.Θ_grid ⟨mu F (scaleMult mC rC), mu_mem_kGrid F _⟩ :=
    R.strictMono h_grid_lt

  -- Step 5: Apply Theta_scaleMult
  have hB_theta : R.Θ_grid ⟨mu F (scaleMult mB rB), mu_mem_kGrid F _⟩ =
                  mB * R.Θ_grid ⟨mu F rB, mu_mem_kGrid F rB⟩ :=
    Theta_scaleMult R rB mB
  have hC_theta : R.Θ_grid ⟨mu F (scaleMult mC rC), mu_mem_kGrid F _⟩ =
                  mC * R.Θ_grid ⟨mu F rC, mu_mem_kGrid F rC⟩ :=
    Theta_scaleMult R rC mC

  rw [hB_theta, hC_theta] at h_Theta_lt

  -- Step 6: Divide to get statistic inequality
  have huB_pos_real : (0 : ℝ) < uB := Nat.cast_pos.mpr huB
  have huC_pos_real : (0 : ℝ) < uC := Nat.cast_pos.mpr huC

  rw [div_lt_div_iff₀ huB_pos_real huC_pos_real]
  have h_rewrite : R.Θ_grid ⟨mu F rB, mu_mem_kGrid F rB⟩ * ↑uC =
                   (uC : ℝ) * R.Θ_grid ⟨mu F rB, mu_mem_kGrid F rB⟩ := by ring
  have h_rewrite' : R.Θ_grid ⟨mu F rC, mu_mem_kGrid F rC⟩ * ↑uB =
                    (uB : ℝ) * R.Θ_grid ⟨mu F rC, mu_mem_kGrid F rC⟩ := by ring
  rw [h_rewrite, h_rewrite']
  exact h_Theta_lt

/-- For B empty: any A-witness statistic is ≤ δ. -/
lemma A_stat_le_delta_of_B_empty {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (H : GridComm F) (IH : GridBridge F) {d : α} (hd : ident < d)
    (hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u)
    (hA_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u)
    (hC_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u)
    {r : Multi k} {u : ℕ} (hu : 0 < u) (hrA : r ∈ extensionSetA F d u) :
    separationStatistic R r u hu ≤
      B_empty_delta (R:=R) (F:=F) d hd hB_empty hA_nonempty hC_nonempty := by
  classical
  -- δ is defined as sSup of A-statistics; we need to show our statistic is ≤ this sSup
  unfold B_empty_delta separationStatistic

  -- The set being supremumed
  let AStats := {s : ℝ | ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u ∧
                          s = R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / u}

  -- Our statistic is in AStats
  have h_in_set : R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / u ∈ AStats := by
    exact ⟨r, u, hu, hrA, rfl⟩

  -- Need to show AStats is bounded above to use le_csSup
  have h_bdd : BddAbove AStats := by
    -- Use C-witness to provide upper bound
    rcases hC_nonempty with ⟨rC, uC, huC, hrC⟩
    let σC := separationStatistic R rC uC huC
    refine ⟨σC, ?_⟩
    intro s hs
    rcases hs with ⟨r', u', hu', hrA', rfl⟩
    -- Every A-statistic is strictly below any C-statistic
    exact le_of_lt (separation_property R H IH hd hu' hrA' huC hrC)

  -- Apply le_csSup
  exact le_csSup h_bdd h_in_set

/-- For B empty: δ is ≤ any C-witness statistic. -/
lemma delta_le_C_stat_of_B_empty {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (H : GridComm F) (IH : GridBridge F) {d : α} (hd : ident < d)
    (hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u)
    (hA_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u)
    (hC_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u)
    {r : Multi k} {u : ℕ} (hu : 0 < u) (hrC : r ∈ extensionSetC F d u) :
    B_empty_delta (R:=R) (F:=F) d hd hB_empty hA_nonempty hC_nonempty ≤
      separationStatistic R r u hu := by
  classical
  -- δ = sSup(AStats); we need to show sSup(AStats) ≤ σC
  unfold B_empty_delta

  let AStats := {s : ℝ | ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u ∧
                          s = R.Θ_grid ⟨mu F r, mu_mem_kGrid F r⟩ / u}

  -- Use csSup_le: need to show every A-stat ≤ σC
  have h_nonempty : AStats.Nonempty := by
    rcases hA_nonempty with ⟨rA, uA, huA, hrA⟩
    use R.Θ_grid ⟨mu F rA, mu_mem_kGrid F rA⟩ / uA
    use rA, uA, huA, hrA

  apply csSup_le h_nonempty
  intro s hs
  rcases hs with ⟨r', u', hu', hrA', rfl⟩
  -- Need: σ(r',u') ≤ σ(r,u) where r'∈A, r∈C
  -- This follows from separation property: all A-stats < all C-stats
  exact le_of_lt (separation_property R H IH hd hu' hrA' hu hrC)

/-- The accuracy lemma: δ is pinned by the A/C gap arbitrarily precisely.

    **Proof sketch** (from K&S):
    1. Pick any reference atom a from the family F.
    2. Use Archimedean property: there exists N such that d < a^N.
    3. For any ε > 0, choose m large enough that 1/m < ε.
    4. Find the crossing point: max n such that a^n ≤ d^m.
    5. Then n/m and (n+1)/m bracket δ with gap < ε.
-/
theorem accuracy_lemma {k : ℕ} {F : AtomFamily α k} (R : MultiGridRep F)
    (d : α) (hd : ident < d)
    (hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB F d u)
    (hA_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetA F d u)
    (hC_nonempty : ∃ r u, 0 < u ∧ r ∈ extensionSetC F d u)
    (ε : ℝ) (hε : 0 < ε) :
    ∃ (rA : Multi k) (uA : ℕ) (huA : 0 < uA) (hrA : rA ∈ extensionSetA F d uA)
      (rC : Multi k) (uC : ℕ) (huC : 0 < uC) (hrC : rC ∈ extensionSetC F d uC),
      separationStatistic R rC uC huC - separationStatistic R rA uA huA < ε := by
  classical
  -- The k = 0 case is impossible under the hypotheses (C cannot be non-empty).
  -- We discharge it via contradiction and rely on the k.succ branch for the real work.
  cases k with
  | zero =>
    -- With no atoms, μ(F, r) = ident for all r, so C cannot contain a witness.
    have hcontr : False := by
      rcases hC_nonempty with ⟨rC, uC, huC, hrC⟩
      have hmu : mu F rC = ident := by simp [mu]
      have hpos : ident < iterate_op d uC := iterate_op_pos d hd _ huC
      have hlt : iterate_op d uC < ident := by simpa [extensionSetC, hmu] using hrC
      exact (lt_asymm hpos hlt).elim
    exact (False.elim hcontr)
  | succ k =>
    -- Choose a reference atom and its Θ-value on the grid.
    let i0 : Fin (k + 1) := ⟨0, Nat.succ_pos _⟩
    let a : α := F.atoms i0
    have ha : ident < a := F.pos i0
    have hmu_one : mu F (unitMulti i0 1) = a := by
      simpa [a, iterate_op_one] using mu_unitMulti F i0 1
    let θatom : ℝ := R.Θ_grid ⟨mu F (unitMulti i0 1), mu_mem_kGrid F (unitMulti i0 1)⟩
    -- θatom is positive because Θ is strictly monotone and Θ(ident) = 0.
    have hθ_pos : 0 < θatom := by
      have hlt :
          R.Θ_grid ⟨ident, ident_mem_kGrid F⟩ <
            R.Θ_grid ⟨mu F (unitMulti i0 1), mu_mem_kGrid F (unitMulti i0 1)⟩ := by
        have hbase : ident < mu F (unitMulti i0 1) := by simpa [hmu_one] using ha
        exact R.strictMono hbase
      have hzero : R.Θ_grid ⟨ident, ident_mem_kGrid F⟩ = 0 := R.ident_eq_zero
      linarith

    -- Pick a large denominator U so that θatom / U < ε.
    obtain ⟨N, hN⟩ := exists_nat_gt (θatom / ε)
    let U : ℕ := Nat.succ N
    have hUpos : 0 < U := Nat.succ_pos _
    have hU_gt : θatom / ε < (U : ℝ) := by
      have hle : (N : ℝ) ≤ (U : ℝ) := by exact_mod_cast Nat.le_succ N
      exact lt_of_lt_of_le hN hle
    have hθ_lt : θatom < (U : ℝ) * ε := by
      have h := mul_lt_mul_of_pos_right hU_gt hε
      have hε_ne : (ε : ℝ) ≠ 0 := ne_of_gt hε
      have hleft : θatom / ε * ε = θatom := by field_simp [hε_ne]
      simpa [hleft, mul_comm] using h
    have hgap : θatom / (U : ℝ) < ε := by
      have hUpos_real : 0 < (U : ℝ) := by exact_mod_cast hUpos
      have hU_ne : (U : ℝ) ≠ 0 := by exact_mod_cast (ne_of_gt hUpos)
      have hθ_lt' : θatom < ε * (U : ℝ) := by simpa [mul_comm] using hθ_lt
      have hpos_inv : 0 < (1 / (U : ℝ)) := one_div_pos.mpr hUpos_real
      have h := mul_lt_mul_of_pos_right hθ_lt' hpos_inv
      have hleft : θatom * (1 / (U : ℝ)) = θatom / (U : ℝ) := by field_simp [hU_ne]
      have hright : ε * (U : ℝ) * (1 / (U : ℝ)) = ε := by field_simp [hU_ne]
      simpa [hleft, hright, mul_left_comm, mul_assoc] using h

    -- Find the crossing index n with a^n ≤ d^U < a^{n+1}.
    obtain ⟨K, hK⟩ := bounded_by_iterate a ha (iterate_op d U)
    let P : ℕ → Prop := fun n => iterate_op a n ≤ iterate_op d U
    have hP0 : P 0 := by
      have hpos : ident < iterate_op d U := iterate_op_pos d hd _ hUpos
      have hle : ident ≤ iterate_op d U := le_of_lt hpos
      simpa [P, iterate_op_zero] using hle
    have hcross := findGreatest_crossing (P := P) K hP0
    let n := Nat.findGreatest P K
    have hPn : P n := hcross.1
    have hn_le_K : n ≤ K := hcross.2.1
    have hn_lt_K : n < K := by
      have hle : iterate_op a n ≤ iterate_op d U := hPn
      have hlt : iterate_op d U < iterate_op a K := hK
      have hneq : n ≠ K := by
        intro hEq
        have hle' : iterate_op a K ≤ iterate_op d U := by simpa [hEq] using hle
        exact (not_le_of_gt hlt) hle'
      exact lt_of_le_of_ne hn_le_K hneq
    have h_notP_succ : ¬ P (n + 1) :=
      hcross.2.2 (n + 1) (Nat.lt_succ_self _) (Nat.succ_le_of_lt hn_lt_K)

    -- Translate P-information to A/C membership.
    have hPn_le : iterate_op a n ≤ iterate_op d U := hPn
    have hnotB : unitMulti i0 n ∉ extensionSetB F d U := hB_empty _ _ hUpos
    have hPn_lt : iterate_op a n < iterate_op d U := by
      have hne : iterate_op a n ≠ iterate_op d U := by
        intro hEq
        apply hnotB
        simpa [extensionSetB, Set.mem_setOf_eq, mu_unitMulti F i0 n] using hEq
      exact lt_of_le_of_ne hPn_le hne
    have hsucc_lt : iterate_op d U < iterate_op a (n + 1) := lt_of_not_ge h_notP_succ

    -- Build A and C witnesses.
    let rA := unitMulti i0 n
    let rC := unitMulti i0 (n + 1)
    have hrA : rA ∈ extensionSetA F d U := by
      simpa [rA, extensionSetA, mu_unitMulti] using hPn_lt
    have hrC : rC ∈ extensionSetC F d U := by
      simpa [rC, extensionSetC, mu_unitMulti] using hsucc_lt

    -- Separation statistics for the two witnesses.
    have h_sepA :
        separationStatistic R rA U hUpos =
          (n : ℝ) * θatom / (U : ℝ) := by
      unfold rA separationStatistic
      have hθ := Theta_unitMulti (R := R) (F := F) i0 n
      -- Simplify using the scaling lemma
      simpa [θatom] using hθ
    have h_sepC :
        separationStatistic R rC U hUpos =
          (n + 1 : ℝ) * θatom / (U : ℝ) := by
      unfold rC separationStatistic
      have hθ := Theta_unitMulti (R := R) (F := F) i0 (n + 1)
      simpa [θatom] using hθ

    -- Gap computation: σ_C - σ_A = θatom / U < ε.
    refine ⟨rA, U, hUpos, hrA, rC, U, hUpos, hrC, ?_⟩
    have hgap_exact :
        separationStatistic R rC U hUpos - separationStatistic R rA U hUpos =
          θatom / (U : ℝ) := by
      rw [h_sepA, h_sepC]
      ring
    nlinarith [hgap_exact, hgap]


end Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA
