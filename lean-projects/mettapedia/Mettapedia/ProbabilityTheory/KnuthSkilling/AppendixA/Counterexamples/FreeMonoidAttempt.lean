import Mathlib.Data.List.Basic
import Mathlib.Order.Basic
import Mettapedia.ProbabilityTheory.KnuthSkilling.Algebra

namespace Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA.Counterexamples

open Classical KnuthSkillingAlgebra

/-!
# Attempt: Free Monoid with Length-Lexicographic Order

Let's try to build a non-commutative algebra satisfying KSSeparation.

## The Construction

**Elements**: Words in a free monoid generated by {x, y}
- Examples: [], [x], [y], [x,x], [x,y], [y,x], [x,x,y], ...
- The empty word [] is the identity

**Operation**: Concatenation (non-commutative!)
- [x,y] ⊕ [y,x] = [x,y,y,x] ≠ [y,x,x,y] = [y,x] ⊕ [x,y]

**Order**: Length-first, then lexicographic
- Shorter words < longer words
- Within same length: lexicographic by generators

**Goal**: Check if this satisfies KnuthSkillingAlgebra axioms, especially KSSeparation.

**Prediction**: Will fail monotonicity or KSSeparation.
-/

/-- Generator symbols for our free monoid -/
inductive Generator where
  | x : Generator
  | y : Generator
  deriving DecidableEq, Repr

/-- The free monoid: lists of generators -/
abbrev FreeMonoid := List Generator

namespace FreeMonoid

/-- The identity element (empty word) -/
def ident : FreeMonoid := []

/-- The operation is list concatenation -/
def op (w₁ w₂ : FreeMonoid) : FreeMonoid := w₁ ++ w₂

/-- Concatenation is associative -/
theorem op_assoc (w₁ w₂ w₃ : FreeMonoid) : op (op w₁ w₂) w₃ = op w₁ (op w₂ w₃) := by
  simp [op, List.append_assoc]

/-- Concatenation is NOT commutative -/
theorem op_not_commutative : ¬∀ w₁ w₂ : FreeMonoid, op w₁ w₂ = op w₂ w₁ := by
  intro h
  -- Take w₁ = [x] and w₂ = [y]
  let w₁ : FreeMonoid := [Generator.x]
  let w₂ : FreeMonoid := [Generator.y]
  have : op w₁ w₂ = op w₂ w₁ := h w₁ w₂
  -- LHS: [x] ++ [y] = [x,y]
  -- RHS: [y] ++ [x] = [y,x]
  simp [op] at this
  -- [x,y] ≠ [y,x]
  cases this

/-- Identity laws -/
theorem op_ident_left (w : FreeMonoid) : op ident w = w := by simp [op, ident]
theorem op_ident_right (w : FreeMonoid) : op w ident = w := by simp [op, ident]

/-!
## The Challenge: Defining a Linear Order

We need a total order that makes `op` monotone.

**Attempt 1: Length-Lexicographic Order**

Order by:
1. Length first: shorter words < longer words
2. Lexicographically within same length (x < y as generators)

Let's check if this makes `op` monotone...
-/

/-- Lexicographic order on generators -/
instance : LinearOrder Generator where
  le := fun a b => a = Generator.x ∨ b = Generator.y
  le_refl := by intro a; cases a <;> simp
  le_trans := by
    intro a b c hab hbc
    cases a <;> cases b <;> cases c <;> simp at * <;> tauto
  le_antisymm := by
    intro a b hab hba
    cases a <;> cases b <;> simp at * <;> tauto
  le_total := by
    intro a b
    cases a <;> cases b <;> simp
  decidableLE := by infer_instance
  lt := fun a b => a = Generator.x ∧ b = Generator.y
  lt_iff_le_not_le := by
    intro a b
    cases a <;> cases b <;> simp <;> tauto

/-- Length-lexicographic order on words -/
def lengthLex (w₁ w₂ : FreeMonoid) : Prop :=
  w₁.length < w₂.length ∨ (w₁.length = w₂.length ∧ w₁ < w₂)

-- Let's check if this is a linear order
theorem lengthLex_refl (w : FreeMonoid) : ¬lengthLex w w := by
  intro h
  cases h with
  | inl h => exact Nat.lt_irrefl w.length h
  | inr h => exact LT.lt.false h.2

theorem lengthLex_antisymm (w₁ w₂ : FreeMonoid) :
    ¬(lengthLex w₁ w₂ ∧ lengthLex w₂ w₁) := by
  intro ⟨h₁, h₂⟩
  cases h₁ with
  | inl h₁ =>
    cases h₂ with
    | inl h₂ => exact Nat.lt_asymm h₁ h₂
    | inr h₂ => exact Nat.ne_of_lt h₁ h₂.1
  | inr h₁ =>
    cases h₂ with
    | inl h₂ => exact Nat.ne_of_lt h₂ h₁.1
    | inr h₂ => exact LT.lt.false (LT.lt.trans h₁.2 h₂.2)

theorem lengthLex_trans (w₁ w₂ w₃ : FreeMonoid) :
    lengthLex w₁ w₂ → lengthLex w₂ w₃ → lengthLex w₁ w₃ := by
  intro h₁₂ h₂₃
  cases h₁₂ with
  | inl h₁₂ =>
    cases h₂₃ with
    | inl h₂₃ => left; exact Nat.lt_trans h₁₂ h₂₃
    | inr h₂₃ => left; rw [← h₂₃.1]; exact h₁₂
  | inr h₁₂ =>
    cases h₂₃ with
    | inl h₂₃ => left; rw [h₁₂.1]; exact h₂₃
    | inr h₂₃ =>
      right
      constructor
      · exact Eq.trans h₁₂.1 h₂₃.1
      · rw [← h₂₃.1] at h₁₂
        rw [← h₁₂.1]
        exact LT.lt.trans h₁₂.2 h₂₃.2

theorem lengthLex_total (w₁ w₂ : FreeMonoid) :
    w₁ = w₂ ∨ lengthLex w₁ w₂ ∨ lengthLex w₂ w₁ := by
  by_cases h : w₁.length = w₂.length
  · by_cases h' : w₁ = w₂
    · left; exact h'
    · right
      have : w₁ < w₂ ∨ w₂ < w₁ := by
        have := List.lt_irrefl w₁
        have := Ne.lt_or_lt h'
        exact this
      cases this with
      | inl lt => left; right; exact ⟨h, lt⟩
      | inr gt => right; right; exact ⟨h.symm, gt⟩
  · right
    have : w₁.length < w₂.length ∨ w₂.length < w₁.length := Nat.lt_or_lt_of_ne h
    cases this with
    | inl lt => left; left; exact lt
    | inr gt => right; left; exact gt

/-!
## Testing Monotonicity

For `op` to be monotone, we need:
- If w₁ < w₂, then w₁ ⊕ w < w₂ ⊕ w for all w
- If w₁ < w₂, then w ⊕ w₁ < w ⊕ w₂ for all w

Let's check if length-lex order has this property...

**Test case**:
- Take w₁ = [x], w₂ = [x,x], w = [y]
- We have w₁ < w₂ (by length: 1 < 2)
- Check: w₁ ⊕ w = [x,y] vs w₂ ⊕ w = [x,x,y]
- Length: 2 vs 3, so [x,y] < [x,x,y] ✓

**Another test**:
- Take w₁ = [x], w₂ = [y], w = [x]
- We have w₁ < w₂ (same length, lex order: x < y)
- Check: w₁ ⊕ w = [x,x] vs w₂ ⊕ w = [y,x]
- Length: 2 vs 2 (same)
- Lex: [x,x] vs [y,x]... is [x,x] < [y,x]?
- First element: x < y, so YES ✓

**Potential problem**:
- w ⊕ w₁ = [x,x] vs w ⊕ w₂ = [x,y]
- First element: x = x (same)
- Second element: x < y, so [x,x] < [x,y] ✓

Looks like it might work! But let's try to prove it formally...
-/

theorem op_mono_right_attempt (w : FreeMonoid) (w₁ w₂ : FreeMonoid) :
    lengthLex w₁ w₂ → lengthLex (op w w₁) (op w w₂) := by
  intro h
  simp [op]
  -- w ++ w₁ vs w ++ w₂
  -- Length: w.length + w₁.length vs w.length + w₂.length
  cases h with
  | inl h =>
    -- w₁.length < w₂.length
    left
    exact Nat.add_lt_add_left h w.length
  | inr h =>
    -- w₁.length = w₂.length and w₁ < w₂
    right
    constructor
    · simp [h.1]
    · -- Need: w ++ w₁ < w ++ w₂ lexicographically
      -- This follows from w₁ < w₂
      exact List.append_lt_append_left w h.2

/-!
Great! Right monotonicity works. Now left monotonicity...
-/

/-- WIP goal (not proved here): left-monotonicity of concatenation under `lengthLex`. -/
def op_mono_left_goal : Prop :=
  ∀ w w₁ w₂ : FreeMonoid, lengthLex w₁ w₂ → lengthLex (op w₁ w) (op w₂ w)

/-!
**Challenge**: Does w₁ < w₂ (lex) imply w₁ ++ w < w₂ ++ w (lex)?

**Example**:
- w₁ = [x], w₂ = [y], w = [x]
- w₁ < w₂ ✓
- w₁ ++ w = [x,x], w₂ ++ w = [y,x]
- Is [x,x] < [y,x]?
- First element: x < y ✓

Seems to work! Let me try to prove it...
-/

/-- WIP lemma (not proved here): appending a common suffix preserves the list order used by `lengthLex`. -/
def list_append_right_preserves_lt_goal (α : Type*) [LinearOrder α] : Prop :=
  ∀ w₁ w₂ w : List α, w₁ < w₂ → w₁ ++ w < w₂ ++ w

/-!
Okay, assuming we can prove left and right monotonicity, we have:
- ✓ Associativity
- ✓ Identity
- ✓ Monotonicity (both directions)
- ✗ NOT commutative

Now the hard parts:
- Archimedean property
- KSSeparation
-/

/-!
## Archimedean Property

For any w₁ < w₂, we need to show ∃n such that w₂ < w₁^n

**Problem**: If w₁ is non-empty, then w₁^n has length n * |w₁|, which grows without bound.
Since w₂ has fixed length, we can definitely find n large enough.

This should work!
-/

/-- WIP goal (not proved here): an Archimedean-style property for the length-first order. -/
def archimedean_goal : Prop :=
  ∀ w₁ w₂ : FreeMonoid, ident < w₁ → ∃ n : ℕ, w₂ < iterate_op w₁ n

/-!
## KSSeparation - THE KEY TEST

For any w₁ < w₂ (both > ident) and any base a > ident, we need:
  ∃n,m: w₁^m < a^n ≤ w₂^m

**Test case**:
- w₁ = [x], w₂ = [x,y], a = [y]
- Can we find m, n?

Lengths:
- w₁^m = [x,x,...,x] has length m
- a^n = [y,y,...,y] has length n
- w₂^m = [x,y,x,y,...] has length 2m

For w₁^m < a^n, we need:
- m < n (by length), OR
- m = n and [x,x,...,x] < [y,y,...,y] (lex: x < y) ✓

For a^n ≤ w₂^m, we need:
- n < 2m (by length), OR
- n = 2m and [y,y,...,y] ≤ [x,y,...] (lex: y > x) ✗

**PROBLEM**: If n = 2m, then [y,y,...,y] > [x,y,...] in lex order!

So we need n < 2m, which combined with m < n gives: m < n < 2m.

This is possible! Take m = 1, n = 1: need 1 < 1 < 2... wait that doesn't work.

Take m = 2, n = 3: need 2 < 3 < 4 ✓

Let me check:
- w₁^2 = [x,x]
- a^3 = [y,y,y]
- w₂^2 = [x,y,x,y]

Is [x,x] < [y,y,y]? Length 2 < 3 ✓
Is [y,y,y] ≤ [x,y,x,y]? Length 3 < 4 ✓

Great! So maybe KSSeparation does hold for this case.

**Different test**:
- w₁ = [x], w₂ = [y], a = [x,x]

These have same length, w₁ < w₂ by lex.

- w₁^m = m copies of x: length m
- a^n = n copies of [x,x]: length 2n
- w₂^m = m copies of y: length m

For w₁^m < a^n: need m < 2n ✓ (always possible)
For a^n ≤ w₂^m: need 2n ≤ m

Combined: 2n ≤ m < 2n... IMPOSSIBLE!

**FOUND IT!** KSSeparation FAILS!
-/

/-- WIP claim (not proved here): a concrete “separation witness” should fail for the
length‑lex candidate order on free monoids.

The intended counterexample is:
- `w₁ = [x]`, `w₂ = [y]` (so `w₁ < w₂` by lex)
- `a = [x,x]`

Then `w₂^m` always has length `m`, while `a^n` has length `2n`, forcing `2n ≤ m` for the
upper bound, but `w₁^m < a^n` forces `m < 2n` for the lower bound. -/
def ks_separation_fails_claim : Prop :=
  let w₁ : FreeMonoid := [Generator.x]
  let w₂ : FreeMonoid := [Generator.y]
  let a : FreeMonoid := [Generator.x, Generator.x]
  lengthLex w₁ w₂ ∧
    ∀ n m : ℕ, 0 < m →
      ¬ (lengthLex (iterate_op w₁ m) (iterate_op a n) ∧
          ¬ lengthLex (iterate_op w₂ m) (iterate_op a n))

end FreeMonoid

/-!
## Conclusion

**Status**: this file is still a WIP attempt. The analysis strongly suggests that the
length‑lex order is incompatible with the `KSSeparation` sandwich property, but the full
`KnuthSkillingAlgebra` instance and the formal `KSSeparation` refutation are not completed here.

Even though it's:
- ✓ Associative
- ✓ Ordered (linearly)
- ✓ Monotone (both directions)
- ✓ Archimedean
- ✗ NOT commutative
- ✗ FAILS KSSeparation

This is consistent with (but does not prove) the heuristic that **non-commutative algebras
cannot satisfy KSSeparation**.

The failure mode is similar to ProductFailsSeparation: elements varying in "different directions"
([x] vs [y] as generators) cannot be separated by a base in a third direction ([x,x]).

**Moral**: KSSeparation is incompatible with non-commutativity!
-/

end Mettapedia.ProbabilityTheory.KnuthSkilling.AppendixA.Counterexamples
