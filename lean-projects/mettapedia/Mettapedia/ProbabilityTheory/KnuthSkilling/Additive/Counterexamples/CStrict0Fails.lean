import Mettapedia.ProbabilityTheory.KnuthSkilling.Additive.Proofs.GridInduction.Core.Induction.Construction
import Mettapedia.ProbabilityTheory.KnuthSkilling.Additive.Counterexamples.SemidirectNoSeparation


namespace Mettapedia.ProbabilityTheory.KnuthSkilling.Additive.Counterexamples

open Classical KnuthSkillingAlgebra
open Mettapedia.ProbabilityTheory.KnuthSkilling.Additive

namespace SD

/-- Convenience: the unique index of `Fin 1`. -/
def i0 : Fin 1 := ⟨0, by decide⟩

lemma baseA_pos : (ident : SD) < SD.baseA := by
  simpa [SD.ident] using (WithBot.bot_lt_iff_ne_bot (x := SD.baseA)).2 (by simp [SD.baseA])

lemma exY_pos : (ident : SD) < SD.exY := by
  simpa [SD.ident] using (WithBot.bot_lt_iff_ne_bot (x := SD.exY)).2 (by simp [SD.exY])

/-- The singleton atom family generated by `baseA = (1,1)`. -/
noncomputable def F1 : AtomFamily SD 1 :=
  singletonAtomFamily (α := SD) SD.baseA baseA_pos

/-- The canonical one-type representation on `F1`: Θ(a^n)=n. -/
noncomputable def R1 : MultiGridRep (F1) :=
  (oneTypeRep SD.baseA baseA_pos).toMulti

/-- Explicit `fst` of powers of `baseA` (first coordinate 1). -/
lemma fst_iterate_baseA (n : ℕ) : SD.fst (iterate_op SD.baseA n) = n := by
  -- reuse the generic lemma `fst_iterate_op_coe` from `SemidirectNoSeparation`
  let pA : SDBase := toLex ((1 : PNat), 1)
  have hpA : (pA.1 : ℕ) = 1 := by rfl
  have := SD.fst_iterate_op_coe (p := pA) n
  simpa [SD.baseA, pA, hpA] using this

/-- Explicit `fst` of powers of `exY` (first coordinate 2). -/
lemma fst_iterate_exY (n : ℕ) : SD.fst (iterate_op SD.exY n) = 2 * n := by
  let pD : SDBase := toLex ((2 : PNat), 1)
  have hpD : (pD.1 : ℕ) = 2 := by rfl
  have := SD.fst_iterate_op_coe (p := pD) n
  -- `fst_iterate_op_coe` gives `n * 2`; rewrite to `2 * n` for convenience.
  simpa [SD.exY, pD, hpD, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc] using this

/-- In the one-type representation built from `oneTypeRep`, Θ(a^n)=n on the singleton grid. -/
lemma theta_pow_baseA (n : ℕ) :
    (SD.R1).Θ_grid ⟨iterate_op SD.baseA n, by
      -- `iterate_op baseA n` lies on the singleton k-grid
      refine ⟨(fun _ : Fin 1 => n), ?_⟩
      simp [SD.F1, mu_singleton, SD.baseA]⟩ = (n : ℝ) := by
  classical
  -- Unfold the transport `OneTypeGridRep.toMulti` and reduce to `Θ₁_on_power`.
  unfold SD.R1
  -- `toMulti` defines `Θ_grid` by composing the one-type `Θ_grid` with `toGrid`.
  simp [OneTypeGridRep.toMulti, SD.F1, SD.baseA, oneTypeRep, Θ₁, gridIndex_iterate_op]

end SD

/-!
## A concrete failure of `C_strict0`

In `SD` (a non-`KSSeparation` model), take:
- old grid generator `a := (1,1)` with Θ(a^n)=n,
- new atom `d := (2,1)`.

Then the B-empty `chooseδ` is `2`, but `a^2 ∈ C(1)` and has statistic `2`.
So the strict C-side inaccessibility property (our `BEmptyExtensionExtra.C_strict0`) fails.
-/

theorem C_strict0_fails_semidirect :
    ∃ (r : Multi 1) (u : ℕ) (hu : 0 < u),
      r ∈ extensionSetC (SD.F1) SD.exY u ∧
        chooseδ (α := SD) (hk := (le_rfl : (1 : ℕ) ≥ 1)) (SD.R1) SD.exY SD.exY_pos =
          separationStatistic (SD.R1) r u hu := by
  classical
  -- We use the witness r=2 at u=1.
  refine ⟨(fun _ => 2), 1, Nat.one_pos, ?_, ?_⟩
  · -- Show `d < a^2`.
    have hd_lt_a2 : iterate_op SD.exY 1 < iterate_op SD.baseA 2 := by
      -- Compute both sides concretely and decide.
      simpa [KnuthSkillingAlgebra.iterate_op_one, KnuthSkillingAlgebra.iterate_op, KnuthSkillingAlgebraBase.op,
        SD.op, SD.baseOp, SD.exY, SD.baseA] using
        (show (SD.exY : SD) < KnuthSkillingAlgebraBase.op SD.baseA SD.baseA by
          simp [KnuthSkillingAlgebraBase.op, SD.op, SD.baseOp, SD.exY, SD.baseA]
          decide)
    -- Pack as C-membership.
    have hμ2 : mu (SD.F1) (fun _ : Fin 1 => 2) = iterate_op SD.baseA 2 := by
      simpa [SD.F1, mu_singleton_eval, SD.baseA, SD.i0] using
        (mu_singleton_eval (a := SD.baseA) SD.baseA_pos (fun _ : Fin 1 => 2))
    -- `iterate_op d 1 = d` and `μ(r2)=a^2`.
    simpa [extensionSetC, Set.mem_setOf_eq, hμ2] using hd_lt_a2
  · -- Compute `chooseδ` and the statistic: both are `2`.
    -- First, show the B-set is empty: there is no solution to `a^n = d^u`.
    have hB_empty : ∀ r u, 0 < u → r ∉ extensionSetB (SD.F1) SD.exY u := by
      intro r u hu hrB
      have hEq : mu (SD.F1) r = iterate_op SD.exY u := by
        simpa [extensionSetB, Set.mem_setOf_eq] using hrB
      -- Reduce `mu` to a power of `baseA` and compare `fst`.
      have hμ : mu (SD.F1) r = iterate_op SD.baseA (r SD.i0) := by
        simpa [SD.F1, mu_singleton_eval, SD.baseA, SD.i0] using (mu_singleton_eval (a := SD.baseA) SD.baseA_pos r)
      have hfst : SD.fst (iterate_op SD.baseA (r SD.i0)) = SD.fst (iterate_op SD.exY u) := by
        simpa [hμ] using congrArg SD.fst hEq
      have hru : r SD.i0 = 2 * u := by
        simpa [SD.fst_iterate_baseA, SD.fst_iterate_exY] using hfst
      -- But we also have `d < a^2`, so `d^u < (a^2)^u = a^(2u)`; hence equality is impossible.
      have hbase : (SD.exY : SD) < iterate_op SD.baseA 2 := by
        -- reuse the explicit computation `d < a^2`
        have : iterate_op SD.exY 1 < iterate_op SD.baseA 2 := by
          -- `d < a^2` as above
          simpa [KnuthSkillingAlgebra.iterate_op_one] using
            (show (SD.exY : SD) < iterate_op SD.baseA 2 by
              -- compute `a^2 = a ⊕ a`
              simpa [KnuthSkillingAlgebra.iterate_op, KnuthSkillingAlgebraBase.op, SD.op, SD.baseOp, SD.exY, SD.baseA]
                using (show (SD.exY : SD) < KnuthSkillingAlgebraBase.op SD.baseA SD.baseA by
                  simp [KnuthSkillingAlgebraBase.op, SD.op, SD.baseOp, SD.exY, SD.baseA]
                  decide))
        simpa [KnuthSkillingAlgebra.iterate_op_one] using this
      have hlt' : iterate_op SD.exY u < iterate_op SD.baseA (2 * u) := by
        have := KnuthSkillingAlgebra.iterate_op_strictMono_base u hu SD.exY (iterate_op SD.baseA 2) hbase
        -- Rewrite `(a^2)^u = a^(2u)`
        simpa [KnuthSkillingAlgebra.iterate_op_mul, Nat.mul_comm, Nat.mul_left_comm, Nat.mul_assoc] using this
      have : iterate_op SD.exY u = iterate_op SD.baseA (2 * u) := by
        -- rewrite `mu` using `hru` and the B-equality witness
        have : mu (SD.F1) r = iterate_op SD.baseA (2 * u) := by
          simpa [hμ, hru]
        exact hEq.symm.trans this
      exact (ne_of_lt hlt') this

    -- Now compute `chooseδ` via DeltaSpec uniqueness: show `2` satisfies DeltaSpec.
    have IH' : GridBridge (singletonAtomFamily (α := SD) SD.baseA SD.baseA_pos) :=
      gridBridge_singleton (α := SD) SD.baseA SD.baseA_pos
    have IH : GridBridge (SD.F1) := by
      simpa [SD.F1] using IH'
    have H : GridComm (SD.F1) := gridComm_of_k_eq_one

    have hDelta2 : DeltaSpec (SD.F1) (SD.R1) SD.exY SD.exY_pos (2 : ℝ) := by
      refine ⟨?_, ?_, ?_⟩
      · -- A-bound: n/u ≤ 2
        intro r u hu hrA
        have hltμ : mu (SD.F1) r < iterate_op SD.exY u := by
          simpa [extensionSetA, Set.mem_setOf_eq] using hrA
        have hle_fst := SD.fst_le_of_lt (x := mu (SD.F1) r) (y := iterate_op SD.exY u) hltμ
        have hμ : mu (SD.F1) r = iterate_op SD.baseA (r SD.i0) := by
          simpa [SD.F1, mu_singleton_eval, SD.baseA, SD.i0] using (mu_singleton_eval (a := SD.baseA) SD.baseA_pos r)
        have hru : r SD.i0 ≤ 2 * u := by
          simpa [SD.fst_iterate_baseA, SD.fst_iterate_exY, hμ] using hle_fst
        -- Rewrite statistic as (r0)/u.
        have hθ : (SD.R1).Θ_grid ⟨mu (SD.F1) r, mu_mem_kGrid (SD.F1) r⟩ = (r SD.i0 : ℝ) := by
          -- reduce to Θ(a^n)=n
          have : mu (SD.F1) r = iterate_op SD.baseA (r SD.i0) := hμ
          -- rewrite the subtype point
          -- (simp works because `R1` is the transported one-type rep)
          simp [hμ, SD.theta_pow_baseA]
        have huℝ : (0 : ℝ) < (u : ℝ) := Nat.cast_pos.mpr hu
        have : (r SD.i0 : ℝ) / (u : ℝ) ≤ 2 := by
          have : (r SD.i0 : ℝ) ≤ 2 * (u : ℝ) := by exact_mod_cast hru
          exact (div_le_iff₀ huℝ).2 this
        simpa [separationStatistic, hθ, Nat.cast_mul] using this
      · -- C-bound: 2 ≤ n/u
        intro r u hu hrC
        have hltμ : iterate_op SD.exY u < mu (SD.F1) r := by
          simpa [extensionSetC, Set.mem_setOf_eq] using hrC
        have hle_fst := SD.fst_le_of_lt (x := iterate_op SD.exY u) (y := mu (SD.F1) r) hltμ
        have hμ : mu (SD.F1) r = iterate_op SD.baseA (r SD.i0) := by
          simpa [SD.F1, mu_singleton_eval, SD.baseA, SD.i0] using (mu_singleton_eval (a := SD.baseA) SD.baseA_pos r)
        have hru : 2 * u ≤ r SD.i0 := by
          simpa [SD.fst_iterate_baseA, SD.fst_iterate_exY, hμ] using hle_fst
        have hθ : (SD.R1).Θ_grid ⟨mu (SD.F1) r, mu_mem_kGrid (SD.F1) r⟩ = (r SD.i0 : ℝ) := by
          simp [hμ, SD.theta_pow_baseA]
        have huℝ : (0 : ℝ) < (u : ℝ) := Nat.cast_pos.mpr hu
        have : (2 : ℝ) ≤ (r SD.i0 : ℝ) / (u : ℝ) := by
          have : (2 : ℝ) * (u : ℝ) ≤ (r SD.i0 : ℝ) := by exact_mod_cast hru
          exact (le_div_iff₀ huℝ).2 this
        simpa [separationStatistic, hθ, Nat.cast_mul] using this
      · -- B-bound: impossible by `hB_empty`
        intro r u hu hrB
        exfalso
        exact hB_empty r u hu hrB

    have hchoose : DeltaSpec (SD.F1) (SD.R1) SD.exY SD.exY_pos
        (chooseδ (α := SD) (hk := (le_rfl : (1 : ℕ) ≥ 1)) (SD.R1) SD.exY SD.exY_pos) :=
      chooseδ_spec (α := SD) (hk := (le_rfl : (1 : ℕ) ≥ 1)) (R := SD.R1) (IH := IH) (H := H)
        (d := SD.exY) (hd := SD.exY_pos)

    have hδ :
        chooseδ (α := SD) (hk := (le_rfl : (1 : ℕ) ≥ 1)) (SD.R1) SD.exY SD.exY_pos = 2 := by
      -- uniqueness of DeltaSpec
      exact DeltaSpec_unique (α := SD) (hk := (le_rfl : (1 : ℕ) ≥ 1)) (R := SD.R1) (IH := IH) (H := H)
        (d := SD.exY) (hd := SD.exY_pos) (hv := hchoose) (hw := hDelta2)

    -- Finally compute the C-witness statistic: it is also `2`.
    have hstat : separationStatistic (SD.R1) (fun _ => 2) 1 Nat.one_pos = 2 := by
      -- Θ(a^2)/1 = 2
      have hμ2 : mu (SD.F1) (fun _ : Fin 1 => 2) = iterate_op SD.baseA 2 := by
        simpa [SD.F1, mu_singleton_eval, SD.baseA, SD.i0] using
          (mu_singleton_eval (a := SD.baseA) SD.baseA_pos (fun _ : Fin 1 => 2))
      -- unfold the statistic and use `theta_pow_baseA` to evaluate Θ(a^2)
      simp [separationStatistic, hμ2, SD.theta_pow_baseA]
    simpa [hδ, hstat]

end Mettapedia.ProbabilityTheory.KnuthSkilling.Additive.Counterexamples
