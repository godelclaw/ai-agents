/-
# D-Separation Soundness Infrastructure

This file defines conditional independence of vertex sets in a Bayesian network
using Mathlib's measure-theoretic `CondIndep`, and proves basic properties.

## Main Definitions

- `CondIndepVertices`: Conditional independence of vertex sets X, Y given Z,
  expressed via σ-algebras generated by coordinate projections.

## Main Results

- `condIndepVertices_symm`: Symmetry of conditional independence.
- `condIndepVertices_empty_left/right`: Independence holds trivially when X or Y is empty.
- `condIndepVertices_of_le_left/right`: Monotonicity (subsets preserve independence).

## References

- Koller & Friedman, "Probabilistic Graphical Models" (2009), Chapter 3
- Pearl, "Probabilistic Reasoning in Intelligent Systems" (1988)
-/

import Mettapedia.ProbabilityTheory.BayesianNetworks.BayesianNetwork
import Mettapedia.ProbabilityTheory.BayesianNetworks.DSeparation
import Mettapedia.ProbabilityTheory.BayesianNetworks.EventSets
import Mathlib.Data.Fintype.Card
import Mathlib.MeasureTheory.Constructions.Polish.Basic
import Mathlib.MeasureTheory.Integral.Bochner.Set

open MeasureTheory ProbabilityTheory

namespace Mettapedia.ProbabilityTheory.BayesianNetworks.BayesianNetwork

variable {V : Type*} [Fintype V] [DecidableEq V]
variable (bn : BayesianNetwork V)
variable [∀ v : V, StandardBorelSpace (bn.stateSpace v)]
variable [StandardBorelSpace bn.JointSpace]
variable (μ : Measure bn.JointSpace) [IsFiniteMeasure μ]

/-! ## Conditional Independence of Vertex Sets -/

/-- Conditional independence of vertex sets X and Y given Z in a Bayesian network.

This wraps Mathlib's `ProbabilityTheory.CondIndep` using σ-algebras generated by
coordinate projections for each vertex set. -/
def CondIndepVertices (X Y Z : Set V) : Prop :=
  ProbabilityTheory.CondIndep
    (m' := bn.measurableSpaceOfVertices Z)
    (m₁ := bn.measurableSpaceOfVertices X)
    (m₂ := bn.measurableSpaceOfVertices Y)
    (hm' := measurableSpaceOfVertices_le (bn := bn) Z)
    μ


/-! ## Basic Properties -/

omit [DecidableEq V] in
/-- Conditional independence is symmetric in X and Y. -/
theorem condIndepVertices_symm {X Y Z : Set V}
    (h : CondIndepVertices bn μ X Y Z) :
    CondIndepVertices bn μ Y X Z :=
by
  unfold CondIndepVertices at h ⊢
  exact CondIndep.symm h

omit [DecidableEq V] in
/-- If X is empty, conditional independence holds trivially. -/
theorem condIndepVertices_empty_left (Y Z : Set V) :
    CondIndepVertices bn μ ∅ Y Z := by
  unfold CondIndepVertices
  have h : bn.measurableSpaceOfVertices ∅ = ⊥ := by
    simp [measurableSpaceOfVertices, iSup_of_empty]
  rw [h]
  exact condIndep_bot_left (bn.measurableSpaceOfVertices Y)

omit [DecidableEq V] in
/-- If Y is empty, conditional independence holds trivially. -/
theorem condIndepVertices_empty_right (X Z : Set V) :
    CondIndepVertices bn μ X ∅ Z := by
  exact condIndepVertices_symm bn μ (condIndepVertices_empty_left bn μ X Z)

omit [Fintype V] [DecidableEq V] [∀ (v : V), StandardBorelSpace (bn.stateSpace v)] in
/-- σ-algebra monotonicity: S' ⊆ S → σ(S') ≤ σ(S). -/
theorem measurableSpaceOfVertices_mono {S S' : Set V} (h : S' ⊆ S) :
    bn.measurableSpaceOfVertices S' ≤ bn.measurableSpaceOfVertices S := by
  unfold measurableSpaceOfVertices
  exact iSup_le fun ⟨v, hv⟩ => le_iSup_of_le ⟨v, h hv⟩ le_rfl

omit [DecidableEq V] in
/-- Monotonicity: if X' ⊆ X and X ⫫ Y | Z, then X' ⫫ Y | Z. -/
theorem condIndepVertices_of_le_left {X X' Y Z : Set V} (hXX' : X' ⊆ X)
    (h : CondIndepVertices bn μ X Y Z) :
    CondIndepVertices bn μ X' Y Z := by
  unfold CondIndepVertices at *
  exact condIndep_of_condIndep_of_le_left h (measurableSpaceOfVertices_mono bn hXX')

omit [DecidableEq V] in
/-- Monotonicity: if Y' ⊆ Y and X ⫫ Y | Z, then X ⫫ Y' | Z. -/
theorem condIndepVertices_of_le_right {X Y Y' Z : Set V} (hYY' : Y' ⊆ Y)
    (h : CondIndepVertices bn μ X Y Z) :
    CondIndepVertices bn μ X Y' Z := by
  unfold CondIndepVertices at *
  exact condIndep_of_condIndep_of_le_right h (measurableSpaceOfVertices_mono bn hYY')

/-! ## Event-level measurability (for single vertices) -/

open Mettapedia.ProbabilityTheory.BayesianNetworks.BayesianNetwork

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] in
/-- `eventEq` is measurable in the σ-algebra generated by a single vertex. -/
theorem measurable_eventEq_vertices
    [∀ v, MeasurableSingletonClass (bn.stateSpace v)]
    (v : V) (val : bn.stateSpace v) :
    MeasurableSet[bn.measurableSpaceOfVertices ({v} : Set V)]
      (eventEq (bn := bn) v val) := by
  classical
  -- First show measurability in the comap σ-algebra of the coordinate projection.
  have hcomap :
      MeasurableSet[
        MeasurableSpace.comap (fun ω : bn.JointSpace => ω v) (by infer_instance)]
        (eventEq (bn := bn) v val) := by
    refine (MeasurableSpace.measurableSet_comap).2 ?_
    refine ⟨{val}, ?_, ?_⟩
    · simp
    · ext ω; rfl
  -- Lift measurability to the `iSup` defining `measurableSpaceOfVertices {v}`.
  have hle :
      MeasurableSpace.comap (fun ω : bn.JointSpace => ω v) (by infer_instance) ≤
        bn.measurableSpaceOfVertices ({v} : Set V) := by
    refine le_iSup_of_le ⟨v, by simp⟩ ?_
    exact le_rfl
  exact hle _ hcomap

/-! ## Measurable functions on a single vertex σ-algebra -/

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] in
lemma measurableSpaceOfVertices_singleton (v : V) :
    bn.measurableSpaceOfVertices ({v} : Set V) =
      MeasurableSpace.comap (fun ω : bn.JointSpace => ω v) (by infer_instance) := by
  classical
  -- `iSup` over a singleton collapses to the single coordinate σ-algebra.
  simpa [measurableSpaceOfVertices, iSup_subtype'', Set.mem_singleton_iff]

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] in
lemma measurable_const_on_fiber
    (v : V) {f : bn.JointSpace → ℝ}
    (hf : Measurable[bn.measurableSpaceOfVertices ({v} : Set V)] f)
    {ω₁ ω₂ : bn.JointSpace} (h : ω₁ v = ω₂ v) :
    f ω₁ = f ω₂ := by
  classical
  have hf' :
      Measurable[MeasurableSpace.comap (fun ω : bn.JointSpace => ω v) (by infer_instance)] f := by
    simpa [measurableSpaceOfVertices_singleton (bn := bn) v] using hf
  have hpre :
      MeasurableSet[
        MeasurableSpace.comap (fun ω : bn.JointSpace => ω v) (by infer_instance)]
        (f ⁻¹' ({f ω₁} : Set ℝ)) := by
    exact hf' (by simp)
  rcases (MeasurableSpace.measurableSet_comap).1 hpre with ⟨s, hs, hpre_eq⟩
  have h₁ : ω₁ ∈ (fun ω : bn.JointSpace => ω v) ⁻¹' s := by
    have : ω₁ ∈ f ⁻¹' ({f ω₁} : Set ℝ) := by simp
    simpa [hpre_eq] using this
  have h₂ : ω₂ ∈ (fun ω : bn.JointSpace => ω v) ⁻¹' s := by
    have : ω₁ v ∈ s := by simpa using h₁
    simpa [h] using this
  have h₂' : ω₂ ∈ f ⁻¹' ({f ω₁} : Set ℝ) := by
    simpa [hpre_eq] using h₂
  simpa using h₂'.symm

/-! ## Constant-on-event integrals -/

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] in
lemma setIntegral_const_on
    (s : Set bn.JointSpace) (hs : MeasurableSet s) (c : ℝ)
    {f : bn.JointSpace → ℝ}
    (hconst : f =ᵐ[μ.restrict s] fun _ => c) :
    ∫ x in s, f x ∂μ = c * μ.real s := by
  have hconst' : ∀ᵐ x ∂μ, x ∈ s → f x = c := by
    exact (MeasureTheory.ae_restrict_iff' hs).1 hconst
  have h' := MeasureTheory.setIntegral_congr_ae (μ := μ) (s := s) hs hconst'
  have h'' : ∫ x in s, (fun _ => c) x ∂μ = c * μ.real s := by
    simpa [mul_comm] using (MeasureTheory.setIntegral_const (μ := μ) (s := s) (c := c))
  exact (h'.trans h'')

lemma condExp_ae_eq_const_on_eventEq
    [∀ v, MeasurableSingletonClass (bn.stateSpace v)]
    (B : V) (valB : bn.stateSpace B)
    (s : Set bn.JointSpace) (ω0 : bn.JointSpace) :
    MeasureTheory.condExp
      (bn.measurableSpaceOfVertices ({B} : Set V)) μ
      (s.indicator fun _ : bn.JointSpace => (1 : ℝ))
      =ᵐ[μ.restrict (eventEq (bn := bn) B valB)]
      fun _ : bn.JointSpace =>
        MeasureTheory.condExp
          (bn.measurableSpaceOfVertices ({B} : Set V)) μ
          (s.indicator fun _ : bn.JointSpace => (1 : ℝ))
          (Function.update ω0 B valB) := by
  classical
  -- `μ⟦s | m'⟧` is measurable with respect to `m'`, hence constant on the fiber `B = valB`.
  refine (MeasureTheory.ae_restrict_iff' ?_).2 ?_
  · simpa using measurable_eventEq (bn := bn) B valB
  refine Filter.Eventually.of_forall ?_
  intro ω hω
  -- Use constancy on fiber for measurable functions.
  apply measurable_const_on_fiber (bn := bn) B
  · exact (stronglyMeasurable_condExp (μ := μ)
      (m := bn.measurableSpaceOfVertices ({B} : Set V))
      (f := (s.indicator fun _ => (1 : ℝ)))).measurable
  · have hB : ω B = valB := by
        simpa [eventEq] using hω
    have h0 : (Function.update ω0 B valB) B = valB := by
      simp
    simpa [hB, h0]

/-! ## Conditional independence ⇒ event independence (Z = ∅) -/

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] [IsFiniteMeasure μ] in
lemma ae_const_eq
    [IsProbabilityMeasure μ] {c₁ c₂ : ℝ}
    (h : (fun _ : bn.JointSpace => c₁) =ᵐ[μ] (fun _ => c₂)) :
    c₁ = c₂ := by
  by_contra hne
  have hprob :
      (∀ᵐ ω ∂μ,
        (fun _ : bn.JointSpace => c₁) ω = (fun _ => c₂) ω) := by
    exact h
  have hzero : μ {ω | c₁ ≠ c₂} = 0 :=
    (MeasureTheory.ae_iff).1 (by
      simpa using hprob)
  have hset : ({ω | c₁ ≠ c₂} : Set bn.JointSpace) = Set.univ := by
    ext ω; simp [hne]
  have huniv : μ (Set.univ : Set bn.JointSpace) = 0 := by
    rw [← hset]
    exact hzero
  have huniv' : (1 : ENNReal) = 0 := by
    rw [← IsProbabilityMeasure.measure_univ (μ := μ)]
    exact huniv
  exact one_ne_zero huniv'

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] in
lemma ae_const_eq_of_restrict_ne_zero
    {s : Set bn.JointSpace} (hs : μ s ≠ 0)
    {c₁ c₂ : ℝ}
    (h : (fun _ : bn.JointSpace => c₁) =ᵐ[μ.restrict s] (fun _ => c₂)) :
    c₁ = c₂ := by
  by_contra hne
  have hzero : μ.restrict s {x | c₁ ≠ c₂} = 0 := by
    simpa using (MeasureTheory.ae_iff).1 h
  have htop : μ.restrict s (Set.univ : Set bn.JointSpace) = 0 := by
    simpa [hne] using hzero
  have hs' : μ s = 0 := by
    simpa [Measure.restrict_apply] using htop
  exact hs hs'

omit [Fintype V] [DecidableEq V] [∀ v, StandardBorelSpace (bn.stateSpace v)] in
lemma sigmaFinite_trim_of_le
    (m' : MeasurableSpace bn.JointSpace)
    (hm' : m' ≤ (MeasurableSpace.pi : MeasurableSpace bn.JointSpace)) :
    SigmaFinite (μ.trim hm') := by
  haveI : SigmaFinite (μ.trim (bot_le : (⊥ : MeasurableSpace bn.JointSpace) ≤ _)) := by
    simpa [MeasureTheory.sigmaFinite_trim_bot_iff] using (inferInstance : IsFiniteMeasure μ)
  exact MeasureTheory.sigmaFiniteTrim_mono (μ := μ) (hm := hm')
    (hm₂ := (bot_le : (⊥ : MeasurableSpace bn.JointSpace) ≤ m'))

omit [DecidableEq V] in
/-- Under conditional independence with `Z = ∅`, single-vertex events are independent. -/
theorem condIndepVertices_eventEq_mul
    [IsProbabilityMeasure μ]
    [∀ v, MeasurableSingletonClass (bn.stateSpace v)]
    (A C : V) (valA : bn.stateSpace A) (valC : bn.stateSpace C)
    (hci : CondIndepVertices bn μ ({A} : Set V) ({C} : Set V) ∅) :
    μ (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC) =
      μ (eventEq (bn := bn) A valA) * μ (eventEq (bn := bn) C valC) := by
  classical
  -- Convert `CondIndepVertices` to the measurable-set formulation.
  unfold CondIndepVertices at hci
  have hci' :=
    (condIndep_iff
      (m' := bn.measurableSpaceOfVertices (∅ : Set V))
      (m₁ := bn.measurableSpaceOfVertices ({A} : Set V))
      (m₂ := bn.measurableSpaceOfVertices ({C} : Set V))
      (hm' := measurableSpaceOfVertices_le (bn := bn) (∅ : Set V))
      (hm₁ := measurableSpaceOfVertices_le (bn := bn) ({A} : Set V))
      (hm₂ := measurableSpaceOfVertices_le (bn := bn) ({C} : Set V))
      (μ := μ)).1 hci
  have hAmeas :
      MeasurableSet[bn.measurableSpaceOfVertices ({A} : Set V)]
        (eventEq (bn := bn) A valA) :=
    measurable_eventEq_vertices (bn := bn) A valA
  have hCmeas :
      MeasurableSet[bn.measurableSpaceOfVertices ({C} : Set V)]
        (eventEq (bn := bn) C valC) :=
    measurable_eventEq_vertices (bn := bn) C valC
  have hcond :=
    hci' (eventEq (bn := bn) A valA) (eventEq (bn := bn) C valC) hAmeas hCmeas
  -- Simplify the conditioning σ-algebra `⊥`.
  have hbot : bn.measurableSpaceOfVertices (∅ : Set V) = ⊥ := by
    simp [measurableSpaceOfVertices, iSup_of_empty]
  have hcond' :
      μ⟦eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC | ⊥⟧ =ᵐ[μ]
        μ⟦eventEq (bn := bn) A valA | ⊥⟧ *
          μ⟦eventEq (bn := bn) C valC | ⊥⟧ := by
    simpa [hbot] using hcond
  -- `μ⟦s|⊥⟧` is the constant function `μ.real s`.
  have hAconst :
      μ⟦eventEq (bn := bn) A valA | ⊥⟧ =
        (fun _ => μ.real (eventEq (bn := bn) A valA)) := by
    have h := MeasureTheory.condExp_bot (μ := μ)
      (f := Set.indicator (eventEq (bn := bn) A valA)
        (fun _ : bn.JointSpace => (1 : ℝ)))
    have hmeas : MeasurableSet (eventEq (bn := bn) A valA) :=
      measurable_eventEq (bn := bn) A valA
    have hInt :
        ∫ x, (eventEq (bn := bn) A valA).indicator (fun _ : bn.JointSpace => (1 : ℝ)) x ∂μ =
          μ.real (eventEq (bn := bn) A valA) := by
      simpa using (MeasureTheory.integral_indicator_one (μ := μ) (s := eventEq (bn := bn) A valA) hmeas)
    ext ω
    have h' := congrArg (fun f => f ω) h
    simpa [hInt] using h'
  have hCconst :
      μ⟦eventEq (bn := bn) C valC | ⊥⟧ =
        (fun _ => μ.real (eventEq (bn := bn) C valC)) := by
    have h := MeasureTheory.condExp_bot (μ := μ)
      (f := Set.indicator (eventEq (bn := bn) C valC)
        (fun _ : bn.JointSpace => (1 : ℝ)))
    have hmeas : MeasurableSet (eventEq (bn := bn) C valC) :=
      measurable_eventEq (bn := bn) C valC
    have hInt :
        ∫ x, (eventEq (bn := bn) C valC).indicator (fun _ : bn.JointSpace => (1 : ℝ)) x ∂μ =
          μ.real (eventEq (bn := bn) C valC) := by
      simpa using (MeasureTheory.integral_indicator_one (μ := μ) (s := eventEq (bn := bn) C valC) hmeas)
    ext ω
    have h' := congrArg (fun f => f ω) h
    simpa [hInt] using h'
  have hACconst :
      μ⟦eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC | ⊥⟧ =
        (fun _ => μ.real (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)) := by
    have h := MeasureTheory.condExp_bot (μ := μ)
      (f := Set.indicator
        (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)
        (fun _ : bn.JointSpace => (1 : ℝ)))
    have hmeas : MeasurableSet
        (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC) := by
      have hA : MeasurableSet (eventEq (bn := bn) A valA) :=
        measurable_eventEq (bn := bn) A valA
      have hC : MeasurableSet (eventEq (bn := bn) C valC) :=
        measurable_eventEq (bn := bn) C valC
      exact hA.inter hC
    have hInt :
        ∫ x, (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC).indicator
            (fun _ : bn.JointSpace => (1 : ℝ)) x ∂μ =
          μ.real (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC) := by
      simpa using
        (MeasureTheory.integral_indicator_one (μ := μ)
          (s := eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC) hmeas)
    ext ω
    have h' := congrArg (fun f => f ω) h
    simpa [hInt] using h'
  have hconst :
      (fun _ => μ.real (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)) =ᵐ[μ]
        (fun _ => μ.real (eventEq (bn := bn) A valA) * μ.real (eventEq (bn := bn) C valC)) := by
    simpa [hAconst, hCconst, hACconst] using hcond'
  have hreal :
      μ.real (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC) =
        μ.real (eventEq (bn := bn) A valA) *
          μ.real (eventEq (bn := bn) C valC) :=
    ae_const_eq (bn := bn) (μ := μ) hconst
  -- Convert real equality back to `ENNReal`.
  have htoReal' :
      (μ (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)).toReal =
        (μ (eventEq (bn := bn) A valA)).toReal *
          (μ (eventEq (bn := bn) C valC)).toReal := by
    simpa [Measure.real] using hreal
  have htoReal :
      (μ (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)).toReal =
        (μ (eventEq (bn := bn) A valA) * μ (eventEq (bn := bn) C valC)).toReal := by
    calc
      (μ (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)).toReal =
          (μ (eventEq (bn := bn) A valA)).toReal *
            (μ (eventEq (bn := bn) C valC)).toReal := htoReal'
      _ = (μ (eventEq (bn := bn) A valA) * μ (eventEq (bn := bn) C valC)).toReal := by
          simp [ENNReal.toReal_mul]
  have hne1 :
      μ (eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC) ≠ (⊤ : ENNReal) :=
    MeasureTheory.measure_ne_top (μ := μ)
      (s := eventEq (bn := bn) A valA ∩ eventEq (bn := bn) C valC)
  have hne2 :
      μ (eventEq (bn := bn) A valA) * μ (eventEq (bn := bn) C valC) ≠ (⊤ : ENNReal) := by
    exact ENNReal.mul_ne_top
      (MeasureTheory.measure_ne_top (μ := μ) (s := eventEq (bn := bn) A valA))
      (MeasureTheory.measure_ne_top (μ := μ) (s := eventEq (bn := bn) C valC))
  exact (ENNReal.toReal_eq_toReal_iff' hne1 hne2).1 htoReal

/-! ## Conditional independence ⇒ screening-off (Z = {B})

The heavy measure-theoretic screening-off proof is moved to
`BayesianNetworks/ScreeningOffFromCondIndep.lean` to keep this core file fast.
-/

/-! ## D-Separation Soundness Interface

This is the standard soundness theorem: **d-separation implies conditional independence**
for measures that satisfy the local Markov property (Koller–Friedman Thm 3.3; Pearl Ch. 3).

We package it as a typeclass so downstream “compiled PLN rules” can demand the theorem
without hard-coding a proof here.
-/

/-- D-separation soundness for a BN and joint measure.

Assuming the local Markov property, d-separation in the graph implies conditional
independence of the corresponding σ-algebras in the joint measure. -/
class DSeparationSoundness {V : Type*} [Fintype V] [DecidableEq V]
    (bn : BayesianNetwork V) [∀ v : V, StandardBorelSpace (bn.stateSpace v)]
    (μ : Measure bn.JointSpace) [IsFiniteMeasure μ]
    [HasLocalMarkovProperty bn μ] : Prop where
  /-- Soundness: d-separation ⇒ conditional independence. -/
  dsep_condIndep :
    ∀ {X Y Z : Set V},
      Mettapedia.ProbabilityTheory.BayesianNetworks.DSeparation.DSeparated bn.graph X Y Z →
        CondIndepVertices bn μ X Y Z

/-- Use d-separation soundness to discharge a conditional-independence obligation. -/
theorem dsep_implies_condIndepVertices
    {V : Type*} [Fintype V] [DecidableEq V]
    (bn : BayesianNetwork V) [∀ v : V, StandardBorelSpace (bn.stateSpace v)]
    (μ : Measure bn.JointSpace) [IsFiniteMeasure μ]
    [HasLocalMarkovProperty bn μ] [DSeparationSoundness bn μ]
    {X Y Z : Set V}
    (h : Mettapedia.ProbabilityTheory.BayesianNetworks.DSeparation.DSeparated bn.graph X Y Z) :
    CondIndepVertices bn μ X Y Z :=
  DSeparationSoundness.dsep_condIndep (bn := bn) (μ := μ) h

end Mettapedia.ProbabilityTheory.BayesianNetworks.BayesianNetwork
