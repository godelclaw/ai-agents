import Mettapedia.UniversalAI.BayesianAgents
import Mettapedia.UniversalAI.InfiniteHistory
import Mettapedia.UniversalAI.GrainOfTruth.FixedPoint
import Mathlib.MeasureTheory.Measure.ProbabilityMeasure
import Mathlib.Probability.Process.Stopping
import Mathlib.Probability.Process.Filtration
import Mathlib.MeasureTheory.Constructions.Pi
import Mathlib.Probability.Kernel.IonescuTulcea.Traj

/-!
# Phase 1: History ↔ Filtration Bridge

This file establishes the connection between our discrete `History` type and
Mathlib's measure-theoretic `Filtration` type. This is the foundational layer
for proving Bayesian consistency.

## Main Definitions

* `Trajectory` - Infinite sequence of (action, percept) pairs
* `trajectoryFiltration` - The canonical filtration on trajectories
* `trajectoryToHistory` - Extract finite history from infinite trajectory
* `environmentMeasure` - Probability measure induced by environment

## Main Results

* `trajectoryToHistory_depends_on_prefix` - Extracting history is adapted
* `environmentMeasure_isProbability` - Environment induces probability measure

## References

- Leike (2016). PhD Thesis, Chapter 7
- Williams (1991). "Probability with Martingales"
-/

namespace Mettapedia.UniversalAI.GrainOfTruth.MeasureTheory.HistoryFiltration

open MeasureTheory ProbabilityTheory Finset Function Preorder  -- Match mathlib's Traj.lean opens
open Mettapedia.UniversalAI.BayesianAgents
open Mettapedia.UniversalAI.GrainOfTruth.FixedPoint
open scoped ENNReal NNReal MeasureTheory

/-! ## MeasurableSpace instances for discrete types -/

/-- History has the discrete σ-algebra (all subsets measurable).
    This is appropriate since History is a countable type. -/
instance : MeasurableSpace History := ⊤

/-- Every subset of History is measurable. -/
theorem History.measurableSet_singleton (h : History) : MeasurableSet ({h} : Set History) :=
  trivial

/-! ## Sample Space: Trajectories

A trajectory is an infinite sequence of (action, percept) pairs representing
a complete interaction history. We index by ℕ where step n contains the
action taken at time n and the percept received after that action.
-/

/-- A single step in a trajectory: action taken and percept received. -/
structure Step where
  action : Action
  percept : Percept
  deriving DecidableEq, Inhabited

/-- Extensionality lemma for Step. -/
@[ext]
theorem Step.ext {s t : Step} (h1 : s.action = t.action) (h2 : s.percept = t.percept) : s = t := by
  cases s; cases t; simp_all

/-- Measurable space on Step (finite, so discrete σ-algebra). -/
instance : MeasurableSpace Step := ⊤

/-- Step has MeasurableSingletonClass (singletons are measurable). -/
instance : MeasurableSingletonClass Step where
  measurableSet_singleton _ := trivial

/-- Equivalence between Step and Action × Percept. -/
def Step.equiv : Step ≃ Action × Percept where
  toFun s := (s.action, s.percept)
  invFun p := ⟨p.1, p.2⟩
  left_inv s := by cases s; rfl
  right_inv p := by cases p; rfl

/-- Step is a finite type (via equivalence with Action × Percept). -/
instance : Fintype Step := Fintype.ofEquiv (Action × Percept) Step.equiv.symm

/-- Number of steps = 3 actions × 4 percepts = 12. -/
theorem step_card : Fintype.card Step = 12 := by
  simp only [Fintype.card]
  rfl

/-- A trajectory is an infinite sequence of steps. -/
abbrev Trajectory := ℕ → Step

/-- Measurable space on Trajectory: product σ-algebra. -/
instance trajectoryMeasurableSpace : MeasurableSpace Trajectory := MeasurableSpace.pi

/-! ## The Canonical Filtration

The filtration ℱ_t represents information available at time t.
ℱ_t is the σ-algebra generated by the first t steps of the trajectory.
-/

/-- Project trajectory to first n steps (as a function on Fin n). -/
def truncate (n : ℕ) : Trajectory → (Fin n → Step) :=
  fun traj i => traj i.val

/-- Truncation is measurable. -/
theorem truncate_measurable (n : ℕ) : Measurable (truncate n) := by
  apply measurable_pi_lambda
  intro i
  exact measurable_pi_apply i.val

/-- σ-algebra generated by first n steps. -/
def sigmaAlgebraUpTo (n : ℕ) : MeasurableSpace Trajectory :=
  MeasurableSpace.comap (truncate n) inferInstance

/-- sigmaAlgebraUpTo is monotone: more steps means finer σ-algebra. -/
theorem sigmaAlgebraUpTo_mono {i j : ℕ} (hij : i ≤ j) :
    sigmaAlgebraUpTo i ≤ sigmaAlgebraUpTo j := by
  intro s hs
  simp only [sigmaAlgebraUpTo, MeasurableSpace.comap] at hs ⊢
  obtain ⟨t, ht, rfl⟩ := hs
  -- Express (truncate i)⁻¹' t as (truncate j)⁻¹' t' for some t'
  -- We project: π : (Fin j → Step) → (Fin i → Step), taking first i coords
  let proj : (Fin j → Step) → (Fin i → Step) := fun f k =>
    f ⟨k.val, Nat.lt_of_lt_of_le k.isLt hij⟩
  use proj ⁻¹' t
  constructor
  · -- Measurability: proj is measurable, so preimage of measurable set is measurable
    have h_proj_meas : Measurable proj := by
      apply measurable_pi_lambda
      intro k
      have hk : k.val < j := Nat.lt_of_lt_of_le k.isLt hij
      exact measurable_pi_apply (Fin.mk k.val hk)
    exact ht.preimage h_proj_meas
  · -- Set equality: (truncate i)⁻¹' t = (truncate j)⁻¹' (proj⁻¹' t)
    ext traj
    simp only [Set.mem_preimage, truncate, proj]
    rfl

/-- sigmaAlgebraUpTo n is coarser than the full σ-algebra. -/
theorem sigmaAlgebraUpTo_le (n : ℕ) : sigmaAlgebraUpTo n ≤ trajectoryMeasurableSpace := by
  -- sigmaAlgebraUpTo n = comap (truncate n) _
  -- Since truncate n is measurable w.r.t. trajectoryMeasurableSpace, the comap is coarser
  apply MeasurableSpace.comap_le_iff_le_map.mpr
  intro s hs
  exact hs.preimage (truncate_measurable n)

/-- The canonical filtration on trajectories. -/
def trajectoryFiltration : @MeasureTheory.Filtration Trajectory ℕ _ trajectoryMeasurableSpace where
  seq := sigmaAlgebraUpTo
  mono' := @sigmaAlgebraUpTo_mono
  le' := sigmaAlgebraUpTo_le

/-! ## Extracting History from Trajectory

We need to convert between our `History` type (a list of HistElem) and
the trajectory representation.
-/

/-- Convert a trajectory prefix (first t steps) to a History.
    The history alternates: [act a₀, per p₀, act a₁, per p₁, ...] -/
def trajectoryToHistory (traj : Trajectory) (t : ℕ) : History :=
  (List.range t).flatMap fun i =>
    [HistElem.act (traj i).action, HistElem.per (traj i).percept]

/-- The history has length 2t (t actions + t percepts). -/
theorem trajectoryToHistory_length (traj : Trajectory) (t : ℕ) :
    (trajectoryToHistory traj t).length = 2 * t := by
  induction t with
  | zero => simp [trajectoryToHistory]
  | succ t ih =>
    simp only [trajectoryToHistory] at ih ⊢
    simp only [List.range_succ, List.flatMap_append, List.flatMap_singleton,
               List.length_append, List.length_cons, List.length_nil]
    rw [ih]
    ring

/-- Extracting history depends only on the first t steps. -/
theorem trajectoryToHistory_depends_on_prefix (traj₁ traj₂ : Trajectory) (t : ℕ)
    (h : ∀ i < t, traj₁ i = traj₂ i) :
    trajectoryToHistory traj₁ t = trajectoryToHistory traj₂ t := by
  induction t with
  | zero => simp [trajectoryToHistory]
  | succ t ih =>
    simp only [trajectoryToHistory, List.range_succ, List.flatMap_append, List.flatMap_singleton]
    congr 1
    · exact ih (fun i hi => h i (Nat.lt_succ_of_lt hi))
    · rw [h t (Nat.lt_succ_self t)]

/-- Empty history at time 0. -/
@[simp]
theorem trajectoryToHistory_zero (traj : Trajectory) :
    trajectoryToHistory traj 0 = [] := by
  simp [trajectoryToHistory]

/-- Inductive structure of history. -/
theorem trajectoryToHistory_succ (traj : Trajectory) (t : ℕ) :
    trajectoryToHistory traj (t + 1) =
      trajectoryToHistory traj t ++
        [HistElem.act (traj t).action, HistElem.per (traj t).percept] := by
  simp only [trajectoryToHistory, List.range_succ, List.flatMap_append, List.flatMap_singleton]

/-- For t ≥ 1, the first element of trajectoryToHistory is act (traj 0).action. -/
theorem trajectoryToHistory_first (traj : Trajectory) (t : ℕ) (ht : t ≥ 1) :
    (trajectoryToHistory traj t)[0]? = some (HistElem.act (traj 0).action) := by
  cases t with
  | zero => omega
  | succ t' =>
    rw [trajectoryToHistory_succ]
    cases t' with
    | zero =>
      -- trajectoryToHistory traj 1 = [] ++ [act _, per _] = [act _, per _]
      simp only [trajectoryToHistory_zero, List.nil_append, List.getElem?_cons_zero]
    | succ t'' =>
      -- trajectoryToHistory traj (t''+2) = trajectoryToHistory traj (t''+1) ++ [_, _]
      -- The first element is in trajectoryToHistory traj (t''+1), not the appended part
      have h_len : (trajectoryToHistory traj (t'' + 1)).length = 2 * (t'' + 1) :=
        trajectoryToHistory_length traj (t'' + 1)
      rw [List.getElem?_append_left (by rw [h_len]; omega)]
      exact trajectoryToHistory_first traj (t'' + 1) (by omega)

/-- For t ≥ 1, the second element of trajectoryToHistory is per (traj 0).percept. -/
theorem trajectoryToHistory_second (traj : Trajectory) (t : ℕ) (ht : t ≥ 1) :
    (trajectoryToHistory traj t)[1]? = some (HistElem.per (traj 0).percept) := by
  cases t with
  | zero => omega
  | succ t' =>
    rw [trajectoryToHistory_succ]
    cases t' with
    | zero =>
      -- trajectoryToHistory traj 1 = [] ++ [act _, per _] = [act _, per _]
      simp only [trajectoryToHistory_zero, List.nil_append, List.getElem?_cons_succ,
                 List.getElem?_cons_zero]
    | succ t'' =>
      -- trajectoryToHistory traj (t''+2) = trajectoryToHistory traj (t''+1) ++ [_, _]
      -- The second element is in trajectoryToHistory traj (t''+1) (since length ≥ 2)
      have h_len : (trajectoryToHistory traj (t'' + 1)).length = 2 * (t'' + 1) :=
        trajectoryToHistory_length traj (t'' + 1)
      rw [List.getElem?_append_left (by rw [h_len]; omega)]
      exact trajectoryToHistory_second traj (t'' + 1) (by omega)

/-- trajectoryToHistory always has even length. -/
theorem trajectoryToHistory_even (traj : Trajectory) (t : ℕ) :
    Even (trajectoryToHistory traj t).length := by
  rw [trajectoryToHistory_length]
  exact even_two_mul t

/-- Helper: appending [act a, per x] to a wellFormed history with even length preserves wellFormedness.
    When h has even length and is wellFormed, it ends with a percept (or is empty).
    Adding [act a, per x] maintains the act-per alternation. -/
theorem wellFormed_append_act_per (h : History) (a : Action) (x : Percept)
    (hw : h.wellFormed) (he : Even h.length) :
    (h ++ [HistElem.act a, HistElem.per x]).wellFormed := by
  -- Induction on h.length / 2 (the number of act-per pairs)
  -- Alternative: prove directly by case analysis on wellFormed structure
  match h with
  | [] =>
    -- [] ++ [act a, per x] = [act a, per x]
    simp only [List.nil_append]
    rfl
  | [HistElem.act _] =>
    -- h = [act a'], but Even [act a'].length = Even 1 = false
    simp at he
  | [HistElem.per _] =>
    -- Not wellFormed
    simp [History.wellFormed] at hw
  | HistElem.act a' :: HistElem.per x' :: rest' =>
    -- h = act a' :: per x' :: rest'
    -- wellFormed h ⟹ wellFormed rest'
    simp only [History.wellFormed] at hw
    simp only [List.length_cons] at he
    have he' : Even rest'.length := by
      obtain ⟨k, hk⟩ := he
      use k - 1
      omega
    -- Recursively apply to rest'
    have ih := wellFormed_append_act_per rest' a x hw he'
    -- (act a' :: per x' :: rest') ++ [act a, per x]
    --   = act a' :: per x' :: (rest' ++ [act a, per x])
    simp only [List.cons_append, History.wellFormed]
    exact ih
  | HistElem.act _ :: HistElem.act _ :: _ =>
    -- Not wellFormed
    simp [History.wellFormed] at hw
  | HistElem.per _ :: _ :: _ =>
    -- Not wellFormed
    simp [History.wellFormed] at hw
termination_by h.length

/-- trajectoryToHistory is always well-formed.
    Each step contributes [act a, per x], preserving well-formedness. -/
theorem trajectoryToHistory_wellFormed (traj : Trajectory) (t : ℕ) :
    (trajectoryToHistory traj t).wellFormed := by
  induction t with
  | zero => simp [trajectoryToHistory, History.wellFormed]
  | succ t ih =>
    rw [trajectoryToHistory_succ]
    exact wellFormed_append_act_per _ _ _ ih (trajectoryToHistory_even traj t)

/-! ## Ionescu-Tulcea Bridge

We construct the environment measure using Mathlib's Ionescu-Tulcea theorem.
The construction requires transition kernels that specify the distribution
of the next step given the prefix.

Since Environment only provides percept probabilities (given action), we
assume uniform action distribution. This is a standard simplification that
preserves the key properties needed for likelihood ratios and martingale theory.
-/

/-- The constant family X n = Step for Ionescu-Tulcea. -/
abbrev StepFamily : ℕ → Type := fun _ => Step

/-- MeasurableSpace for StepFamily (each component has discrete σ-algebra). -/
instance (n : ℕ) : MeasurableSpace (StepFamily n) := inferInstanceAs (MeasurableSpace Step)

/-- Convert a prefix in Iic-indexed form to our Fin-indexed form.
    `Π i : Iic n, Step` → `Fin (n+1) → Step` -/
def iicToFin (n : ℕ) (x : Π _ : Iic n, Step) : Fin (n + 1) → Step :=
  fun i => x ⟨i.val, mem_Iic.2 (Nat.lt_succ_iff.mp i.isLt)⟩

/-- Convert a Fin-indexed prefix back to Iic-indexed form.
    `Fin (n+1) → Step` → `Π i : Iic n, Step` -/
def finToIic (n : ℕ) (f : Fin (n + 1) → Step) : Π _ : Iic n, Step :=
  fun i => f ⟨i.1, Nat.lt_succ_of_le (mem_Iic.1 i.2)⟩

@[simp] theorem iicToFin_finToIic (n : ℕ) (f : Fin (n + 1) → Step) :
    iicToFin n (finToIic n f) = f := by
  funext i
  rfl

@[simp] theorem finToIic_iicToFin (n : ℕ) (x : Π _ : Iic n, Step) :
    finToIic n (iicToFin n x) = x := by
  funext i
  rfl

/-- Convert Iic-indexed prefix to History (inline definition to avoid forward reference). -/
def iicPrefixToHistory (n : ℕ) (x : Π _ : Iic n, Step) : History :=
  (List.finRange (n + 1)).flatMap fun i =>
    let s := iicToFin n x i
    [HistElem.act s.action, HistElem.per s.percept]

/-- Helper: [act a, per p] is well-formed as a standalone history. -/
theorem wellFormed_actper_pair (a : Action) (p : Percept) :
    History.wellFormed ([HistElem.act a, HistElem.per p] : History) := by
  simp [History.wellFormed]

/-- Helper: A history of form [act, per, ..., act, per] (only pairs, no trailing action)
    is well-formed. -/
theorem wellFormed_actper_pairs (pairs : List (Action × Percept)) :
    let h := pairs.flatMap (fun ⟨act, per⟩ => [HistElem.act act, HistElem.per per])
    History.wellFormed h := by
  induction pairs with
  | nil => simp only [List.flatMap_nil]; rfl
  | cons p rest ih =>
    simp only [List.flatMap_cons]
    show History.wellFormed (HistElem.act p.1 :: HistElem.per p.2 :: _)
    simp only [History.wellFormed]
    exact ih

/-- iicPrefixToHistory produces a well-formed history.
    The history [act₀, per₀, act₁, per₁, ...] matches the wellFormed pattern. -/
theorem iicPrefixToHistory_wellFormed (n : ℕ) (x : Π _ : Iic n, Step) :
    (iicPrefixToHistory n x).wellFormed := by
  unfold iicPrefixToHistory iicToFin
  let pairs : List (Action × Percept) :=
    (List.finRange (n + 1)).map fun i =>
      let s := x ⟨i.val, mem_Iic.2 (Nat.lt_succ_iff.mp i.isLt)⟩
      (s.action, s.percept)
  have h_eq : (List.finRange (n + 1)).flatMap (fun i =>
      let s := x ⟨i.val, mem_Iic.2 (Nat.lt_succ_iff.mp i.isLt)⟩
      [HistElem.act s.action, HistElem.per s.percept]) =
    pairs.flatMap (fun ⟨act, per⟩ => [HistElem.act act, HistElem.per per]) := by
    simp only [pairs, List.flatMap_map]
  rw [h_eq]
  exact wellFormed_actper_pairs pairs

/-- Key helper: A history of form [act, per, ..., act, per, act] (pairs followed by single act)
    is well-formed. We prove this by showing [act, per] ++ h is well-formed if h ends with [act]. -/
theorem wellFormed_actper_prefix_act (pairs : List (Action × Percept)) (a : Action) :
    let h := pairs.flatMap (fun ⟨act, per⟩ => [HistElem.act act, HistElem.per per])
    History.wellFormed (h ++ [HistElem.act a]) := by
  -- By induction on pairs
  induction pairs with
  | nil =>
    -- [] ++ [act a] = [act a] which is well-formed
    simp only [List.flatMap_nil, List.nil_append]
    rfl  -- wellFormed [act a] = true by definition
  | cons p rest ih =>
    -- ((act, per) :: rest).flatMap ... ++ [act a]
    -- = [act, per] ++ rest.flatMap ... ++ [act a]
    -- = [act, per] ++ (rest.flatMap ... ++ [act a])
    -- wellFormed [act, per, ...] = wellFormed ...
    simp only [List.flatMap_cons, List.append_assoc]
    -- Now the goal is: wellFormed ([act p.1, per p.2] ++ (rest.flatMap ... ++ [act a]))
    -- = wellFormed (act p.1 :: per p.2 :: (rest.flatMap ... ++ [act a]))
    -- By the wellFormed definition, this reduces to wellFormed of the tail
    show History.wellFormed (HistElem.act p.1 :: HistElem.per p.2 :: _)
    simp only [History.wellFormed]
    exact ih

/-- Appending [act a] to iicPrefixToHistory gives a well-formed history.
    Since iicPrefixToHistory produces [act, per, ..., act, per] ending with percept,
    appending [act a] gives [act, per, ..., act, per, act] which matches
    wellFormed pattern [act] or [act, per, ..., act]. -/
theorem iicPrefixToHistory_append_act_wellFormed (n : ℕ) (x : Π _ : Iic n, Step) (a : Action) :
    (iicPrefixToHistory n x ++ [HistElem.act a]).wellFormed := by
  -- Express iicPrefixToHistory as flatMap over pairs
  unfold iicPrefixToHistory iicToFin
  -- The list (List.finRange (n + 1)).flatMap ... has the right form
  -- We need to show this matches the pattern in wellFormed_actper_prefix_act
  -- Convert to the pairs form
  let pairs : List (Action × Percept) :=
    (List.finRange (n + 1)).map fun i =>
      let s := x ⟨i.val, mem_Iic.2 (Nat.lt_succ_iff.mp i.isLt)⟩
      (s.action, s.percept)
  -- Show the flatMap equals pairs.flatMap
  have h_eq : (List.finRange (n + 1)).flatMap (fun i =>
      let s := x ⟨i.val, mem_Iic.2 (Nat.lt_succ_iff.mp i.isLt)⟩
      [HistElem.act s.action, HistElem.per s.percept]) =
    pairs.flatMap (fun ⟨act, per⟩ => [HistElem.act act, HistElem.per per]) := by
    simp only [pairs, List.flatMap_map]
  rw [h_eq]
  exact wellFormed_actper_prefix_act pairs a

/-- Number of actions (for uniform distribution). -/
noncomputable def numActions : ℕ := Fintype.card Action

/-- Uniform probability over actions. -/
noncomputable def uniformActionProb : ENNReal :=
  (1 : ENNReal) / numActions

/-- An environment is stochastic if percept probabilities sum to exactly 1.
    This is needed for the Ionescu-Tulcea construction to give a probability measure. -/
def isStochastic (μ : Environment) : Prop :=
  ∀ h : History, h.wellFormed → (∑' x : Percept, μ.prob h x) = 1

/-- Key lemma: uniformActionProb * |Action| = 1. -/
theorem uniformActionProb_sum_eq_one :
    (uniformActionProb : ENNReal) * (Fintype.card Action : ℕ) = 1 := by
  simp only [uniformActionProb, numActions]
  rw [ENNReal.div_mul_cancel]
  · simp only [ne_eq, Nat.cast_eq_zero, Fintype.card_eq_zero_iff]
    exact not_isEmpty_of_nonempty Action
  · exact ENNReal.natCast_ne_top (Fintype.card Action)

/-! ## Transition Measure (Uniform Actions)

This is the baseline measure used for the existing likelihood-ratio development.

For Leike-style *on-policy* results we also construct `transitionMeasureWithPolicy`
and the induced `environmentMeasureWithPolicy` below.
-/

/-- The transition measure: given prefix x₀..xₙ, distribution over next step.

    The joint distribution over (action, percept) is:
    P(a, x) = (1/|Action|) * μ.prob(h ++ [act a])(x)

    where h is the history corresponding to the prefix. -/
noncomputable def transitionMeasure (μ : Environment) (n : ℕ)
    (x : Π _ : Iic n, Step) : MeasureTheory.Measure Step := by
  -- The measure assigns to each singleton {⟨a, p⟩} the probability
  -- uniformActionProb * μ.prob(h ++ [act a])(p)
  let h := iicPrefixToHistory n x
  exact MeasureTheory.Measure.sum (fun s : Step =>
    (uniformActionProb * μ.prob (h ++ [HistElem.act s.action]) s.percept) •
      MeasureTheory.Measure.dirac s)

/-- The transition measure is finite. -/
theorem transitionMeasure_finite (μ : Environment) (n : ℕ)
    (x : Π _ : Iic n, Step) :
    MeasureTheory.IsFiniteMeasure (transitionMeasure μ n x) := by
  constructor
  -- The measure of univ is bounded by sum of step probabilities ≤ |Step| / |Action| < ∞
  simp only [transitionMeasure]
  -- Use sum_apply_of_countable since Step is a Fintype (hence countable)
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  -- Now we have: ∑' s, (uniformActionProb * μ.prob(...)(s.percept)) • Measure.dirac s univ
  -- Rewrite tsum as finite sum, then use sum_lt_top
  rw [tsum_fintype]
  rw [ENNReal.sum_lt_top]
  intro s _
  -- Show (c • dirac s) univ < ⊤
  simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
  apply ENNReal.mul_lt_top
  · -- uniformActionProb * μ.prob(...)(s.percept) < ⊤
    apply ENNReal.mul_lt_top
    · -- uniformActionProb < ⊤
      simp only [uniformActionProb, numActions]
      apply ENNReal.div_lt_top
      · simp
      · simp only [ne_eq, Nat.cast_eq_zero, Fintype.card_eq_zero_iff]
        exact not_isEmpty_of_nonempty Action
    · -- μ.prob(...)(s.percept) < ⊤
      -- Use iicPrefixToHistory_append_act_wellFormed to show the history is well-formed
      let hist := iicPrefixToHistory n x ++ [HistElem.act s.action]
      have h_wf := iicPrefixToHistory_append_act_wellFormed n x s.action
      have h_sum_le : (∑' p : Percept, μ.prob hist p) ≤ 1 := μ.prob_le_one hist h_wf
      have h_le_sum : μ.prob hist s.percept ≤ ∑' p : Percept, μ.prob hist p :=
        ENNReal.le_tsum s.percept
      exact lt_of_le_of_lt (le_trans h_le_sum h_sum_le) ENNReal.one_lt_top
  · -- dirac s univ = 1 < ⊤
    simp only [MeasureTheory.Measure.dirac_apply' _ MeasurableSet.univ, Set.indicator_univ,
               Pi.one_apply]
    exact ENNReal.one_lt_top

/-- The transition measure at a singleton equals the product of
    uniformActionProb and the environment probability. -/
theorem transitionMeasure_singleton (μ : Environment) (n : ℕ)
    (x : Π _ : Iic n, Step) (s : Step) :
    transitionMeasure μ n x {s} =
      uniformActionProb * μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept := by
  simp only [transitionMeasure]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]
  -- Only the term for s contributes (Dirac at s gives 1 at {s}, 0 at other singletons)
  conv_lhs =>
    arg 2
    ext s'
    rw [MeasureTheory.Measure.smul_apply, smul_eq_mul]
    rw [MeasureTheory.Measure.dirac_apply' s' (MeasurableSet.singleton s)]
  simp only [Set.mem_singleton_iff, Set.indicator_apply, Pi.one_apply]
  -- Sum over s' : Step where (s' = s ? 1 : 0) contributes
  rw [Finset.sum_eq_single s]
  · -- Main term: s' = s
    simp only [ite_true, mul_one]
  · -- Other terms: s' ≠ s contribute 0
    intro s' _ hs'
    simp only [hs', ite_false, mul_zero]
  · -- s not in Finset.univ is impossible
    intro h_abs
    exact absurd (Finset.mem_univ s) h_abs

/-! ## Transition Measure (Policy Actions)

For on-policy convergence statements we need a probability measure on trajectories
generated by *both*:
1. sampling an action from a (stochastic) policy `π` given the past history, and
2. sampling the next percept from the environment `μ` given that action.

Since the action kernel does not depend on `μ`, likelihood ratios between two
environments still cancel the policy factors (as in Leike's thesis).
-/

/-- Policy-driven transition measure: given prefix x₀..xₙ, sample next action from `π`,
then next percept from `μ`. -/
noncomputable def transitionMeasureWithPolicy (μ : Environment) (π : Agent) (n : ℕ)
    (x : Π _ : Iic n, Step) : MeasureTheory.Measure Step := by
  let h := iicPrefixToHistory n x
  exact MeasureTheory.Measure.sum (fun s : Step =>
    (π.policy h s.action * μ.prob (h ++ [HistElem.act s.action]) s.percept) •
      MeasureTheory.Measure.dirac s)

/-- The policy-driven transition measure is finite. -/
theorem transitionMeasureWithPolicy_finite (μ : Environment) (π : Agent) (n : ℕ)
    (x : Π _ : Iic n, Step) :
    MeasureTheory.IsFiniteMeasure (transitionMeasureWithPolicy μ π n x) := by
  constructor
  simp only [transitionMeasureWithPolicy]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]
  rw [ENNReal.sum_lt_top]
  intro s _
  simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
  apply ENNReal.mul_lt_top
  · -- π(h)(a) * μ.prob(h ++ [act a])(x) < ⊤
    apply ENNReal.mul_lt_top
    · -- π(h)(a) < ⊤, because π(h)(a) ≤ 1
      have h_wf : (iicPrefixToHistory n x).wellFormed := iicPrefixToHistory_wellFormed n x
      have h_le_one :
          π.policy (iicPrefixToHistory n x) s.action ≤ (1 : ENNReal) := by
        have h_le_tsum :
            π.policy (iicPrefixToHistory n x) s.action ≤
              (∑' a : Action, π.policy (iicPrefixToHistory n x) a) :=
          ENNReal.le_tsum s.action
        simpa [π.policy_sum_one _ h_wf] using h_le_tsum
      exact lt_of_le_of_lt h_le_one ENNReal.one_lt_top
    · -- μ.prob(...) < ⊤, because μ.prob(...) ≤ 1
      let hist := iicPrefixToHistory n x ++ [HistElem.act s.action]
      have h_wf := iicPrefixToHistory_append_act_wellFormed n x s.action
      have h_sum_le : (∑' p : Percept, μ.prob hist p) ≤ 1 := μ.prob_le_one hist h_wf
      have h_le_sum : μ.prob hist s.percept ≤ ∑' p : Percept, μ.prob hist p :=
        ENNReal.le_tsum s.percept
      exact lt_of_le_of_lt (le_trans h_le_sum h_sum_le) ENNReal.one_lt_top
  · -- dirac s univ = 1 < ⊤
    simp only [MeasureTheory.Measure.dirac_apply' _ MeasurableSet.univ, Set.indicator_univ,
      Pi.one_apply]
    exact ENNReal.one_lt_top

/-- The policy-driven transition measure at a singleton. -/
theorem transitionMeasureWithPolicy_singleton (μ : Environment) (π : Agent) (n : ℕ)
    (x : Π _ : Iic n, Step) (s : Step) :
    transitionMeasureWithPolicy μ π n x {s} =
      π.policy (iicPrefixToHistory n x) s.action *
        μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept := by
  simp only [transitionMeasureWithPolicy]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]
  conv_lhs =>
    arg 2
    ext s'
    rw [MeasureTheory.Measure.smul_apply, smul_eq_mul]
    rw [MeasureTheory.Measure.dirac_apply' s' (MeasurableSet.singleton s)]
  simp only [Set.mem_singleton_iff, Set.indicator_apply, Pi.one_apply]
  rw [Finset.sum_eq_single s]
  · simp only [ite_true, mul_one]
  · intro s' _ hs'
    simp only [hs', ite_false, mul_zero]
  · intro h_abs
    exact absurd (Finset.mem_univ s) h_abs

/-- Instance: The domain type for our transition kernel is finite. -/
instance (n : ℕ) : Fintype (Π i : Iic n, StepFamily i) := by
  -- Each StepFamily i = Step is finite, and Iic n is finite (has n+1 elements)
  infer_instance

/-- Instance: The domain type has MeasurableSingletonClass. -/
instance (n : ℕ) : MeasurableSingletonClass (Π i : Iic n, StepFamily i) := by
  -- Follows from MeasurableSingletonClass for Step and finite product
  infer_instance

/-- The transition kernel from prefix to next step.

    This is the key ingredient for Ionescu-Tulcea: a kernel
    κ n : Kernel (Π i : Iic n, Step) Step
    that gives the distribution over the next step given the prefix. -/
noncomputable def transitionKernel (μ : Environment) (n : ℕ) :
    ProbabilityTheory.Kernel (Π i : Iic n, StepFamily i) (StepFamily (n + 1)) where
  toFun := transitionMeasure μ n
  measurable' := by
    -- The domain has MeasurableSingletonClass and is Finite, so any function is measurable
    exact measurable_of_finite _

/-- The policy-driven transition kernel. -/
noncomputable def transitionKernelWithPolicy (μ : Environment) (π : Agent) (n : ℕ) :
    ProbabilityTheory.Kernel (Π i : Iic n, StepFamily i) (StepFamily (n + 1)) where
  toFun := transitionMeasureWithPolicy μ π n
  measurable' := by
    exact measurable_of_finite _

/-- The transition kernel is a Markov kernel when the environment is stochastic.
    For each input prefix, the transition measure has total mass 1. -/
theorem transitionKernel_isMarkov (μ : Environment) (n : ℕ)
    (h_stoch : isStochastic μ) :
    IsMarkovKernel (transitionKernel μ n) := by
  constructor
  intro x
  constructor
  -- Need to show transitionMeasure μ n x Set.univ = 1
  show transitionMeasure μ n x Set.univ = 1
  simp only [transitionMeasure]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]

  -- Simplify each term: (c • dirac s) univ = c
  have h_simp : ∀ s : Step,
      ((uniformActionProb * μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept) •
       MeasureTheory.Measure.dirac s) Set.univ =
      uniformActionProb * μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept := by
    intro s
    simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
    rw [MeasureTheory.Measure.dirac_apply' s MeasurableSet.univ]
    simp only [Set.indicator_univ, Pi.one_apply, mul_one]
  simp only [h_simp]

  -- Reindex the sum over Action × Percept
  have h_equiv : ∑ s : Step, uniformActionProb * μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept =
      ∑ p : Action × Percept, uniformActionProb * μ.prob (iicPrefixToHistory n x ++ [HistElem.act p.1]) p.2 := by
    apply Fintype.sum_equiv Step.equiv
    intro s
    rfl
  rw [h_equiv]

  -- Split sum over pairs into sum over actions then percepts
  rw [Fintype.sum_prod_type]

  -- Rewrite as sum over actions of (uniformActionProb * sum over percepts)
  have h_factor : ∀ a : Action,
      ∑ p : Percept, uniformActionProb * μ.prob (iicPrefixToHistory n x ++ [HistElem.act a]) p =
      uniformActionProb * ∑ p : Percept, μ.prob (iicPrefixToHistory n x ++ [HistElem.act a]) p := by
    intro a
    rw [Finset.mul_sum]
  simp only [h_factor]

  -- Each inner sum equals 1 by stochastic property
  have h_inner_eq_one : ∀ a : Action,
      ∑ p : Percept, μ.prob (iicPrefixToHistory n x ++ [HistElem.act a]) p = 1 := by
    intro a
    have h_wf := iicPrefixToHistory_append_act_wellFormed n x a
    have h_stoch_app := h_stoch (iicPrefixToHistory n x ++ [HistElem.act a]) h_wf
    simpa [tsum_fintype] using h_stoch_app

  simp only [h_inner_eq_one, mul_one]

  -- Now: ∑_{a : Action} uniformActionProb = uniformActionProb * |Action| = 1
  rw [Finset.sum_const, Finset.card_univ]
  rw [nsmul_eq_mul]
  rw [mul_comm]
  exact uniformActionProb_sum_eq_one

/-- The policy-driven transition kernel is a Markov kernel when:
1. the environment is stochastic (percepts sum to 1), and
2. the agent policy is stochastic (actions sum to 1). -/
theorem transitionKernelWithPolicy_isMarkov (μ : Environment) (π : Agent) (n : ℕ)
    (h_stoch : isStochastic μ) :
    IsMarkovKernel (transitionKernelWithPolicy μ π n) := by
  constructor
  intro x
  constructor
  show transitionMeasureWithPolicy μ π n x Set.univ = 1
  simp only [transitionMeasureWithPolicy]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]

  have h_simp : ∀ s : Step,
      ((π.policy (iicPrefixToHistory n x) s.action *
            μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept) •
          MeasureTheory.Measure.dirac s) Set.univ =
        π.policy (iicPrefixToHistory n x) s.action *
            μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept := by
    intro s
    simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
    rw [MeasureTheory.Measure.dirac_apply' s MeasurableSet.univ]
    simp only [Set.indicator_univ, Pi.one_apply, mul_one]
  simp only [h_simp]

  -- Reindex over Action × Percept
  have h_equiv :
      ∑ s : Step,
          π.policy (iicPrefixToHistory n x) s.action *
            μ.prob (iicPrefixToHistory n x ++ [HistElem.act s.action]) s.percept =
        ∑ p : Action × Percept,
          π.policy (iicPrefixToHistory n x) p.1 *
            μ.prob (iicPrefixToHistory n x ++ [HistElem.act p.1]) p.2 := by
    apply Fintype.sum_equiv Step.equiv
    intro s
    rfl
  rw [h_equiv]

  -- Split sum over pairs into sum over actions then percepts
  rw [Fintype.sum_prod_type]

  -- Factor the action probability out of the inner percept sum
  have h_factor : ∀ a : Action,
      ∑ p : Percept,
          π.policy (iicPrefixToHistory n x) a *
            μ.prob (iicPrefixToHistory n x ++ [HistElem.act a]) p =
        π.policy (iicPrefixToHistory n x) a *
          ∑ p : Percept, μ.prob (iicPrefixToHistory n x ++ [HistElem.act a]) p := by
    intro a
    rw [Finset.mul_sum]
  simp only [h_factor]

  have h_inner_eq_one : ∀ a : Action,
      ∑ p : Percept, μ.prob (iicPrefixToHistory n x ++ [HistElem.act a]) p = 1 := by
    intro a
    have h_wf := iicPrefixToHistory_append_act_wellFormed n x a
    have h_stoch_app := h_stoch (iicPrefixToHistory n x ++ [HistElem.act a]) h_wf
    simpa [tsum_fintype] using h_stoch_app
  simp only [h_inner_eq_one, mul_one]

  -- Sum over actions is 1 by policy stochasticity
  have h_wf : (iicPrefixToHistory n x).wellFormed := iicPrefixToHistory_wellFormed n x
  -- Convert `tsum` to `Finset.sum`
  simpa [tsum_fintype] using (π.policy_sum_one (iicPrefixToHistory n x) h_wf)

/-! ## Environment Measure via Ionescu-Tulcea

Now we apply the Ionescu-Tulcea theorem to construct the measure on trajectories.
-/

/-- The initial step measure: distribution over the first (action, percept) pair.
    Uses uniform action distribution and environment probability for percept given
    empty history + action. -/
noncomputable def initialStepMeasure (μ : Environment) : MeasureTheory.Measure Step :=
  MeasureTheory.Measure.sum fun s : Step =>
    (uniformActionProb * μ.prob [HistElem.act s.action] s.percept) •
      MeasureTheory.Measure.dirac s

/-- The initial step measure is finite.
    Proof follows transitionMeasure_finite pattern with history = [act a]. -/
theorem initialStepMeasure_finite (μ : Environment) :
    MeasureTheory.IsFiniteMeasure (initialStepMeasure μ) := by
  constructor
  simp only [initialStepMeasure]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]
  rw [ENNReal.sum_lt_top]
  intro s _
  simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
  apply ENNReal.mul_lt_top
  · -- uniformActionProb * μ.prob([act s.action])(s.percept) < ⊤
    apply ENNReal.mul_lt_top
    · -- uniformActionProb < ⊤
      simp only [uniformActionProb, numActions]
      apply ENNReal.div_lt_top
      · simp
      · simp only [ne_eq, Nat.cast_eq_zero, Fintype.card_eq_zero_iff]
        exact not_isEmpty_of_nonempty Action
    · -- μ.prob([act s.action])(s.percept) < ⊤
      let hist : History := [HistElem.act s.action]
      have h_wf : hist.wellFormed := rfl  -- [act a] is well-formed by definition
      have h_sum_le : (∑' p : Percept, μ.prob hist p) ≤ 1 := μ.prob_le_one hist h_wf
      have h_le_sum : μ.prob hist s.percept ≤ ∑' p : Percept, μ.prob hist p :=
        ENNReal.le_tsum s.percept
      exact lt_of_le_of_lt (le_trans h_le_sum h_sum_le) ENNReal.one_lt_top
  · -- dirac s univ = 1 < ⊤
    simp only [MeasureTheory.Measure.dirac_apply' _ MeasurableSet.univ, Set.indicator_univ,
               Pi.one_apply]
    exact ENNReal.one_lt_top

/-- The initial step measure is a probability measure when the environment is stochastic.
    Sum over all (action, percept) pairs equals 1.
    The proof pattern mirrors transitionKernel_isMarkov:
    ∑_(a,p) uniformActionProb * μ.prob [act a] p
    = ∑_a uniformActionProb * (∑_p μ.prob [act a] p)
    = ∑_a uniformActionProb * 1  (by stochasticity)
    = uniformActionProb * |Action| = 1  -/
instance initialStepMeasure_isProbability (μ : Environment) (h_stoch : isStochastic μ) :
    MeasureTheory.IsProbabilityMeasure (initialStepMeasure μ) := by
  constructor
  -- Need to show initialStepMeasure μ Set.univ = 1
  simp only [initialStepMeasure]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]

  -- Simplify each term: (c • dirac s) univ = c
  have h_simp : ∀ s : Step,
      ((uniformActionProb * μ.prob [HistElem.act s.action] s.percept) •
       MeasureTheory.Measure.dirac s) Set.univ =
      uniformActionProb * μ.prob [HistElem.act s.action] s.percept := by
    intro s
    simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
    rw [MeasureTheory.Measure.dirac_apply' s MeasurableSet.univ]
    simp only [Set.indicator_univ, Pi.one_apply, mul_one]
  simp only [h_simp]

  -- Reindex the sum over Action × Percept
  have h_equiv : ∑ s : Step, uniformActionProb * μ.prob [HistElem.act s.action] s.percept =
      ∑ p : Action × Percept, uniformActionProb * μ.prob [HistElem.act p.1] p.2 := by
    apply Fintype.sum_equiv Step.equiv
    intro s
    rfl
  rw [h_equiv]

  -- Split sum over pairs into sum over actions then percepts
  rw [Fintype.sum_prod_type]

  -- Rewrite as sum over actions of (uniformActionProb * sum over percepts)
  have h_factor : ∀ a : Action,
      ∑ p : Percept, uniformActionProb * μ.prob [HistElem.act a] p =
      uniformActionProb * ∑ p : Percept, μ.prob [HistElem.act a] p := by
    intro a
    rw [Finset.mul_sum]
  simp only [h_factor]

  -- Each inner sum equals 1 by stochastic property
  -- [act a] is well-formed by definition
  have h_inner_eq_one : ∀ a : Action,
      ∑ p : Percept, μ.prob [HistElem.act a] p = 1 := by
    intro a
    have h_wf : History.wellFormed [HistElem.act a] := rfl
    have h_stoch_app := h_stoch [HistElem.act a] h_wf
    simpa [tsum_fintype] using h_stoch_app

  simp only [h_inner_eq_one, mul_one]

  -- Now: ∑_{a : Action} uniformActionProb = uniformActionProb * |Action| = 1
  rw [Finset.sum_const, Finset.card_univ]
  rw [nsmul_eq_mul]
  rw [mul_comm]
  exact uniformActionProb_sum_eq_one

/-! ## Policy-Driven Environment Measure

Leike's on-policy results reason about the probability space induced by running
**a fixed stochastic policy** `π` in an environment `μ`.

We therefore build an Ionescu–Tulcea measure where at each cycle we:
1. sample an action from `π` given the current history, and
2. sample a percept from `μ` given that action.
-/

/-- The initial step measure for a policy-driven process.

This samples `a₀ ~ π(∅)` and then `x₀ ~ μ(· | a₀)`, yielding the first `Step = ⟨a₀, x₀⟩`. -/
noncomputable def initialStepMeasureWithPolicy (μ : Environment) (π : Agent) :
    MeasureTheory.Measure Step :=
  MeasureTheory.Measure.sum fun s : Step =>
    (π.policy [] s.action * μ.prob [HistElem.act s.action] s.percept) •
      MeasureTheory.Measure.dirac s

/-- The policy-driven initial step measure is finite. -/
theorem initialStepMeasureWithPolicy_finite (μ : Environment) (π : Agent) :
    MeasureTheory.IsFiniteMeasure (initialStepMeasureWithPolicy μ π) := by
  constructor
  simp only [initialStepMeasureWithPolicy]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]
  rw [ENNReal.sum_lt_top]
  intro s _
  simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
  apply ENNReal.mul_lt_top
  · apply ENNReal.mul_lt_top
    · -- π(∅)(a) < ⊤, because π(∅)(a) ≤ 1
      have h_wf : History.wellFormed ([] : History) := rfl
      have h_le_one : π.policy ([] : History) s.action ≤ (1 : ENNReal) := by
        have h_le_tsum :
            π.policy ([] : History) s.action ≤ (∑' a : Action, π.policy ([] : History) a) :=
          ENNReal.le_tsum s.action
        simpa [π.policy_sum_one _ h_wf] using h_le_tsum
      exact lt_of_le_of_lt h_le_one ENNReal.one_lt_top
    · -- μ.prob([act a])(x) < ⊤, because ≤ 1
      let hist : History := [HistElem.act s.action]
      have h_wf : hist.wellFormed := rfl
      have h_sum_le : (∑' p : Percept, μ.prob hist p) ≤ 1 := μ.prob_le_one hist h_wf
      have h_le_sum : μ.prob hist s.percept ≤ ∑' p : Percept, μ.prob hist p :=
        ENNReal.le_tsum s.percept
      exact lt_of_le_of_lt (le_trans h_le_sum h_sum_le) ENNReal.one_lt_top
  · simp only [MeasureTheory.Measure.dirac_apply' _ MeasurableSet.univ, Set.indicator_univ,
      Pi.one_apply]
    exact ENNReal.one_lt_top

/-- The policy-driven initial step measure is a probability measure when the environment is stochastic. -/
instance initialStepMeasureWithPolicy_isProbability (μ : Environment) (π : Agent)
    (h_stoch : isStochastic μ) :
    MeasureTheory.IsProbabilityMeasure (initialStepMeasureWithPolicy μ π) := by
  constructor
  simp only [initialStepMeasureWithPolicy]
  rw [MeasureTheory.Measure.sum_apply_of_countable]
  rw [tsum_fintype]

  have h_simp : ∀ s : Step,
      ((π.policy ([] : History) s.action * μ.prob [HistElem.act s.action] s.percept) •
          MeasureTheory.Measure.dirac s) Set.univ =
        π.policy ([] : History) s.action * μ.prob [HistElem.act s.action] s.percept := by
    intro s
    simp only [MeasureTheory.Measure.smul_apply, smul_eq_mul]
    rw [MeasureTheory.Measure.dirac_apply' s MeasurableSet.univ]
    simp only [Set.indicator_univ, Pi.one_apply, mul_one]
  simp only [h_simp]

  have h_equiv :
      ∑ s : Step, π.policy ([] : History) s.action * μ.prob [HistElem.act s.action] s.percept =
        ∑ p : Action × Percept, π.policy ([] : History) p.1 * μ.prob [HistElem.act p.1] p.2 := by
    apply Fintype.sum_equiv Step.equiv
    intro s
    rfl
  rw [h_equiv]

  rw [Fintype.sum_prod_type]

  have h_factor : ∀ a : Action,
      ∑ p : Percept, π.policy ([] : History) a * μ.prob [HistElem.act a] p =
        π.policy ([] : History) a * ∑ p : Percept, μ.prob [HistElem.act a] p := by
    intro a
    rw [Finset.mul_sum]
  simp only [h_factor]

  have h_inner_eq_one : ∀ a : Action, ∑ p : Percept, μ.prob [HistElem.act a] p = 1 := by
    intro a
    have h_wf : History.wellFormed ([HistElem.act a] : History) := rfl
    have h_stoch_app := h_stoch [HistElem.act a] h_wf
    simpa [tsum_fintype] using h_stoch_app
  simp only [h_inner_eq_one, mul_one]

  have h_wf : History.wellFormed ([] : History) := rfl
  simpa [tsum_fintype] using (π.policy_sum_one ([] : History) h_wf)

/-- Convert between Step and the domain of traj at a = 0.
    Iic 0 = {0}, so Π i : Iic 0, Step is isomorphic to Step. -/
def stepToIic0 : Step ≃ (Π i : Iic 0, StepFamily i) where
  toFun s := fun _ => s
  invFun f := f ⟨0, mem_Iic.2 (le_rfl)⟩
  left_inv _ := rfl
  right_inv f := by
    funext ⟨i, hi⟩
    have hi' : i = 0 := Nat.le_zero.mp (mem_Iic.1 hi)
    subst hi'
    rfl

/-- stepToIic0 is measurable. -/
theorem stepToIic0_measurable : Measurable stepToIic0 := by
  apply measurable_pi_lambda
  intro _
  exact measurable_id

/-- The initial measure on the `Iic 0` domain for the policy-driven process. -/
noncomputable def initialMeasureIic0WithPolicy (μ : Environment) (π : Agent) :
    MeasureTheory.Measure (Π i : Iic 0, StepFamily i) :=
  (initialStepMeasureWithPolicy μ π).map stepToIic0

/-- The policy-driven initial measure is a probability measure (when the environment is stochastic). -/
instance initialMeasureIic0WithPolicy_isProbability (μ : Environment) (π : Agent)
    (h_stoch : isStochastic μ) :
    MeasureTheory.IsProbabilityMeasure (initialMeasureIic0WithPolicy μ π) := by
  haveI : MeasureTheory.IsProbabilityMeasure (initialStepMeasureWithPolicy μ π) :=
    initialStepMeasureWithPolicy_isProbability μ π h_stoch
  constructor
  simp only [initialMeasureIic0WithPolicy]
  rw [MeasureTheory.Measure.map_apply stepToIic0_measurable MeasurableSet.univ]
  simp only [Set.preimage_univ]
  exact MeasureTheory.measure_univ

/-- The environment measure on trajectories induced by policy `π` via Ionescu–Tulcea. -/
noncomputable def environmentMeasureWithPolicy (μ : Environment) (π : Agent) (h_stoch : isStochastic μ) :
    MeasureTheory.Measure Trajectory :=
  have hκ : ∀ n, IsMarkovKernel (transitionKernelWithPolicy μ π n) :=
    fun n => transitionKernelWithPolicy_isMarkov μ π n h_stoch
  let _ : (n : Nat) -> IsMarkovKernel (transitionKernelWithPolicy μ π n) := hκ
  Mettapedia.UniversalAI.InfiniteHistory.trajMeasureOf (X := StepFamily)
    (κ := transitionKernelWithPolicy μ π) 0 (initialMeasureIic0WithPolicy μ π)

/-- The policy-driven environment measure is a probability measure. -/
theorem environmentMeasureWithPolicy_isProbability (μ : Environment) (π : Agent) (h_stoch : isStochastic μ) :
    MeasureTheory.IsProbabilityMeasure (environmentMeasureWithPolicy μ π h_stoch) := by
  simp [environmentMeasureWithPolicy]
  haveI : MeasureTheory.IsProbabilityMeasure (initialMeasureIic0WithPolicy μ π) :=
    initialMeasureIic0WithPolicy_isProbability μ π h_stoch
  haveI : ∀ n, ProbabilityTheory.IsMarkovKernel (transitionKernelWithPolicy μ π n) :=
    fun n => transitionKernelWithPolicy_isMarkov μ π n h_stoch
  infer_instance

/-- The policy-driven environment measure is σ-finite. -/
instance environmentMeasureWithPolicy_sigmaFinite (μ : Environment) (π : Agent) (h_stoch : isStochastic μ) :
    MeasureTheory.SigmaFinite (environmentMeasureWithPolicy μ π h_stoch) := by
  haveI : MeasureTheory.IsProbabilityMeasure (environmentMeasureWithPolicy μ π h_stoch) :=
    environmentMeasureWithPolicy_isProbability μ π h_stoch
  infer_instance

/-- The policy-driven environment measure of `univ` is `1`. -/
theorem environmentMeasureWithPolicy_univ_eq_one (μ : Environment) (π : Agent) (h_stoch : isStochastic μ) :
    environmentMeasureWithPolicy μ π h_stoch Set.univ = 1 := by
  haveI : MeasureTheory.IsProbabilityMeasure (environmentMeasureWithPolicy μ π h_stoch) :=
    environmentMeasureWithPolicy_isProbability μ π h_stoch
  exact MeasureTheory.measure_univ

/-- The initial measure on the Iic 0 domain. -/
noncomputable def initialMeasureIic0 (μ : Environment) :
    MeasureTheory.Measure (Π i : Iic 0, StepFamily i) :=
  (initialStepMeasure μ).map stepToIic0

/-- The initial measure is a probability measure when the environment is stochastic.
    Follows from the fact that stepToIic0 is a measurable equivalence
    and measurable equivalences preserve the measure of univ. -/
instance initialMeasureIic0_isProbability (μ : Environment) (h_stoch : isStochastic μ) :
    MeasureTheory.IsProbabilityMeasure (initialMeasureIic0 μ) := by
  haveI : MeasureTheory.IsProbabilityMeasure (initialStepMeasure μ) :=
    initialStepMeasure_isProbability μ h_stoch
  constructor
  simp only [initialMeasureIic0]
  rw [MeasureTheory.Measure.map_apply stepToIic0_measurable MeasurableSet.univ]
  simp only [Set.preimage_univ]
  exact MeasureTheory.measure_univ

/-- The environment measure on trajectories, constructed via Ionescu-Tulcea.

    Given a stochastic environment (where percept probabilities sum to 1),
    we construct the measure on trajectories using:
    1. initialMeasureIic0 (distribution over first step)
    2. Kernel.traj (transitionKernel μ) 0 (Ionescu-Tulcea extension to full trajectories)
    3. Composition via Measure.bind (∘ₘ notation)

    This is the unique probability measure on trajectories consistent with
    the environment's transition probabilities. -/
noncomputable def environmentMeasure (μ : Environment) (h_stoch : isStochastic μ) :
    MeasureTheory.Measure Trajectory :=
  -- Apply Ionescu-Tulcea: bind initial distribution with traj kernel
  -- Explicitly provide all type parameters to avoid Iic/Finset.Iic ambiguity
  have hκ : ∀ n, IsMarkovKernel (transitionKernel μ n) :=
    fun n => transitionKernel_isMarkov μ n h_stoch
  let _ : (n : Nat) -> IsMarkovKernel (transitionKernel μ n) := hκ
  Mettapedia.UniversalAI.InfiniteHistory.trajMeasureOf (X := StepFamily)
    (κ := transitionKernel μ) 0 (initialMeasureIic0 μ)

/-- The environment measure is a probability measure.
    Follows from Ionescu-Tulcea: traj applied to a probability measure
    (initialMeasureIic0) yields a probability measure.

    Uses the instance from Mathlib/Probability/Kernel/Composition/MeasureComp.lean:
    `instance [IsProbabilityMeasure μ] [IsMarkovKernel κ] : IsProbabilityMeasure (κ ∘ₘ μ)`

    Combined with:
    - `initialMeasureIic0_isProbability` : IsProbabilityMeasure (initialMeasureIic0 μ)
    - `Kernel.traj_instIsMarkovKernel` : IsMarkovKernel (traj κ a)
-/
theorem environmentMeasure_isProbability (μ : Environment) (h_stoch : isStochastic μ) :
    MeasureTheory.IsProbabilityMeasure (environmentMeasure μ h_stoch) := by
  simp [environmentMeasure]
  -- Provides: IsProbabilityMeasure (initialMeasureIic0 μ) from earlier instance
  haveI : MeasureTheory.IsProbabilityMeasure (initialMeasureIic0 μ) :=
    initialMeasureIic0_isProbability μ h_stoch
  -- The transition kernels are Markov (from transitionKernel_isMarkov)
  haveI : ∀ n, ProbabilityTheory.IsMarkovKernel (transitionKernel μ n) :=
    fun n => transitionKernel_isMarkov μ n h_stoch
  -- Kernel.traj is a Markov kernel (Mathlib instance at Traj.lean:517)
  -- Composition of Markov kernel with probability measure is probability measure
  -- (Mathlib instance at MeasureComp.lean:70)
  infer_instance

/-- The environment measure is σ-finite (follows from being a probability measure). -/
instance environmentMeasure_sigmaFinite (μ : Environment) (h_stoch : isStochastic μ) :
    MeasureTheory.SigmaFinite (environmentMeasure μ h_stoch) := by
  haveI : MeasureTheory.IsProbabilityMeasure (environmentMeasure μ h_stoch) :=
    environmentMeasure_isProbability μ h_stoch
  infer_instance

/-- The environment measure of the full space is 1.
    Follows immediately from being a probability measure. -/
theorem environmentMeasure_univ_eq_one (μ : Environment) (h_stoch : isStochastic μ) :
    environmentMeasure μ h_stoch Set.univ = 1 := by
  haveI : MeasureTheory.IsProbabilityMeasure (environmentMeasure μ h_stoch) :=
    environmentMeasure_isProbability μ h_stoch
  exact MeasureTheory.measure_univ

/-- **Base case for IT factorization (policy-driven)**: the policy-driven environment measure
of the set where step `0` equals a specific value equals the policy-driven initial step mass. -/
theorem environmentMeasureWithPolicy_step0_singleton (μ : Environment) (π : Agent)
    (h_stoch : isStochastic μ) (s : Step) :
    environmentMeasureWithPolicy μ π h_stoch {traj | traj 0 = s} =
      π.policy [] s.action * μ.prob [HistElem.act s.action] s.percept := by
  classical
  have h_set :
      ({traj : Trajectory | traj 0 = s} : Set Trajectory) =
        (frestrictLe (π := StepFamily) 0) ⁻¹' ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
    ext traj
    constructor
    · intro h0
      have h_eq : frestrictLe (π := StepFamily) 0 traj = stepToIic0 s := by
        funext i
        rcases i with ⟨i, hi⟩
        have hi0 : i = 0 := Nat.le_zero.mp (mem_Iic.1 hi)
        subst hi0
        simpa [frestrictLe_apply, stepToIic0, h0]
      simpa [Set.mem_preimage, Set.mem_singleton_iff] using h_eq
    · intro hmem
      have h_eq : frestrictLe (π := StepFamily) 0 traj = stepToIic0 s := by
        simpa [Set.mem_preimage, Set.mem_singleton_iff] using hmem
      have h_at0 := congrArg (fun f => f ⟨0, mem_Iic.2 (le_rfl)⟩) h_eq
      simpa [frestrictLe_apply, stepToIic0] using h_at0

  have h_map :
      (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) 0) =
        initialMeasureIic0WithPolicy μ π := by
    haveI : ∀ n, IsMarkovKernel (transitionKernelWithPolicy μ π n) :=
      fun n => transitionKernelWithPolicy_isMarkov μ π n h_stoch
    have hf : Measurable (frestrictLe (π := StepFamily) 0) :=
      measurable_frestrictLe (X := StepFamily) 0
    simp [environmentMeasureWithPolicy]
    rw [MeasureTheory.Measure.map_comp (μ := initialMeasureIic0WithPolicy μ π)
      (κ := @Kernel.traj StepFamily (fun _ => inferInstance) (transitionKernelWithPolicy μ π)
        (fun n => transitionKernelWithPolicy_isMarkov μ π n h_stoch) 0) hf]
    rw [Kernel.traj_map_frestrictLe, Kernel.partialTraj_self]
    simp

  have hs_iic0 : MeasurableSet ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
    simp
  have hf0 : Measurable (frestrictLe (π := StepFamily) 0) := measurable_frestrictLe (X := StepFamily) 0

  calc
    environmentMeasureWithPolicy μ π h_stoch {traj | traj 0 = s}
        = environmentMeasureWithPolicy μ π h_stoch ((frestrictLe (π := StepFamily) 0) ⁻¹'
            ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i))) := by
              simp [h_set]
    _ = (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) 0)
          ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
            simpa using
              (MeasureTheory.Measure.map_apply (μ := environmentMeasureWithPolicy μ π h_stoch) hf0 hs_iic0).symm
    _ = initialMeasureIic0WithPolicy μ π ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
          simp [h_map]
    _ = initialStepMeasureWithPolicy μ π {s} := by
          have hs_step : MeasurableSet ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by simp
          have h_pre :
              stepToIic0 ⁻¹' ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) = ({s} : Set Step) := by
            ext s'
            simp
          simp [initialMeasureIic0WithPolicy,
            MeasureTheory.Measure.map_apply stepToIic0_measurable hs_step, h_pre]
    _ = π.policy [] s.action * μ.prob [HistElem.act s.action] s.percept := by
          have hs : MeasurableSet ({s} : Set Step) := by simp
          simp only [initialStepMeasureWithPolicy]
          rw [MeasureTheory.Measure.sum_apply_of_countable]
          rw [tsum_fintype]
          conv_lhs =>
            arg 2
            ext x
            rw [MeasureTheory.Measure.smul_apply, smul_eq_mul]
            rw [MeasureTheory.Measure.dirac_apply' x hs]
          simp only [Set.mem_singleton_iff, Set.indicator_apply, Pi.one_apply]
          rw [Finset.sum_eq_single s]
          · simp
          · intro x _ hx
            simp [hx]
          · intro h_abs
            exact absurd (Finset.mem_univ s) h_abs

/-- **Base case for IT factorization**: The environment measure of the set where step 0
    equals a specific value equals the initial step probability.

    This connects the IT construction back to our explicit probability formula.
    The proof unfolds the IT construction:
    1. environmentMeasure = traj κ 0 ∘ₘ initialMeasureIic0 μ
    2. For the set {traj | traj 0 = s}, the traj kernel gives measure 1 when
       the input has step 0 = s, and 0 otherwise
    3. So the integral over initialMeasureIic0 gives exactly the initial step measure of {s}
    4. Which equals uniformActionProb * μ.prob [act s.action] s.percept -/
theorem environmentMeasure_step0_singleton (μ : Environment) (h_stoch : isStochastic μ) (s : Step) :
    environmentMeasure μ h_stoch {traj | traj 0 = s} =
      uniformActionProb * μ.prob [HistElem.act s.action] s.percept := by
  classical
  have h_set :
      ({traj : Trajectory | traj 0 = s} : Set Trajectory) =
        (frestrictLe (π := StepFamily) 0) ⁻¹' ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
    ext traj
    constructor
    · intro h0
      -- Show `frestrictLe 0 traj = stepToIic0 s`
      have h_eq : frestrictLe (π := StepFamily) 0 traj = stepToIic0 s := by
        funext i
        rcases i with ⟨i, hi⟩
        have hi0 : i = 0 := Nat.le_zero.mp (mem_Iic.1 hi)
        subst hi0
        simpa [frestrictLe_apply, stepToIic0, h0]
      simpa [Set.mem_preimage, Set.mem_singleton_iff] using h_eq
    · intro hmem
      have h_eq : frestrictLe (π := StepFamily) 0 traj = stepToIic0 s := by
        simpa [Set.mem_preimage, Set.mem_singleton_iff] using hmem
      have h_at0 :=
        congrArg (fun f => f ⟨0, mem_Iic.2 (le_rfl)⟩) h_eq
      simpa [frestrictLe_apply, stepToIic0] using h_at0

  have h_map :
      (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) 0) =
        initialMeasureIic0 μ := by
    -- Map the IT measure down to the `Iic 0` prefix. This is exactly the initial measure.
    haveI : ∀ n, IsMarkovKernel (transitionKernel μ n) :=
      fun n => transitionKernel_isMarkov μ n h_stoch
    have hf : Measurable (frestrictLe (π := StepFamily) 0) := measurable_frestrictLe (X := StepFamily) 0
    simp [environmentMeasure]
    -- `map_comp` pushes `map` through `∘ₘ`
    rw [MeasureTheory.Measure.map_comp (μ := initialMeasureIic0 μ)
      (κ := @Kernel.traj StepFamily (fun _ => inferInstance) (transitionKernel μ)
        (fun n => transitionKernel_isMarkov μ n h_stoch) 0) hf]
    -- `traj` restricted to time 0 is the identity kernel
    rw [Kernel.traj_map_frestrictLe, Kernel.partialTraj_self]
    simp

  have hs_iic0 : MeasurableSet ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
    simp
  have hf0 : Measurable (frestrictLe (π := StepFamily) 0) := measurable_frestrictLe (X := StepFamily) 0

  calc
    environmentMeasure μ h_stoch {traj | traj 0 = s}
        = environmentMeasure μ h_stoch ((frestrictLe (π := StepFamily) 0) ⁻¹'
            ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i))) := by
              simp [h_set]
    _ = (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) 0)
          ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
            simpa using (MeasureTheory.Measure.map_apply (μ := environmentMeasure μ h_stoch) hf0 hs_iic0).symm
    _ = initialMeasureIic0 μ ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by
          simp [h_map]
    _ = initialStepMeasure μ {s} := by
          -- Unfold the map defining `initialMeasureIic0` and simplify the singleton preimage
          have hs_step : MeasurableSet ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) := by simp
          have h_pre :
              stepToIic0 ⁻¹' ({stepToIic0 s} : Set (Π i : Iic 0, StepFamily i)) = ({s} : Set Step) := by
            ext s'
            simp
          simp [initialMeasureIic0, MeasureTheory.Measure.map_apply stepToIic0_measurable hs_step, h_pre]
    _ = uniformActionProb * μ.prob [HistElem.act s.action] s.percept := by
          -- Evaluate the explicit sum-of-diracs definition at a singleton.
          have hs : MeasurableSet ({s} : Set Step) := by simp
          -- Reduce to a finite sum where only the `x = s` term survives.
          simp only [initialStepMeasure]
          rw [MeasureTheory.Measure.sum_apply_of_countable]
          rw [tsum_fintype]
          conv_lhs =>
            arg 2
            ext x
            rw [MeasureTheory.Measure.smul_apply, smul_eq_mul]
            rw [MeasureTheory.Measure.dirac_apply' x hs]
          simp only [Set.mem_singleton_iff, Set.indicator_apply, Pi.one_apply]
          rw [Finset.sum_eq_single s]
          · simp
          · intro x _ hx
            simp [hx]
          · intro h_abs
            exact (h_abs (Finset.mem_univ s)).elim

/-! ## Key Properties of Environment Measure

These properties characterize the environment measure and would follow
from the Ionescu-Tulcea construction.
-/

/-- The probability of a cylinder set defined by history h.
    This is the key property connecting measure theory to our discrete setup. -/
def cylinderSet (h : History) : Set Trajectory :=
  {traj | ∃ t, trajectoryToHistory traj t = h}

/-- Cylinder set at a fixed time: trajectories producing history h at time t. -/
def cylinderSetAt (t : ℕ) (h : History) : Set Trajectory :=
  {traj | trajectoryToHistory traj t = h}

/-- Convert a finite prefix to a history.
    This is the finite version of trajectoryToHistory. -/
def prefixToHistory (t : ℕ) (f : Fin t → Step) : History :=
  (List.finRange t).flatMap fun i =>
    [HistElem.act (f i).action, HistElem.per (f i).percept]

/-- prefixToHistory agrees with trajectoryToHistory on truncation.

    Both compute the same thing: enumerate i ∈ [0, t) and map each to
    [HistElem.act (traj i).action, HistElem.per (traj i).percept].
    The only difference is List.finRange vs List.range for the enumeration. -/
theorem prefixToHistory_eq_trajectoryToHistory (t : ℕ) (traj : Trajectory) :
    prefixToHistory t (truncate t traj) = trajectoryToHistory traj t := by
  unfold prefixToHistory trajectoryToHistory truncate
  -- Use List.flatMap_map: (l.map f).flatMap g = l.flatMap (g ∘ f)
  -- In reverse: l.flatMap (g ∘ f) = (l.map f).flatMap g
  -- We have LHS: (List.finRange t).flatMap (fun i => [act (traj i.val).., per (traj i.val)..])
  -- We want: (List.range t).flatMap (fun n => [act (traj n).., per (traj n)..])
  -- Key: (List.finRange t).map Fin.val = List.range t (by List.map_coe_finRange)
  rw [← List.map_coe_finRange t]
  rw [List.flatMap_map]

/-! ### Inverting `prefixToHistory` on well-formed histories -/

/-- `prefixToHistory` decomposes at `t+1` into the first step and the remaining prefix. -/
theorem prefixToHistory_succ (t : ℕ) (f : Fin (t + 1) → Step) :
    prefixToHistory (t + 1) f =
      [HistElem.act (f ⟨0, Nat.succ_pos t⟩).action, HistElem.per (f ⟨0, Nat.succ_pos t⟩).percept] ++
        prefixToHistory t (fun i => f i.succ) := by
  unfold prefixToHistory
  -- `finRange (t+1) = 0 :: (finRange t).map Fin.succ`
  simp [List.finRange_succ, List.flatMap_cons, List.flatMap_map]

/-- Extract the `Fin t → Step` prefix encoded by a history, dropping ill-formed cases.

This is the (computable) inverse to `prefixToHistory` on well-formed histories of length `2t`. -/
def historyToFinPrefix : (t : ℕ) → History → (Fin t → Step)
  | 0, _ => fun i => nomatch i
  | Nat.succ t, HistElem.act a :: HistElem.per p :: rest =>
      fun i => Fin.cases (Step.mk a p) (fun j => historyToFinPrefix t rest j) i
  | Nat.succ _t, _ => fun _ => default

@[simp] theorem historyToFinPrefix_zero (h : History) :
    historyToFinPrefix 0 h = fun i => nomatch i := rfl

@[simp] theorem historyToFinPrefix_succ_act_per (t : ℕ) (a : Action) (p : Percept) (rest : History) :
    historyToFinPrefix (t + 1) (HistElem.act a :: HistElem.per p :: rest) =
      fun i => Fin.cases (Step.mk a p) (fun j => historyToFinPrefix t rest j) i := rfl

/-! `historyToFinPrefix` and `prefixToHistory` are inverse on the `prefixToHistory` image. -/

theorem historyToFinPrefix_prefixToHistory (t : ℕ) (f : Fin t → Step) :
    historyToFinPrefix t (prefixToHistory t f) = f := by
  induction t with
  | zero =>
    funext i
    exact (nomatch i)
  | succ t ih =>
    funext i
    -- Peel the `Fin (t+1)` index and use `prefixToHistory_succ`.
    cases i using Fin.cases with
    | zero =>
      simp [prefixToHistory_succ]
    | succ j =>
      simp [prefixToHistory_succ, ih]

/-! `prefixToHistory` is a left inverse to `historyToFinPrefix` on well-formed, complete histories. -/

theorem prefixToHistory_historyToFinPrefix (t : ℕ) (h : History)
    (hw : h.wellFormed) (hlen : h.length = 2 * t) :
    prefixToHistory t (historyToFinPrefix t h) = h := by
  induction t generalizing h with
  | zero =>
    -- `h.length = 0` forces `h = []`.
    cases h with
    | nil =>
      simp [prefixToHistory, historyToFinPrefix]
    | cons _ _ =>
      simp [List.length_cons] at hlen
  | succ t ih =>
    cases h with
    | nil =>
      -- `0 = 2 * (t+1)` is impossible.
      simp at hlen
    | cons e rest =>
      cases e with
      | per _ =>
        -- A well-formed history cannot start with a percept.
        simp [History.wellFormed] at hw
      | act a =>
        cases rest with
        | nil =>
          -- length 1 contradicts `2 * (t+1)`.
          exfalso
          have hlen' : 1 = 2 * (t + 1) := by
            simpa [List.length_cons] using hlen
          omega
        | cons e2 rest2 =>
          cases e2 with
          | act _ =>
            simp [History.wellFormed] at hw
          | per p =>
            have hw_rest2 : History.wellFormed rest2 = true := by
              simpa [History.wellFormed] using hw
            have hlen_rest2 : rest2.length = 2 * t := by
              have hlen' : rest2.length + 2 = 2 * (t + 1) := by
                simpa [List.length_cons] using hlen
              have hlen'' : rest2.length + 2 = 2 * t + 2 := by
                simpa [Nat.mul_add, Nat.mul_one, Nat.add_assoc, Nat.add_left_comm, Nat.add_comm] using hlen'
              exact Nat.add_right_cancel hlen''
            -- Evaluate `historyToFinPrefix` at the head and use IH on the tail.
            simp [historyToFinPrefix, prefixToHistory_succ, ih rest2 hw_rest2 hlen_rest2]


/-- Cylinder set at fixed time is measurable.

    The key insight is that the cylinder set is a preimage under truncation of a
    measurable set in the finite product space. Since `Fin t → Step` has
    `MeasurableSingletonClass` (finite product of finite types with discrete σ-algebras),
    all sets are measurable there. -/
theorem cylinderSetAt_measurable (t : ℕ) (h : History) :
    MeasurableSet (cylinderSetAt t h) := by
  unfold cylinderSetAt
  -- The set is determined by first t coordinates, so it's in sigmaAlgebraUpTo t
  apply sigmaAlgebraUpTo_le t
  -- Express as preimage under truncate
  simp only [sigmaAlgebraUpTo, MeasurableSpace.comap]
  -- Define the target set in Fin t → Step
  let targetSet : Set (Fin t → Step) := {f | prefixToHistory t f = h}
  use targetSet
  constructor
  · -- targetSet is measurable in (Fin t → Step, MeasurableSpace.pi)
    -- Since Fin t is countable and Step has MeasurableSingletonClass,
    -- (Fin t → Step) has MeasurableSingletonClass by Pi.instMeasurableSingletonClass.
    -- Any subset of a finite type is finite, hence measurable.
    have hfin : Set.Finite targetSet := Set.toFinite targetSet
    exact hfin.measurableSet
  · -- Show equality: {traj | trajectoryToHistory traj t = h} = (truncate t)⁻¹' targetSet
    ext traj
    simp only [Set.mem_setOf_eq, Set.mem_preimage, targetSet]
    rw [← prefixToHistory_eq_trajectoryToHistory]

/-- Cylinder sets are measurable.
    The cylinder set is the set of trajectories that produce history h at some time.
    For a history h of length 2t, only that specific t works. -/
theorem cylinderSet_measurable (h : History) :
    MeasurableSet (cylinderSet h) := by
  unfold cylinderSet
  -- Express as countable union of cylinderSetAt
  have h_union : {traj | ∃ t, trajectoryToHistory traj t = h} =
      ⋃ t : ℕ, cylinderSetAt t h := by
    ext traj
    simp only [Set.mem_setOf_eq, Set.mem_iUnion, cylinderSetAt]
  rw [h_union]
  exact MeasurableSet.iUnion (fun t => cylinderSetAt_measurable t h)

/-- The number of steps (action-percept pairs) in a well-formed history. -/
def historySteps (h : History) : ℕ := h.length / 2

/-- historySteps decomposes for [act a, per x, rest']. -/
theorem historySteps_cons_cons (a : Action) (x : Percept) (rest' : History) :
    historySteps (HistElem.act a :: HistElem.per x :: rest') = 1 + historySteps rest' := by
  simp only [historySteps, List.length_cons]
  -- Goal: (rest'.length + 1 + 1) / 2 = 1 + rest'.length / 2
  -- This is (rest'.length + 2) / 2 = 1 + rest'.length / 2
  have h : rest'.length + 1 + 1 = rest'.length + 2 := by ring
  rw [h]
  rw [Nat.add_div_right rest'.length (by norm_num : 0 < 2)]
  ring

/-- historyProbability decomposes for [act a, per x, rest'].
    This uses the accumulator-based definition of historyProbabilityAux. -/
theorem historyProbability_cons_cons (μ : Environment) (a : Action) (x : Percept) (rest' : History) :
    historyProbability μ (HistElem.act a :: HistElem.per x :: rest') =
      μ.prob [HistElem.act a] x * historyProbabilityAux μ [HistElem.act a, HistElem.per x] rest' := by
  -- Unfold historyProbability and historyProbabilityAux
  simp only [historyProbability, historyProbabilityAux]
  -- The prefix starts empty, then extends to [act a, per x]
  simp only [List.nil_append]

/-! ## Trajectory Shift and Cylinder Set Decomposition -/

/-- Shift a trajectory by one step: (shift traj) i = traj (i + 1). -/
def shiftTrajectory (traj : Trajectory) : Trajectory := fun i => traj (i + 1)

/-- Shifting preserves the relationship with trajectoryToHistory. -/
theorem trajectoryToHistory_shift (traj : Trajectory) (t : ℕ) :
    trajectoryToHistory (shiftTrajectory traj) t =
      (List.range t).flatMap fun i =>
        [HistElem.act (traj (i + 1)).action, HistElem.per (traj (i + 1)).percept] := by
  simp only [trajectoryToHistory, shiftTrajectory]

/-- trajectoryToHistory at (t+1) equals the first step plus shifted trajectory. -/
theorem trajectoryToHistory_succ_eq (traj : Trajectory) (t : ℕ) :
    trajectoryToHistory traj (t + 1) =
      [HistElem.act (traj 0).action, HistElem.per (traj 0).percept] ++
        trajectoryToHistory (shiftTrajectory traj) t := by
  induction t with
  | zero =>
    simp only [Nat.zero_add, trajectoryToHistory, shiftTrajectory, List.range_zero,
               List.flatMap_nil, List.append_nil]
    -- Goal: (List.range 1).flatMap f = [f 0]
    rfl
  | succ t ih =>
    -- Use the existing trajectoryToHistory_succ lemma
    rw [trajectoryToHistory_succ, ih]
    simp only [List.append_assoc]
    congr 1
    rw [trajectoryToHistory_succ]
    simp only [shiftTrajectory]

/-- Cylinder set decomposes: cylinderSetAt (t+1) for [act a, per x, rest'].
    The set equals trajectories where:
    - The first step is (a, x)
    - The shifted trajectory produces rest' -/
theorem cylinderSetAt_cons_cons (a : Action) (x : Percept) (rest' : History) (t : ℕ) :
    cylinderSetAt (t + 1) (HistElem.act a :: HistElem.per x :: rest') =
      {traj | traj 0 = Step.mk a x ∧ trajectoryToHistory (shiftTrajectory traj) t = rest'} := by
  ext traj
  simp only [cylinderSetAt, Set.mem_setOf_eq]
  constructor
  · intro h_eq
    -- trajectoryToHistory traj (t+1) = [act a, per x, rest']
    rw [trajectoryToHistory_succ_eq] at h_eq
    -- h_eq : [act (traj 0).action, per (traj 0).percept] ++ shifted = [act a, per x, rest']
    -- Rewrite RHS as append form
    have h_rhs : (HistElem.act a :: HistElem.per x :: rest' : History) =
        [HistElem.act a, HistElem.per x] ++ rest' := by simp
    rw [h_rhs] at h_eq
    -- Now use append injectivity
    have h_len : ([HistElem.act (traj 0).action, HistElem.per (traj 0).percept] : History).length =
        ([HistElem.act a, HistElem.per x] : History).length := by simp
    have h1 : [HistElem.act (traj 0).action, HistElem.per (traj 0).percept] =
        [HistElem.act a, HistElem.per x] ∧
        trajectoryToHistory (shiftTrajectory traj) t = rest' :=
      List.append_inj h_eq h_len
    constructor
    · -- Show traj 0 = Step.mk a x
      -- Extract the components from h1.1
      have h_cons_eq := h1.1
      simp only [List.cons_eq_cons, HistElem.act.injEq, HistElem.per.injEq, and_true] at h_cons_eq
      -- h_cons_eq : (traj 0).action = a ∧ (traj 0).percept = x
      cases hstep : traj 0 with
      | mk act' per' =>
        -- Substitute hstep into h_cons_eq
        simp only [hstep] at h_cons_eq
        simp only [Step.mk.injEq]
        exact h_cons_eq
    · exact h1.2
  · intro ⟨h_step, h_rest⟩
    rw [trajectoryToHistory_succ_eq, h_rest]
    -- Need: [act (traj 0).action, per (traj 0).percept] ++ rest' = [act a, per x, rest']
    simp only [List.cons_append, List.nil_append]
    rw [h_step]

/-- Shifted cylinder set relates to the original. -/
theorem shiftTrajectory_preimage_cylinderSet (rest' : History) :
    shiftTrajectory ⁻¹' cylinderSet rest' =
      {traj | ∃ t, trajectoryToHistory (shiftTrajectory traj) t = rest'} := by
  ext traj
  simp only [Set.mem_preimage, cylinderSet, Set.mem_setOf_eq]

/-! ## Helper Lemmas for Chain Rule -/

/-- historyProbabilityAux of empty history is 1. -/
theorem historyProbabilityAux_nil (μ : Environment) (pfx : History) :
    historyProbabilityAux μ pfx [] = 1 := rfl

/-- historyProbabilityAux decomposes for [act a, per x, rest']. -/
theorem historyProbabilityAux_cons_cons (μ : Environment) (pfx : History)
    (a : Action) (x : Percept) (rest' : History) :
    historyProbabilityAux μ pfx (HistElem.act a :: HistElem.per x :: rest') =
      μ.prob (pfx ++ [HistElem.act a]) x *
        historyProbabilityAux μ (pfx ++ [HistElem.act a, HistElem.per x]) rest' := by
  simp only [historyProbabilityAux]

/-- Appending empty history doesn't change cylinder set. -/
theorem cylinderSet_append_nil (pfx : History) :
    cylinderSet (pfx ++ []) = cylinderSet pfx := by
  simp only [List.append_nil]

/-- historySteps of [act a, per x, rest'] decomposes. -/
theorem historySteps_append_pair (a : Action) (x : Percept) (rest' : History) :
    historySteps ([HistElem.act a, HistElem.per x] ++ rest') = 1 + historySteps rest' := by
  simp only [List.cons_append, List.nil_append]
  exact historySteps_cons_cons a x rest'

/-- For a well-formed history of length 2t, cylinderSetAt t h equals cylinderSet h.
    This is because a well-formed history determines a unique t.

    Note: This lemma is placed here (before the chain rule) to enable its use
    in proving the single-step chain rule. -/
theorem cylinderSet_eq_cylinderSetAt' (h : History) (_hw : h.wellFormed) :
    cylinderSet h = cylinderSetAt (historySteps h) h := by
  ext traj
  simp only [cylinderSet, cylinderSetAt, Set.mem_setOf_eq]
  constructor
  · -- (→) If trajectoryToHistory traj t = h for some t, then t = historySteps h
    intro ⟨t, ht⟩
    -- trajectoryToHistory always produces well-formed histories of length 2t
    have h_len : h.length = 2 * t := by
      rw [← ht]
      exact trajectoryToHistory_length traj t
    simp only [historySteps]
    -- h.length = 2 * t implies h.length / 2 = t
    have : h.length / 2 = t := by
      rw [h_len]
      exact Nat.mul_div_cancel_left t (by norm_num : 0 < 2)
    exact this ▸ ht
  · -- (←) Direct
    intro ht
    exact ⟨historySteps h, ht⟩

/-- Auxiliary: well-formed append preserves well-formedness when adding [act, per].
    This only works for even-length prefixes (complete histories).

    Note: This lemma is placed here (before the chain rule) to enable its use
    in proving the single-step chain rule. -/
theorem wellFormed_append_pair' (pfx : History) (a : Action) (x : Percept)
    (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) :
    (pfx ++ [HistElem.act a, HistElem.per x]).wellFormed := by
  -- Strong induction on length of pfx
  generalize hlen : pfx.length = len
  induction len using Nat.strong_induction_on generalizing pfx with
  | _ len ih =>
    cases pfx with
    | nil =>
      -- pfx = [], so pfx ++ [act a, per x] = [act a, per x]
      simp only [List.nil_append, History.wellFormed]
    | cons elem rest =>
      cases elem with
      | act a' =>
        cases rest with
        | nil =>
          -- pfx = [act a'], length = 1 (odd), contradicts h_pfx_complete
          simp only [List.length_singleton] at h_pfx_complete
          exact absurd h_pfx_complete (by decide : ¬Even 1)
        | cons elem' rest' =>
          cases elem' with
          | act _ =>
            -- pfx = [act a', act _, ...] is not well-formed
            exact absurd h_pfx_wf (by simp only [History.wellFormed]; decide)
          | per x' =>
            -- pfx = [act a', per x', rest']
            have h_wf_rest' : History.wellFormed rest' := h_pfx_wf
            have h_complete_rest' : Even rest'.length := by
              simp only [List.length_cons] at h_pfx_complete
              have heq : rest'.length + 1 + 1 = rest'.length + 2 := by ring
              rw [heq, Nat.even_add] at h_pfx_complete
              exact h_pfx_complete.mpr (by decide : Even 2)
            have h_len_rest' : rest'.length < len := by
              simp only [List.length_cons] at hlen
              omega
            -- pfx ++ [act a, per x] = [act a', per x'] ++ (rest' ++ [act a, per x])
            have h_assoc : (HistElem.act a' :: HistElem.per x' :: rest') ++ [HistElem.act a, HistElem.per x] =
                HistElem.act a' :: HistElem.per x' :: (rest' ++ [HistElem.act a, HistElem.per x]) := by
              simp only [List.cons_append]
            rw [h_assoc]
            simp only [History.wellFormed]
            -- Apply IH to rest'
            exact ih rest'.length h_len_rest' rest' h_wf_rest' h_complete_rest' rfl
      | per _ =>
        exact absurd h_pfx_wf (by simp only [History.wellFormed]; decide)

/-- The extended cylinder set decomposes as an intersection.
    cylinderSet (pfx ++ [act a, per x]) = cylinderSet pfx ∩ {traj | traj n = Step.mk a x}
    where n = historySteps pfx.

    This is the key geometric decomposition for the chain rule. -/
theorem cylinderSet_append_eq_inter (pfx : History) (a : Action) (x : Percept)
    (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) :
    cylinderSet (pfx ++ [HistElem.act a, HistElem.per x]) =
      cylinderSet pfx ∩ {traj | traj (historySteps pfx) = Step.mk a x} := by
  -- Express both sides via cylinderSetAt
  have h_wf_ext : (pfx ++ [HistElem.act a, HistElem.per x]).wellFormed :=
    wellFormed_append_pair' pfx a x h_pfx_wf h_pfx_complete
  have h_steps_ext : historySteps (pfx ++ [HistElem.act a, HistElem.per x]) =
      historySteps pfx + 1 := by
    simp only [historySteps, List.length_append, List.length_cons, List.length_nil]
    rw [Nat.add_div_right pfx.length (by norm_num : 0 < 2)]
  -- Use cylinderSet_eq_cylinderSetAt' to rewrite both sides
  rw [cylinderSet_eq_cylinderSetAt' pfx h_pfx_wf]
  rw [cylinderSet_eq_cylinderSetAt' _ h_wf_ext]
  rw [h_steps_ext]
  -- Now prove: cylinderSetAt (n+1) ext = cylinderSetAt n pfx ∩ {traj | traj n = Step.mk a x}
  ext traj
  simp only [cylinderSetAt, Set.mem_inter_iff, Set.mem_setOf_eq]
  constructor
  · intro h
    -- trajectoryToHistory traj (n+1) = ext implies trajectoryToHistory traj n = pfx
    rw [trajectoryToHistory_succ] at h
    set n := historySteps pfx with hn
    have h_len_eq : (trajectoryToHistory traj n).length = pfx.length := by
      rw [trajectoryToHistory_length]
      simp only [historySteps] at hn
      rw [hn, mul_comm]
      exact Nat.div_two_mul_two_of_even h_pfx_complete
    constructor
    · exact (List.append_inj h h_len_eq).1
    · -- Extract the step from the appended part
      have h_tail := (List.append_inj h h_len_eq).2
      simp only [List.cons_eq_cons, HistElem.act.injEq, HistElem.per.injEq, and_true] at h_tail
      exact Step.ext h_tail.1 h_tail.2
  · intro ⟨h1, h2⟩
    -- Combine the prefix and the step
    rw [trajectoryToHistory_succ, h1, h2]

/-! ## Product Measure Factorization

The Ionescu-Tulcea measure satisfies a key product measure property:
the measure of (cylinder based on first n steps) ∩ (step n constraint)
factors as (measure of cylinder) × (transition probability of step).
-/

/-- **IT Product Factorization**: For a cylinder set based on first n steps
    and a singleton constraint at step n, the measure factors.

    This is the fundamental property of IT measures:
    μ(A ∩ {ω | ω(n) = s}) = μ(A) × κ_n({s})

    where:
    - A is a cylinder based on first n steps (determined by history pfx)
    - κ_n is the transition kernel at step n
    - The kernel mass at {s} is uniformActionProb × μ.prob(pfx ++ [act]) percept

    **Proof Strategy**:
    By the IT construction, the measure on (Π i : ℕ, Step) is built as a
    projective limit with the factorization property built in. Specifically:
    1. The measure restricted to (Π i : Iic n, Step) factors as the
       product of marginals
    2. Each marginal at step i is the transition kernel κ_{i-1}
    3. For A based on first n steps and B = {ω | ω(n) = s}:
       μ(A ∩ B) = μ_n(proj_n(A) ∩ proj_n(B))
                = μ_{n-1}(proj_{n-1}(A)) × κ_n({s})
                = μ(A) × κ_n({s})

    The key insight is that the measure of cylinderSet pfx ∩ {traj | traj n = s}
    equals:
      environmentMeasure(cylinderSet pfx) × uniformActionProb × μ.prob(pfx ++ [act s.action]) s.percept

    This is because:
    - The transition kernel κ_n is constructed exactly to give this probability
    - The IT measure factors by construction -/
theorem IT_product_factorization (μ : Environment) (h_stoch : isStochastic μ)
    (pfx : History) (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) (s : Step) :
    environmentMeasure μ h_stoch (cylinderSet pfx ∩ {traj | traj (historySteps pfx) = s}) =
      environmentMeasure μ h_stoch (cylinderSet pfx) *
        uniformActionProb * μ.prob (pfx ++ [HistElem.act s.action]) s.percept := by
  -- Induction on the number of steps in pfx
  generalize hn : historySteps pfx = n
  induction n generalizing pfx with
  | zero =>
    -- Base case: pfx = [] (empty history)
    -- historySteps pfx = 0 implies pfx = []
    have h_pfx_empty : pfx = [] := by
      cases pfx with
      | nil => rfl
      | cons e rest =>
        simp only [historySteps, List.length_cons] at hn
        -- historySteps (e :: rest) = (rest.length + 1) / 2
        -- For this to equal 0, we need rest.length + 1 < 2, i.e., rest.length = 0
        -- But then historySteps [e] = 1 / 2 = 0, which is actually possible!
        -- Wait, we also have h_pfx_wf and h_pfx_complete constraints
        -- If pfx is well-formed with even length > 0, it must have at least 2 elements
        -- Actually for [e] (length 1), it's odd, so h_pfx_complete fails
        cases rest with
        | nil =>
          -- pfx = [e], length = 1, which is odd, contradicts h_pfx_complete
          simp only [List.length_singleton, Nat.not_even_one] at h_pfx_complete
        | cons e' rest' =>
          -- pfx has at least 2 elements, so historySteps > 0
          simp only [List.length_cons] at hn
          -- historySteps = (rest'.length + 2) / 2 ≥ 1
          have : 0 < (rest'.length + 2) / 2 := Nat.div_pos (by omega) (by norm_num)
          omega
    subst h_pfx_empty
    -- Now pfx = []
    -- cylinderSet [] = Set.univ
    have h_cyl_empty : cylinderSet ([] : History) = Set.univ := by
      ext traj
      simp only [cylinderSet, Set.mem_setOf_eq, Set.mem_univ, iff_true]
      exact ⟨0, trajectoryToHistory_zero traj⟩
    simp only [historySteps, List.length_nil, Nat.zero_div] at hn ⊢
    -- Goal: environmentMeasure μ h_stoch (cylinderSet [] ∩ {traj | traj 0 = s}) =
    --       environmentMeasure μ h_stoch (cylinderSet []) * uniformActionProb * μ.prob [act s.action] s.percept
    -- Rewrite all cylinderSet [] to Set.univ
    simp only [h_cyl_empty, Set.univ_inter]
    -- Now: environmentMeasure μ h_stoch {traj | traj 0 = s} =
    --      environmentMeasure μ h_stoch Set.univ * uniformActionProb * μ.prob [act s.action] s.percept
    rw [environmentMeasure_univ_eq_one, one_mul]
    -- Simplify [] ++ [act s.action] to [act s.action]
    simp only [List.nil_append]
    -- Now need: environmentMeasure μ h_stoch {traj | traj 0 = s} =
    --           uniformActionProb * μ.prob [act s.action] s.percept
    -- Apply the base case lemma
    exact environmentMeasure_step0_singleton μ h_stoch s
  | succ n ih =>
    -- Inductive case: pfx has n+1 steps
    -- We need to use the Markov property: P(A ∩ B) = P(A) × P(B|A)
    -- where A = cylinderSet pfx and B = {traj | traj (n+1) = s}
    --
    -- The key insight is that our environmentMeasure is built from the transition kernel,
    -- which gives exactly the conditional probability P(B|A).
    --
    -- Proof strategy:
    -- 1. Decompose pfx = pfx' ++ [act a, per x] where historySteps pfx' = n
    -- 2. Use the chain rule: cylinderSet pfx = cylinderSet pfx' ∩ {traj | traj n = Step.mk a x}
    classical
    have hnSteps : historySteps pfx = n.succ := hn

    have hlen : pfx.length = 2 * n.succ := by
      have hdiv : pfx.length / 2 = n.succ := by
        simpa [historySteps] using hnSteps
      have h_even : (pfx.length / 2) * 2 = pfx.length :=
        Nat.div_two_mul_two_of_even h_pfx_complete
      calc
        pfx.length = (pfx.length / 2) * 2 := by
          symm
          exact h_even
        _ = n.succ * 2 := by
          simp [hdiv]
        _ = 2 * n.succ := by
          simp [Nat.mul_comm]

    -- Canonical finite prefix determined by `pfx`.
    let f0 : Fin n.succ → Step := historyToFinPrefix n.succ pfx
    have hpfx_prefix : prefixToHistory n.succ f0 = pfx := by
      simpa [f0] using
        (prefixToHistory_historyToFinPrefix (t := n.succ) (h := pfx) h_pfx_wf hlen)

    -- Same prefix, but in the Ionescu–Tulcea (`Iic`) indexing.
    let x0 : Π i : Iic n, StepFamily i := finToIic n f0
    have hpfx_iic : iicPrefixToHistory n x0 = pfx := by
      -- `iicPrefixToHistory` is `prefixToHistory` after reindexing, and `iicToFin_finToIic` removes
      -- the conversion.
      simpa [iicPrefixToHistory, prefixToHistory, x0] using hpfx_prefix

    have h_iicToFin_frestrictLe (traj : Trajectory) :
        iicToFin n (frestrictLe (π := StepFamily) n traj) = truncate n.succ traj := by
      funext i
      rfl

    have h_cyl :
        cylinderSet pfx =
          (frestrictLe (π := StepFamily) n) ⁻¹'
            ({x0} : Set (Π i : Iic n, StepFamily i)) := by
      ext traj
      have hcyl : cylinderSet pfx = cylinderSetAt (historySteps pfx) pfx :=
        cylinderSet_eq_cylinderSetAt' pfx h_pfx_wf
      -- Reduce to `trajectoryToHistory` at time `n+1`.
      simp [hcyl, cylinderSetAt, hnSteps]
      constructor
      · intro h_hist
        -- Turn the history equality into a truncation equality by applying `historyToFinPrefix`.
        have h_pref : prefixToHistory n.succ (truncate n.succ traj) = pfx := by
          calc
            prefixToHistory n.succ (truncate n.succ traj) =
                trajectoryToHistory traj n.succ := prefixToHistory_eq_trajectoryToHistory n.succ traj
            _ = pfx := h_hist
        have h_pref' : prefixToHistory n.succ (truncate n.succ traj) = prefixToHistory n.succ f0 := by
          simpa [hpfx_prefix] using h_pref
        have h_trunc : truncate n.succ traj = f0 := by
          have := congrArg (fun h => historyToFinPrefix n.succ h) h_pref'
          simpa [historyToFinPrefix_prefixToHistory] using this
        -- Convert truncation equality to an `Iic`-prefix equality.
        have hiic : iicToFin n (frestrictLe (π := StepFamily) n traj) = f0 := by
          simpa [h_trunc] using (h_iicToFin_frestrictLe traj)
        have := congrArg (fun f => finToIic n f) hiic
        simpa [x0] using this
      · intro h_prefEq
        -- Convert an `Iic`-prefix equality into a truncation equality, then to the history.
        have hiic : iicToFin n (frestrictLe (π := StepFamily) n traj) = f0 := by
          simpa [x0] using congrArg (iicToFin n) h_prefEq
        have h_trunc : truncate n.succ traj = f0 := by
          calc
            truncate n.succ traj = iicToFin n (frestrictLe (π := StepFamily) n traj) := by
              symm
              exact congrArg id (h_iicToFin_frestrictLe traj)
            _ = f0 := hiic
        calc
          trajectoryToHistory traj n.succ =
              prefixToHistory n.succ (truncate n.succ traj) := (prefixToHistory_eq_trajectoryToHistory n.succ traj).symm
          _ = prefixToHistory n.succ f0 := by simp [h_trunc]
          _ = pfx := hpfx_prefix

    -- The next-step prefix `x1`, extending `x0` with the event `traj (n+1) = s`.
    let z : Π i : Ioc n n.succ, StepFamily i := (MeasurableEquiv.piSingleton n) s
    let x1 : Π i : Iic n.succ, StepFamily i := IicProdIoc (X := StepFamily) n n.succ (x0, z)

    have h_inter :
        cylinderSet pfx ∩ {traj | traj n.succ = s} =
          (frestrictLe (π := StepFamily) n.succ) ⁻¹'
            ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
      ext traj
      constructor
      · rintro ⟨hpfx_mem, hs_mem⟩
        have hx0_traj : frestrictLe (π := StepFamily) n traj = x0 := by
          simpa [h_cyl, Set.mem_preimage, Set.mem_singleton_iff] using hpfx_mem
        -- Show the extended prefix matches `x1`.
        have hx1_traj : frestrictLe (π := StepFamily) n.succ traj = x1 := by
          funext i
          rcases i with ⟨i, hiIic⟩
          by_cases hi : i ≤ n
          · -- prefix part
            have hi' : i ∈ Iic n := mem_Iic.2 hi
            have := congrArg (fun f => f ⟨i, hi'⟩) hx0_traj
            simpa [frestrictLe_apply, x1, IicProdIoc, hi] using this
          · -- last coordinate is forced to be `n+1`
            have hi_gt : n < i := lt_of_not_ge hi
            have hi_le : i ≤ n.succ := mem_Iic.1 hiIic
            have hi_eq : i = n.succ := Nat.le_antisymm hi_le (Nat.succ_le_of_lt hi_gt)
            subst hi_eq
            simpa [frestrictLe_apply, x1, IicProdIoc, hi, z, hs_mem]
        simpa [Set.mem_preimage, Set.mem_singleton_iff] using hx1_traj
      · intro hmem
        have hx1_traj : frestrictLe (π := StepFamily) n.succ traj = x1 := by
          simpa [Set.mem_preimage, Set.mem_singleton_iff] using hmem
        have hs_mem : traj n.succ = s := by
          -- Evaluate at the last index.
          have := congrArg (fun f => f ⟨n.succ, mem_Iic.2 (le_rfl)⟩) hx1_traj
          simpa [frestrictLe_apply, x1, IicProdIoc, z, MeasurableEquiv.piSingleton] using this
        have hx0_traj : frestrictLe (π := StepFamily) n traj = x0 := by
          funext i
          have hi_le : (i : ℕ) ≤ n := mem_Iic.1 i.2
          have := congrArg (fun f => f ⟨i.1, mem_Iic.2 (hi_le.trans n.le_succ)⟩) hx1_traj
          simpa [frestrictLe_apply, x1, IicProdIoc, hi_le] using this
        have hpfx_mem : traj ∈ cylinderSet pfx := by
          simpa [h_cyl, Set.mem_preimage, Set.mem_singleton_iff] using hx0_traj
        exact ⟨hpfx_mem, hs_mem⟩

    -- Rewrite the goal to a statement about singleton cylinder events in the IT prefix spaces.
    haveI : ∀ m, IsMarkovKernel (transitionKernel μ m) :=
      fun m => transitionKernel_isMarkov μ m h_stoch

    have h_meas_n : Measurable (frestrictLe (π := StepFamily) n) :=
      measurable_frestrictLe (X := StepFamily) n
    have h_meas_succ : Measurable (frestrictLe (π := StepFamily) n.succ) :=
      measurable_frestrictLe (X := StepFamily) n.succ

    have hx0_meas : MeasurableSet ({x0} : Set (Π i : Iic n, StepFamily i)) := by simp
    have hx1_meas : MeasurableSet ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by simp

    -- Convert the sets to `map`-probabilities.
    have hA :
        environmentMeasure μ h_stoch ((frestrictLe (π := StepFamily) n) ⁻¹' ({x0} : Set (Π i : Iic n, StepFamily i))) =
          (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) n) ({x0} : Set (Π i : Iic n, StepFamily i)) := by
      simpa using (MeasureTheory.Measure.map_apply h_meas_n hx0_meas).symm

    have hB :
        environmentMeasure μ h_stoch ((frestrictLe (π := StepFamily) n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i))) =
          (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) n.succ) ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
      simpa using (MeasureTheory.Measure.map_apply h_meas_succ hx1_meas).symm

    -- Compute the prefix measures via `partialTraj`.
    have h_map_prefix (k : ℕ) :
        (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) k) =
          Kernel.partialTraj (transitionKernel μ) 0 k ∘ₘ initialMeasureIic0 μ := by
      have hk_meas : Measurable (frestrictLe (π := StepFamily) k) := measurable_frestrictLe (X := StepFamily) k
      simp [environmentMeasure]
      rw [MeasureTheory.Measure.map_comp (μ := initialMeasureIic0 μ)
        (κ := @Kernel.traj StepFamily (fun _ => inferInstance) (transitionKernel μ)
          (fun n => transitionKernel_isMarkov μ n h_stoch) 0) hk_meas]
      rw [Kernel.traj_map_frestrictLe]

    -- Let μₙ be the distribution of prefixes up to time n.
    let μn : MeasureTheory.Measure (Π i : Iic n, StepFamily i) :=
      (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) n)

    let μn1 : MeasureTheory.Measure (Π i : Iic n.succ, StepFamily i) :=
      (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) n.succ)

    have hμn : μn = Kernel.partialTraj (transitionKernel μ) 0 n ∘ₘ initialMeasureIic0 μ := by
      simpa [μn] using h_map_prefix n

    have hμn1 : μn1 = Kernel.partialTraj (transitionKernel μ) 0 n.succ ∘ₘ initialMeasureIic0 μ := by
      simpa [μn1] using h_map_prefix n.succ

    have hμn1_fact :
        μn1 = Kernel.partialTraj (transitionKernel μ) n n.succ ∘ₘ μn := by
      -- factor `partialTraj 0 (n+1)` through time `n`
      have hPT :
          Kernel.partialTraj (transitionKernel μ) 0 n.succ =
            Kernel.partialTraj (transitionKernel μ) n n.succ ∘ₖ Kernel.partialTraj (transitionKernel μ) 0 n := by
        simpa [Nat.succ_eq_add_one] using
          (Kernel.partialTraj_succ_eq_comp (κ := transitionKernel μ) (a := 0) (b := n) (Nat.zero_le n))
      -- Push this factorization through the composition with the initial measure, then rewrite the
      -- intermediate prefix distribution as `μn`.
      calc
        μn1 = Kernel.partialTraj (transitionKernel μ) 0 n.succ ∘ₘ initialMeasureIic0 μ := by
          simpa [μn1] using hμn1
        _ = (Kernel.partialTraj (transitionKernel μ) n n.succ ∘ₖ Kernel.partialTraj (transitionKernel μ) 0 n) ∘ₘ
              initialMeasureIic0 μ := by
          simp [hPT]
        _ = Kernel.partialTraj (transitionKernel μ) n n.succ ∘ₘ
              (Kernel.partialTraj (transitionKernel μ) 0 n ∘ₘ initialMeasureIic0 μ) := by
          -- reassociate kernel/measure composition
          simpa using (MeasureTheory.Measure.comp_assoc (μ := initialMeasureIic0 μ)
            (κ := Kernel.partialTraj (transitionKernel μ) 0 n) (η := Kernel.partialTraj (transitionKernel μ) n n.succ)).symm
        _ = Kernel.partialTraj (transitionKernel μ) n n.succ ∘ₘ μn := by
          simpa [μn] using congrArg (fun m => Kernel.partialTraj (transitionKernel μ) n n.succ ∘ₘ m) hμn.symm

    -- Evaluate the singleton probability at time `n+1`.
    have h_singleton_step :
        μn1 ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
          μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasure μ n x0 {s} := by
      -- Expand the one-step composition `partialTraj n (n+1) ∘ₘ μn` as a finite sum.
      have hsum :
          μn1 ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
            ∑ ω : (Π i : Iic n, StepFamily i),
              μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
                Kernel.partialTraj (transitionKernel μ) n n.succ ω ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
        -- Use the countable-sum formula for kernel composition, then reduce to a finite sum.
        have hx1_meas' : MeasurableSet ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by simp
        -- Replace `μn1` using the factorization.
        rw [hμn1_fact]
        -- Rewrite `∘ₘ` as a sum over singletons (domain is finite, hence countable).
        rw [MeasureTheory.Measure.comp_eq_sum_of_countable (μ := μn) (κ := Kernel.partialTraj (transitionKernel μ) n n.succ)]
        -- Evaluate the sum measure at the singleton.
        rw [MeasureTheory.Measure.sum_apply_of_countable]
        -- Reduce the infinite sum to a finite sum.
        rw [tsum_fintype]
        -- Simplify each term of the finite sum.
        simp [MeasureTheory.Measure.smul_apply, smul_eq_mul]

      -- Compute the transition kernel contribution at `{x1}`: only `ω = x0` contributes.
      -- First show the explicit singleton formula for the one-step `partialTraj`.
      have h_partialTraj_singleton (ω : Π i : Iic n, StepFamily i) :
          Kernel.partialTraj (transitionKernel μ) n n.succ ω ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
            if ω = x0 then transitionMeasure μ n ω {s} else 0 := by
        -- Unfold the successor case of `partialTraj`.
        have hPT := Kernel.partialTraj_succ_self (κ := transitionKernel μ) n
        -- Evaluate at `ω` and the singleton `{x1}`.
        have hx1_meas' : MeasurableSet ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by simp
        have hIic_meas : Measurable (IicProdIoc (X := StepFamily) n n.succ) := by fun_prop
        -- Start from the `partialTraj_succ_self` formula.
        -- `simp` will reduce the product kernel using `Kernel.id_prod_apply'`.
        -- The preimage under `IicProdIoc` of `{x1}` is the singleton `{(x0, z)}`.
        -- Then `Prod.mk ω` picks `{z}` iff `ω = x0`.
        -- Finally, mapping by `piSingleton` reduces to the transition measure of `{s}`.
        have h_preimage :
            (IicProdIoc (X := StepFamily) n n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
              ({(x0, z)} : Set ((Π i : Iic n, StepFamily i) × (Π i : Ioc n n.succ, StepFamily i))) := by
          classical
          -- Use the measurable equivalence `MeasurableEquiv.IicProdIoc` (a bijection) to identify
          -- the unique preimage of a singleton.
          let e :=
            MeasurableEquiv.IicProdIoc (X := StepFamily) (a := n) (b := n.succ) (Nat.le_succ n)
          have hx1 : e (x0, z) = x1 := by
            simp [e, x1, MeasurableEquiv.coe_IicProdIoc]
          have hx1_symm : e.symm x1 = (x0, z) := by
            simpa [hx1] using (e.symm_apply_apply (x0, z))
          ext y
          constructor
          · intro hy
            have hy' : IicProdIoc (X := StepFamily) n n.succ y = x1 := by
              simpa [Set.mem_preimage, Set.mem_singleton_iff] using hy
            have hy'' : e y = x1 := by
              simpa [e, MeasurableEquiv.coe_IicProdIoc] using hy'
            have : y = e.symm x1 := (e.apply_eq_iff_eq_symm_apply).1 hy''
            simpa [Set.mem_singleton_iff, hx1_symm] using this
          · intro hy
            have : y = (x0, z) := by simpa [Set.mem_singleton_iff] using hy
            subst this
            simp [Set.mem_preimage, Set.mem_singleton_iff, x1]

        -- Now compute `partialTraj` on the singleton.
        rw [hPT]
        -- Expand kernel map.
        rw [Kernel.map_apply' _ (by fun_prop) ω hx1_meas']
        -- Reduce product kernel with `Kernel.id_prod_apply'`.
        have h_prod_meas : MeasurableSet ((IicProdIoc (X := StepFamily) n n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i))) := by
          simpa using hx1_meas'.preimage (by fun_prop : Measurable (IicProdIoc (X := StepFamily) n n.succ))
        rw [Kernel.id_prod_apply' _ ω h_prod_meas]
        -- Use the computed preimage.
        rw [h_preimage]
        -- Compute the preimage under `Prod.mk ω`.
        by_cases hω : ω = x0
        · subst hω
          -- `Prod.mk x0` hits the singleton `{(x0,z)}` exactly at `z`.
          have hmk :
              Prod.mk x0 ⁻¹'
                  ({(x0, z)} :
                    Set ((Π i : Iic n, StepFamily i) × (Π i : Ioc n n.succ, StepFamily i))) =
                ({z} : Set (Π i : Ioc n n.succ, StepFamily i)) := by
            ext u
            simp [Set.mem_preimage, Set.mem_singleton_iff]
          -- Reduce to the transition measure of `{s}`.
          simp [hmk]
          rw [Kernel.map_apply' (κ := transitionKernel μ n) (f := (MeasurableEquiv.piSingleton n))
            (MeasurableEquiv.piSingleton n).measurable x0 (by simp)]
          have hz :
              (MeasurableEquiv.piSingleton n) ⁻¹' ({z} : Set (Π i : Ioc n n.succ, StepFamily i)) =
                ({s} : Set Step) := by
            ext t
            simp [z, Set.mem_preimage, Set.mem_singleton_iff]
          simp [transitionKernel, hz]
        · -- If `ω ≠ x0`, the preimage is empty, so the probability is 0.
          have hmk :
              Prod.mk ω ⁻¹'
                  ({(x0, z)} :
                    Set ((Π i : Iic n, StepFamily i) × (Π i : Ioc n n.succ, StepFamily i))) =
                (∅ : Set (Π i : Ioc n n.succ, StepFamily i)) := by
            ext u
            simp [Set.mem_preimage, Set.mem_singleton_iff, hω]
          simp [hmk, hω]

      -- Use the singleton formula to collapse the finite sum to the `ω = x0` term.
      rw [hsum]
      classical
      -- Rewrite the summand using `h_partialTraj_singleton`, then isolate the `ω = x0` term.
      have h_other (ω : (Π i : Iic n, StepFamily i)) (hω : ω ≠ x0) :
          μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
              Kernel.partialTraj (transitionKernel μ) n n.succ ω
                ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
            0 := by
        simp [h_partialTraj_singleton ω, hω]
      have : (∑ ω : (Π i : Iic n, StepFamily i),
          μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
            Kernel.partialTraj (transitionKernel μ) n n.succ ω
              ({x1} : Set (Π i : Iic n.succ, StepFamily i))) =
          μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasure μ n x0 {s} := by
        calc
          (∑ ω : (Π i : Iic n, StepFamily i),
                μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
                  Kernel.partialTraj (transitionKernel μ) n n.succ ω
                    ({x1} : Set (Π i : Iic n.succ, StepFamily i))) =
              μn ({x0} : Set (Π i : Iic n, StepFamily i)) *
                Kernel.partialTraj (transitionKernel μ) n n.succ x0
                  ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
            simpa using (Fintype.sum_eq_single x0 (fun ω hω => h_other ω hω))
          _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasure μ n x0 {s} := by
            simp [h_partialTraj_singleton x0]
      simpa using this

    -- Replace the transition measure using `transitionMeasure_singleton` and `pfx`-rewrite.
    have h_trans :
        transitionMeasure μ n x0 {s} =
          uniformActionProb * μ.prob (pfx ++ [HistElem.act s.action]) s.percept := by
      simpa [hpfx_iic] using (transitionMeasure_singleton μ n x0 s)

    -- Assemble the final statement by rewriting events as IT-prefix singletons.
    have h_setL :
        cylinderSet pfx ∩ {traj | traj n.succ = s} =
          (frestrictLe (π := StepFamily) n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i)) :=
      h_inter
    have h_setR :
        cylinderSet pfx =
          (frestrictLe (π := StepFamily) n) ⁻¹' ({x0} : Set (Π i : Iic n, StepFamily i)) :=
      h_cyl

    calc
      environmentMeasure μ h_stoch (cylinderSet pfx ∩ {traj | traj n.succ = s})
          = environmentMeasure μ h_stoch
              ((frestrictLe (π := StepFamily) n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i))) := by
                simp [h_setL]
      _ = (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) n.succ)
            ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
                exact hB
      _ = μn1 ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := rfl
      _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasure μ n x0 {s} := by
            simpa using h_singleton_step
      _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) *
            (uniformActionProb * μ.prob (pfx ++ [HistElem.act s.action]) s.percept) := by
            simp [h_trans]
      _ = environmentMeasure μ h_stoch (cylinderSet pfx) *
            uniformActionProb * μ.prob (pfx ++ [HistElem.act s.action]) s.percept := by
            -- rewrite `environmentMeasure μ h_stoch (cylinderSet pfx)` as the corresponding singleton prefix probability
            have :
                environmentMeasure μ h_stoch (cylinderSet pfx) =
                  μn ({x0} : Set (Π i : Iic n, StepFamily i)) := by
                calc
                  environmentMeasure μ h_stoch (cylinderSet pfx)
                      = environmentMeasure μ h_stoch
                          ((frestrictLe (π := StepFamily) n) ⁻¹' ({x0} : Set (Π i : Iic n, StepFamily i))) := by
                            simp [h_setR]
                  _ = (environmentMeasure μ h_stoch).map (frestrictLe (π := StepFamily) n)
                        ({x0} : Set (Π i : Iic n, StepFamily i)) := hA
                  _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) := rfl
            -- now it's just reassociation/commutation
            simp [this, mul_assoc, mul_left_comm, mul_comm]

/-! ## IT Product Factorization (Policy Actions)

The same factorization lemma holds for the on-policy Ionescu–Tulcea construction
`environmentMeasureWithPolicy μ π h_stoch`. The only change is that the constant
`uniformActionProb` is replaced by the history-dependent policy probability `π.policy pfx a`.
-/

theorem IT_product_factorizationWithPolicy (μ : Environment) (π : Agent) (h_stoch : isStochastic μ)
    (pfx : History) (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) (s : Step) :
    environmentMeasureWithPolicy μ π h_stoch
        (cylinderSet pfx ∩ {traj | traj (historySteps pfx) = s}) =
      environmentMeasureWithPolicy μ π h_stoch (cylinderSet pfx) *
        π.policy pfx s.action * μ.prob (pfx ++ [HistElem.act s.action]) s.percept := by
  -- Induction on the number of steps in pfx.
  generalize hn : historySteps pfx = n
  induction n generalizing pfx with
  | zero =>
    -- Base case: pfx = [].
    have h_pfx_empty : pfx = [] := by
      cases pfx with
      | nil => rfl
      | cons e rest =>
        simp only [historySteps, List.length_cons] at hn
        cases rest with
        | nil =>
          simp only [List.length_singleton, Nat.not_even_one] at h_pfx_complete
        | cons _ rest' =>
          simp only [List.length_cons] at hn
          have : 0 < (rest'.length + 2) / 2 := Nat.div_pos (by omega) (by norm_num)
          omega
    subst h_pfx_empty
    have h_cyl_empty : cylinderSet ([] : History) = Set.univ := by
      ext traj
      simp only [cylinderSet, Set.mem_setOf_eq, Set.mem_univ, iff_true]
      exact ⟨0, trajectoryToHistory_zero traj⟩
    simp only [historySteps, List.length_nil, Nat.zero_div] at hn ⊢
    simp only [h_cyl_empty, Set.univ_inter]
    rw [environmentMeasureWithPolicy_univ_eq_one (μ := μ) (π := π) (h_stoch := h_stoch), one_mul]
    simp only [List.nil_append]
    exact environmentMeasureWithPolicy_step0_singleton μ π h_stoch s
  | succ n ih =>
    classical
    have hnSteps : historySteps pfx = n.succ := hn

    have hlen : pfx.length = 2 * n.succ := by
      have hdiv : pfx.length / 2 = n.succ := by
        simpa [historySteps] using hnSteps
      have h_even : (pfx.length / 2) * 2 = pfx.length :=
        Nat.div_two_mul_two_of_even h_pfx_complete
      calc
        pfx.length = (pfx.length / 2) * 2 := by
          symm
          exact h_even
        _ = n.succ * 2 := by
          simp [hdiv]
        _ = 2 * n.succ := by
          simp [Nat.mul_comm]

    -- Canonical finite prefix determined by `pfx`.
    let f0 : Fin n.succ → Step := historyToFinPrefix n.succ pfx
    have hpfx_prefix : prefixToHistory n.succ f0 = pfx := by
      simpa [f0] using
        (prefixToHistory_historyToFinPrefix (t := n.succ) (h := pfx) h_pfx_wf hlen)

    -- Same prefix, but in the Ionescu–Tulcea (`Iic`) indexing.
    let x0 : Π i : Iic n, StepFamily i := finToIic n f0
    have hpfx_iic : iicPrefixToHistory n x0 = pfx := by
      simpa [iicPrefixToHistory, prefixToHistory, x0] using hpfx_prefix

    have h_iicToFin_frestrictLe (traj : Trajectory) :
        iicToFin n (frestrictLe (π := StepFamily) n traj) = truncate n.succ traj := by
      funext i
      rfl

    have h_cyl :
        cylinderSet pfx =
          (frestrictLe (π := StepFamily) n) ⁻¹'
            ({x0} : Set (Π i : Iic n, StepFamily i)) := by
      ext traj
      have hcyl : cylinderSet pfx = cylinderSetAt (historySteps pfx) pfx :=
        cylinderSet_eq_cylinderSetAt' pfx h_pfx_wf
      -- Reduce to `trajectoryToHistory` at time `n+1`.
      simp [hcyl, cylinderSetAt, hnSteps]
      constructor
      · intro h_hist
        -- Turn the history equality into a truncation equality by applying `historyToFinPrefix`.
        have h_pref : prefixToHistory n.succ (truncate n.succ traj) = pfx := by
          calc
            prefixToHistory n.succ (truncate n.succ traj) =
                trajectoryToHistory traj n.succ := prefixToHistory_eq_trajectoryToHistory n.succ traj
            _ = pfx := h_hist
        have h_pref' : prefixToHistory n.succ (truncate n.succ traj) = prefixToHistory n.succ f0 := by
          simpa [hpfx_prefix] using h_pref
        have h_trunc : truncate n.succ traj = f0 := by
          have := congrArg (fun h => historyToFinPrefix n.succ h) h_pref'
          simpa [historyToFinPrefix_prefixToHistory] using this
        -- Convert truncation equality to an `Iic`-prefix equality.
        have hiic : iicToFin n (frestrictLe (π := StepFamily) n traj) = f0 := by
          simpa [h_trunc] using (h_iicToFin_frestrictLe traj)
        have := congrArg (fun f => finToIic n f) hiic
        simpa [x0] using this
      · intro h_prefEq
        -- Convert an `Iic`-prefix equality into a truncation equality, then to the history.
        have hiic : iicToFin n (frestrictLe (π := StepFamily) n traj) = f0 := by
          simpa [x0] using congrArg (iicToFin n) h_prefEq
        have h_trunc : truncate n.succ traj = f0 := by
          calc
            truncate n.succ traj = iicToFin n (frestrictLe (π := StepFamily) n traj) := by
              symm
              exact congrArg id (h_iicToFin_frestrictLe traj)
            _ = f0 := hiic
        calc
          trajectoryToHistory traj n.succ =
              prefixToHistory n.succ (truncate n.succ traj) := (prefixToHistory_eq_trajectoryToHistory n.succ traj).symm
          _ = prefixToHistory n.succ f0 := by simp [h_trunc]
          _ = pfx := hpfx_prefix

    -- The next-step prefix `x1`, extending `x0` with the event `traj (n+1) = s`.
    let z : Π i : Ioc n n.succ, StepFamily i := (MeasurableEquiv.piSingleton n) s
    let x1 : Π i : Iic n.succ, StepFamily i := IicProdIoc (X := StepFamily) n n.succ (x0, z)

    have h_inter :
        cylinderSet pfx ∩ {traj | traj n.succ = s} =
          (frestrictLe (π := StepFamily) n.succ) ⁻¹'
            ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
      ext traj
      constructor
      · rintro ⟨hpfx_mem, hs_mem⟩
        have hx0_traj : frestrictLe (π := StepFamily) n traj = x0 := by
          simpa [h_cyl, Set.mem_preimage, Set.mem_singleton_iff] using hpfx_mem
        -- Show the extended prefix matches `x1`.
        have hx1_traj : frestrictLe (π := StepFamily) n.succ traj = x1 := by
          funext i
          rcases i with ⟨i, hiIic⟩
          by_cases hi : i ≤ n
          · -- prefix part
            have hi' : i ∈ Iic n := mem_Iic.2 hi
            have := congrArg (fun f => f ⟨i, hi'⟩) hx0_traj
            simpa [frestrictLe_apply, x1, IicProdIoc, hi] using this
          · -- last coordinate is forced to be `n+1`
            have hi_gt : n < i := lt_of_not_ge hi
            have hi_le : i ≤ n.succ := mem_Iic.1 hiIic
            have hi_eq : i = n.succ := Nat.le_antisymm hi_le (Nat.succ_le_of_lt hi_gt)
            subst hi_eq
            simpa [frestrictLe_apply, x1, IicProdIoc, hi, z, hs_mem]
        simpa [Set.mem_preimage, Set.mem_singleton_iff] using hx1_traj
      · intro hmem
        have hx1_traj : frestrictLe (π := StepFamily) n.succ traj = x1 := by
          simpa [Set.mem_preimage, Set.mem_singleton_iff] using hmem
        have hs_mem : traj n.succ = s := by
          -- Evaluate at the last index.
          have := congrArg (fun f => f ⟨n.succ, mem_Iic.2 (le_rfl)⟩) hx1_traj
          simpa [frestrictLe_apply, x1, IicProdIoc, z, MeasurableEquiv.piSingleton] using this
        have hx0_traj : frestrictLe (π := StepFamily) n traj = x0 := by
          funext i
          have hi_le : (i : ℕ) ≤ n := mem_Iic.1 i.2
          have := congrArg (fun f => f ⟨i.1, mem_Iic.2 (hi_le.trans n.le_succ)⟩) hx1_traj
          simpa [frestrictLe_apply, x1, IicProdIoc, hi_le] using this
        have hpfx_mem : traj ∈ cylinderSet pfx := by
          simpa [h_cyl, Set.mem_preimage, Set.mem_singleton_iff] using hx0_traj
        exact ⟨hpfx_mem, hs_mem⟩

    -- Rewrite the goal to a statement about singleton cylinder events in the IT prefix spaces.
    haveI : ∀ m, IsMarkovKernel (transitionKernelWithPolicy μ π m) :=
      fun m => transitionKernelWithPolicy_isMarkov μ π m h_stoch

    have h_meas_n : Measurable (frestrictLe (π := StepFamily) n) :=
      measurable_frestrictLe (X := StepFamily) n
    have h_meas_succ : Measurable (frestrictLe (π := StepFamily) n.succ) :=
      measurable_frestrictLe (X := StepFamily) n.succ

    have hx0_meas : MeasurableSet ({x0} : Set (Π i : Iic n, StepFamily i)) := by simp
    have hx1_meas : MeasurableSet ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by simp

    -- Convert the sets to `map`-probabilities.
    have hA :
        environmentMeasureWithPolicy μ π h_stoch ((frestrictLe (π := StepFamily) n) ⁻¹'
          ({x0} : Set (Π i : Iic n, StepFamily i))) =
          (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) n)
            ({x0} : Set (Π i : Iic n, StepFamily i)) := by
      simpa using
        (MeasureTheory.Measure.map_apply (μ := environmentMeasureWithPolicy μ π h_stoch) h_meas_n hx0_meas).symm

    have hB :
        environmentMeasureWithPolicy μ π h_stoch ((frestrictLe (π := StepFamily) n.succ) ⁻¹'
          ({x1} : Set (Π i : Iic n.succ, StepFamily i))) =
          (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) n.succ)
            ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
      simpa using
        (MeasureTheory.Measure.map_apply (μ := environmentMeasureWithPolicy μ π h_stoch) h_meas_succ hx1_meas).symm

    -- Compute the prefix measures via `partialTraj`.
    have h_map_prefix (k : ℕ) :
        (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) k) =
          Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 k ∘ₘ initialMeasureIic0WithPolicy μ π := by
      have hk_meas : Measurable (frestrictLe (π := StepFamily) k) := measurable_frestrictLe (X := StepFamily) k
      simp [environmentMeasureWithPolicy]
      rw [MeasureTheory.Measure.map_comp (μ := initialMeasureIic0WithPolicy μ π)
        (κ := @Kernel.traj StepFamily (fun _ => inferInstance) (transitionKernelWithPolicy μ π)
          (fun n => transitionKernelWithPolicy_isMarkov μ π n h_stoch) 0) hk_meas]
      rw [Kernel.traj_map_frestrictLe]

    -- Let μₙ be the distribution of prefixes up to time n.
    let μn : MeasureTheory.Measure (Π i : Iic n, StepFamily i) :=
      (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) n)

    let μn1 : MeasureTheory.Measure (Π i : Iic n.succ, StepFamily i) :=
      (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) n.succ)

    have hμn : μn = Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n ∘ₘ initialMeasureIic0WithPolicy μ π := by
      simpa [μn] using h_map_prefix n

    have hμn1 : μn1 = Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n.succ ∘ₘ initialMeasureIic0WithPolicy μ π := by
      simpa [μn1] using h_map_prefix n.succ

    have hμn1_fact :
        μn1 = Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ∘ₘ μn := by
      -- factor `partialTraj 0 (n+1)` through time `n`
      have hPT :
          Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n.succ =
            Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ∘ₖ
              Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n := by
        simpa [Nat.succ_eq_add_one] using
          (Kernel.partialTraj_succ_eq_comp (κ := transitionKernelWithPolicy μ π) (a := 0) (b := n) (Nat.zero_le n))
      calc
        μn1 = Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n.succ ∘ₘ initialMeasureIic0WithPolicy μ π := by
          simpa [μn1] using hμn1
        _ = (Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ∘ₖ
              Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n) ∘ₘ
              initialMeasureIic0WithPolicy μ π := by
          simp [hPT]
        _ = Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ∘ₘ
              (Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n ∘ₘ initialMeasureIic0WithPolicy μ π) := by
          -- reassociate kernel/measure composition
          simpa using (MeasureTheory.Measure.comp_assoc (μ := initialMeasureIic0WithPolicy μ π)
            (κ := Kernel.partialTraj (transitionKernelWithPolicy μ π) 0 n)
            (η := Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ)).symm
        _ = Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ∘ₘ μn := by
          simpa [μn] using congrArg (fun m => Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ∘ₘ m) hμn.symm

    -- Evaluate the singleton probability at time `n+1`.
    have h_singleton_step :
        μn1 ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
          μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasureWithPolicy μ π n x0 {s} := by
      -- Expand the one-step composition `partialTraj n (n+1) ∘ₘ μn` as a finite sum.
      have hsum :
          μn1 ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
            ∑ ω : (Π i : Iic n, StepFamily i),
              μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
                Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ω
                  ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
        have hx1_meas' : MeasurableSet ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by simp
        rw [hμn1_fact]
        rw [MeasureTheory.Measure.comp_eq_sum_of_countable (μ := μn)
          (κ := Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ)]
        rw [MeasureTheory.Measure.sum_apply_of_countable]
        rw [tsum_fintype]
        simp [MeasureTheory.Measure.smul_apply, smul_eq_mul]

      -- Compute the transition kernel contribution at `{x1}`: only `ω = x0` contributes.
      have h_partialTraj_singleton (ω : Π i : Iic n, StepFamily i) :
          Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ω
              ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
            if ω = x0 then transitionMeasureWithPolicy μ π n ω {s} else 0 := by
        have hPT := Kernel.partialTraj_succ_self (κ := transitionKernelWithPolicy μ π) n
        have hx1_meas' : MeasurableSet ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by simp
        have hIic_meas : Measurable (IicProdIoc (X := StepFamily) n n.succ) := by fun_prop
        have h_preimage :
            (IicProdIoc (X := StepFamily) n n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
              ({(x0, z)} : Set ((Π i : Iic n, StepFamily i) × (Π i : Ioc n n.succ, StepFamily i))) := by
          classical
          let e :=
            MeasurableEquiv.IicProdIoc (X := StepFamily) (a := n) (b := n.succ) (Nat.le_succ n)
          have hx1' : e (x0, z) = x1 := by
            simp [e, x1, MeasurableEquiv.coe_IicProdIoc]
          have hx1_symm : e.symm x1 = (x0, z) := by
            simpa [hx1'] using (e.symm_apply_apply (x0, z))
          ext y
          constructor
          · intro hy
            have hy' : IicProdIoc (X := StepFamily) n n.succ y = x1 := by
              simpa [Set.mem_preimage, Set.mem_singleton_iff] using hy
            have hy'' : e y = x1 := by
              simpa [e, MeasurableEquiv.coe_IicProdIoc] using hy'
            have : y = e.symm x1 := (e.apply_eq_iff_eq_symm_apply).1 hy''
            simpa [Set.mem_singleton_iff, hx1_symm] using this
          · intro hy
            have : y = (x0, z) := by simpa [Set.mem_singleton_iff] using hy
            subst this
            simp [Set.mem_preimage, Set.mem_singleton_iff, x1]
        -- Now compute `partialTraj` on the singleton.
        rw [hPT]
        rw [Kernel.map_apply' _ (by fun_prop) ω hx1_meas']
        have h_prod_meas :
            MeasurableSet ((IicProdIoc (X := StepFamily) n n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i))) := by
          simpa using hx1_meas'.preimage hIic_meas
        rw [Kernel.id_prod_apply' _ ω h_prod_meas]
        rw [h_preimage]
        by_cases hω : ω = x0
        · subst hω
          have hmk :
              Prod.mk x0 ⁻¹'
                  ({(x0, z)} :
                    Set ((Π i : Iic n, StepFamily i) × (Π i : Ioc n n.succ, StepFamily i))) =
                ({z} : Set (Π i : Ioc n n.succ, StepFamily i)) := by
            ext u
            simp [Set.mem_preimage, Set.mem_singleton_iff]
          simp [hmk]
          rw [Kernel.map_apply' (κ := transitionKernelWithPolicy μ π n) (f := (MeasurableEquiv.piSingleton n))
            (MeasurableEquiv.piSingleton n).measurable x0 (by simp)]
          have hz :
              (MeasurableEquiv.piSingleton n) ⁻¹' ({z} : Set (Π i : Ioc n n.succ, StepFamily i)) =
                ({s} : Set Step) := by
            ext t
            simp [z, Set.mem_preimage, Set.mem_singleton_iff]
          simp [transitionKernelWithPolicy, hz]
        · have hmk :
              Prod.mk ω ⁻¹'
                  ({(x0, z)} :
                    Set ((Π i : Iic n, StepFamily i) × (Π i : Ioc n n.succ, StepFamily i))) =
                (∅ : Set (Π i : Ioc n n.succ, StepFamily i)) := by
            ext u
            simp [Set.mem_preimage, Set.mem_singleton_iff, hω]
          simp [hmk, hω]

      -- Use the singleton formula to collapse the finite sum to the `ω = x0` term.
      rw [hsum]
      classical
      have h_other (ω : (Π i : Iic n, StepFamily i)) (hω : ω ≠ x0) :
          μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
              Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ω
                ({x1} : Set (Π i : Iic n.succ, StepFamily i)) =
            0 := by
        simp [h_partialTraj_singleton ω, hω]
      have : (∑ ω : (Π i : Iic n, StepFamily i),
          μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
            Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ω
              ({x1} : Set (Π i : Iic n.succ, StepFamily i))) =
          μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasureWithPolicy μ π n x0 {s} := by
        calc
          (∑ ω : (Π i : Iic n, StepFamily i),
                μn ({ω} : Set (Π i : Iic n, StepFamily i)) *
                  Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ ω
                    ({x1} : Set (Π i : Iic n.succ, StepFamily i))) =
              μn ({x0} : Set (Π i : Iic n, StepFamily i)) *
                Kernel.partialTraj (transitionKernelWithPolicy μ π) n n.succ x0
                  ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
            simpa using (Fintype.sum_eq_single x0 (fun ω hω => h_other ω hω))
          _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasureWithPolicy μ π n x0 {s} := by
            simp [h_partialTraj_singleton x0]
      simpa using this

    have h_trans :
        transitionMeasureWithPolicy μ π n x0 {s} =
          π.policy pfx s.action * μ.prob (pfx ++ [HistElem.act s.action]) s.percept := by
      simpa [hpfx_iic] using (transitionMeasureWithPolicy_singleton μ π n x0 s)

    have h_setL :
        cylinderSet pfx ∩ {traj | traj n.succ = s} =
          (frestrictLe (π := StepFamily) n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i)) :=
      h_inter
    have h_setR :
        cylinderSet pfx =
          (frestrictLe (π := StepFamily) n) ⁻¹' ({x0} : Set (Π i : Iic n, StepFamily i)) :=
      h_cyl

    calc
      environmentMeasureWithPolicy μ π h_stoch (cylinderSet pfx ∩ {traj | traj n.succ = s})
          = environmentMeasureWithPolicy μ π h_stoch
              ((frestrictLe (π := StepFamily) n.succ) ⁻¹' ({x1} : Set (Π i : Iic n.succ, StepFamily i))) := by
                simp [h_setL]
      _ = (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) n.succ)
            ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := by
                exact hB
      _ = μn1 ({x1} : Set (Π i : Iic n.succ, StepFamily i)) := rfl
      _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) * transitionMeasureWithPolicy μ π n x0 {s} := by
            simpa using h_singleton_step
      _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) *
            (π.policy pfx s.action * μ.prob (pfx ++ [HistElem.act s.action]) s.percept) := by
            simp [h_trans]
      _ = environmentMeasureWithPolicy μ π h_stoch (cylinderSet pfx) *
            π.policy pfx s.action * μ.prob (pfx ++ [HistElem.act s.action]) s.percept := by
            have :
                environmentMeasureWithPolicy μ π h_stoch (cylinderSet pfx) =
                  μn ({x0} : Set (Π i : Iic n, StepFamily i)) := by
                calc
                  environmentMeasureWithPolicy μ π h_stoch (cylinderSet pfx)
                      = environmentMeasureWithPolicy μ π h_stoch
                          ((frestrictLe (π := StepFamily) n) ⁻¹' ({x0} : Set (Π i : Iic n, StepFamily i))) := by
                            simp [h_setR]
                  _ = (environmentMeasureWithPolicy μ π h_stoch).map (frestrictLe (π := StepFamily) n)
                        ({x0} : Set (Π i : Iic n, StepFamily i)) := hA
                  _ = μn ({x0} : Set (Π i : Iic n, StepFamily i)) := rfl
            simp [this, mul_assoc]

/-! ## Single-Step Chain Rule

The fundamental building block: adding one (action, percept) pair multiplies
the measure by uniformActionProb × μ.prob(percept | history).
-/

/-- **Single-step chain rule**: Adding one (act, per) pair to a history.

    This is the atomic case of the chain rule. It follows from how
    the transition kernel is constructed: each step contributes
    uniformActionProb (for the action) × μ.prob (for the percept).

    **Proof Strategy**:

    1. Express both cylinder sets in Mathlib's `cylinder (Iic b) S` format:
       - `cylinderSet pfx` corresponds to `cylinder (Iic (historySteps pfx - 1)) S₁`
       - `cylinderSet (pfx ++ [act a, per x])` corresponds to `cylinder (Iic (historySteps pfx)) S₂`

    2. Use `trajContent_cylinder` from Mathlib to express measures via `partialTraj`:
       - `environmentMeasure μ h_stoch (cylinderSet pfx) = partialTraj κ 0 t₁ x₀ S₁`
       - `environmentMeasure μ h_stoch (cylinderSet (pfx ++ [act a, per x])) = partialTraj κ 0 t₂ x₀ S₂`

    3. Use the factorization of `partialTraj` at the transition step:
       - `partialTraj κ 0 (t+1) x₀ S₂ = ∫ ... dκ × partialTraj κ 0 t x₀ S₁`
       - This is the key step using `partialTraj_succ` or similar

    4. The integral over the transition kernel at step t gives:
       - uniformActionProb (action distribution)
       - × μ.prob (pfx ++ [act a]) x (percept distribution)

    **Key Insight**: The `transitionKernel μ t` is defined exactly so that
    its mass at `Step.mk a x` is `uniformActionProb × μ.prob (h ++ [act a]) x`.
    This is the design that makes the factorization work.

    **TODO**: Full proof requires careful setup of the correspondence between
    our History-based cylinder sets and Mathlib's Iic-indexed cylinder sets.
    This involves showing that the embeddings are measure-preserving. -/
theorem cylinderSet_append_single_step (μ : Environment) (h_stoch : isStochastic μ)
    (pfx : History) (a : Action) (x : Percept)
    (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) :
    environmentMeasure μ h_stoch (cylinderSet (pfx ++ [HistElem.act a, HistElem.per x])) =
      environmentMeasure μ h_stoch (cylinderSet pfx) *
        uniformActionProb * μ.prob (pfx ++ [HistElem.act a]) x := by
  -- Step 1: Decompose the extended cylinder as an intersection
  have h_decomp := cylinderSet_append_eq_inter pfx a x h_pfx_wf h_pfx_complete
  rw [h_decomp]

  -- Step 2: Apply IT product factorization
  -- The key lemma says:
  --   μ(cylinderSet pfx ∩ {traj | traj n = s}) =
  --     μ(cylinderSet pfx) × uniformActionProb × μ.prob(pfx ++ [act s.action]) s.percept
  exact IT_product_factorization μ h_stoch pfx h_pfx_wf h_pfx_complete (Step.mk a x)

/-- **Single-step chain rule (policy-driven)**: Adding one (act, per) pair to a history
under the policy-induced trajectory measure `environmentMeasureWithPolicy`.

This is the same as `cylinderSet_append_single_step`, but with the history-dependent
action probability `π.policy pfx a` in place of the constant `uniformActionProb`. -/
theorem cylinderSet_append_single_stepWithPolicy (μ : Environment) (π : Agent) (h_stoch : isStochastic μ)
    (pfx : History) (a : Action) (x : Percept)
    (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) :
    environmentMeasureWithPolicy μ π h_stoch (cylinderSet (pfx ++ [HistElem.act a, HistElem.per x])) =
      environmentMeasureWithPolicy μ π h_stoch (cylinderSet pfx) *
        π.policy pfx a * μ.prob (pfx ++ [HistElem.act a]) x := by
  have h_decomp := cylinderSet_append_eq_inter pfx a x h_pfx_wf h_pfx_complete
  rw [h_decomp]
  exact IT_product_factorizationWithPolicy μ π h_stoch pfx h_pfx_wf h_pfx_complete (Step.mk a x)

/-! ## Chain Rule for Cylinder Measures -/

/-- Auxiliary: well-formed append preserves well-formedness when adding [act, per].
    This only works for even-length prefixes (complete histories). -/
theorem wellFormed_append_pair (pfx : History) (a : Action) (x : Percept)
    (h_pfx_wf : pfx.wellFormed) (h_pfx_complete : Even pfx.length) :
    (pfx ++ [HistElem.act a, HistElem.per x]).wellFormed := by
  -- Strong induction on length of pfx
  generalize hlen : pfx.length = len
  induction len using Nat.strong_induction_on generalizing pfx with
  | _ len ih =>
    cases pfx with
    | nil =>
      -- pfx = [], so pfx ++ [act a, per x] = [act a, per x]
      simp only [List.nil_append, History.wellFormed]
    | cons elem rest =>
      cases elem with
      | act a' =>
        cases rest with
        | nil =>
          -- pfx = [act a'], length = 1 (odd), contradicts h_pfx_complete
          simp only [List.length_singleton] at h_pfx_complete
          exact absurd h_pfx_complete (by decide : ¬Even 1)
        | cons elem' rest' =>
          cases elem' with
          | act _ =>
            -- pfx = [act a', act _, ...] is not well-formed
            exact absurd h_pfx_wf (by simp only [History.wellFormed]; decide)
          | per x' =>
            -- pfx = [act a', per x', rest']
            have h_wf_rest' : History.wellFormed rest' := h_pfx_wf
            have h_complete_rest' : Even rest'.length := by
              simp only [List.length_cons] at h_pfx_complete
              have heq : rest'.length + 1 + 1 = rest'.length + 2 := by ring
              rw [heq, Nat.even_add] at h_pfx_complete
              exact h_pfx_complete.mpr (by decide : Even 2)
            have h_len_rest' : rest'.length < len := by
              simp only [List.length_cons] at hlen
              omega
            -- pfx ++ [act a, per x] = [act a', per x'] ++ (rest' ++ [act a, per x])
            have h_assoc : (HistElem.act a' :: HistElem.per x' :: rest') ++ [HistElem.act a, HistElem.per x] =
                HistElem.act a' :: HistElem.per x' :: (rest' ++ [HistElem.act a, HistElem.per x]) := by
              simp only [List.cons_append]
            rw [h_assoc]
            simp only [History.wellFormed]
            -- Apply IH to rest'
            exact ih rest'.length h_len_rest' rest' h_wf_rest' h_complete_rest' rfl
      | per _ =>
        exact absurd h_pfx_wf (by simp only [History.wellFormed]; decide)

/-- **Chain rule for cylinder measures** (generalized version).

    By strong induction on historySteps h. -/
theorem cylinderSet_append_measure (μ : Environment) (h_stoch : isStochastic μ)
    (pfx h : History) (h_pfx_wf : pfx.wellFormed) (h_wf : h.wellFormed)
    (h_pfx_complete : Even pfx.length) (h_complete : Even h.length) :
    environmentMeasure μ h_stoch (cylinderSet (pfx ++ h)) =
      environmentMeasure μ h_stoch (cylinderSet pfx) *
        uniformActionProb ^ (historySteps h) * historyProbabilityAux μ pfx h := by
  -- Strong induction on historySteps h
  generalize hn : historySteps h = n
  induction n using Nat.strong_induction_on generalizing pfx h with
  | _ n ih =>
  cases h with
  | nil =>
    -- Base case: h = []
    -- First: hn tells us n = 0 (since historySteps [] = 0)
    simp only [historySteps, List.length_nil, Nat.zero_div] at hn
    subst hn
    -- Now the goal has uniformActionProb^0 = 1
    simp only [List.append_nil, pow_zero, historyProbabilityAux_nil, mul_one]
  | cons elem rest =>
    cases elem with
    | act a =>
      cases rest with
      | nil =>
        -- h = [act a], but this has odd length, contradicting h_complete
        simp only [List.length_singleton] at h_complete
        exact absurd h_complete (by decide : ¬Even 1)
      | cons elem' rest' =>
        cases elem' with
        | act a' =>
          -- h = [act a, act a', ...] is not well-formed
          exact absurd h_wf (by simp only [History.wellFormed]; decide)
        | per x =>
          -- Main case: h = [act a, per x, rest']
          have h_wf_rest' : History.wellFormed rest' := h_wf
          have h_complete_rest' : Even rest'.length := by
            simp only [List.length_cons] at h_complete
            have heq : rest'.length + 1 + 1 = rest'.length + 2 := by ring
            rw [heq, Nat.even_add] at h_complete
            exact h_complete.mpr (by decide : Even 2)

          -- Extract that n = 1 + historySteps rest' from hn
          have hn_decomp : n = 1 + historySteps rest' := by
            rw [← hn, historySteps_cons_cons]

          -- historySteps rest' < n
          have h_steps_lt : historySteps rest' < n := by
            rw [hn_decomp]; omega

          -- Extended prefix properties
          have h_pfx'_wf := wellFormed_append_pair pfx a x h_pfx_wf h_pfx_complete
          have h_pfx'_complete : Even (pfx ++ [HistElem.act a, HistElem.per x]).length := by
            simp only [List.length_append, List.length_cons, List.length_nil]
            rw [Nat.even_add]
            constructor
            · intro _; decide
            · intro _; exact h_pfx_complete

          -- Decompose: pfx ++ [act a, per x, rest'] = (pfx ++ [act a, per x]) ++ rest'
          have h_append_assoc : pfx ++ (HistElem.act a :: HistElem.per x :: rest') =
              (pfx ++ [HistElem.act a, HistElem.per x]) ++ rest' := by
            simp only [List.cons_append, List.nil_append, List.append_assoc]
          rw [h_append_assoc]

          -- Apply IH to rest' (which has fewer steps)
          have ih_rest' := ih (historySteps rest') h_steps_lt
              (pfx ++ [HistElem.act a, HistElem.per x]) rest'
              h_pfx'_wf h_wf_rest' h_pfx'_complete h_complete_rest' rfl
          rw [ih_rest']

          -- Now use single-step chain rule
          rw [cylinderSet_append_single_step μ h_stoch pfx a x h_pfx_wf h_pfx_complete]

          -- Decompose the probability and power terms
          rw [historyProbabilityAux_cons_cons]
          rw [hn_decomp, pow_add, pow_one]

          -- Now it's algebra: rearrange the products
          ring
    | per x =>
      -- h = [per x, ...] is not well-formed (must start with action)
      exact absurd h_wf (by simp only [History.wellFormed]; decide)

/-! ## Base Case Lemmas for historyProbability_eq_measure

The proof of historyProbability_eq_measure proceeds by showing:
1. Base case: Empty history has probability 1, and its cylinder set is the full space
2. Inductive case: The recursive structure matches the kernel composition
-/

/-- The cylinder set for empty history is the full trajectory space. -/
theorem cylinderSet_empty : cylinderSet ([] : History) = Set.univ := by
  ext traj
  simp only [cylinderSet, Set.mem_setOf_eq, Set.mem_univ, iff_true]
  exact ⟨0, trajectoryToHistory_zero traj⟩

/-- historyProbability of empty history is 1. -/
theorem historyProbability_empty (μ : Environment) :
    historyProbability μ [] = 1 := rfl

/-- Base case: historyProbability_eq_measure for empty history.
    For h = [], historySteps h = 0, so uniformActionProb^0 = 1. -/
theorem historyProbability_eq_measure_empty (μ : Environment) (h_stoch : isStochastic μ) :
    uniformActionProb ^ (historySteps ([] : History)) * historyProbability μ [] =
      environmentMeasure μ h_stoch (cylinderSet []) := by
  simp only [historySteps, List.length_nil, Nat.zero_div, pow_zero, one_mul]
  rw [historyProbability_empty, cylinderSet_empty, environmentMeasure_univ_eq_one]

/-! ## Connection to Mathlib's Cylinder Sets

We need to show that our `cylinderSetAt t h` corresponds to a Mathlib `cylinder`.
The key insight is that cylinderSetAt is determined by a finite prefix, which
is exactly what Mathlib's cylinder sets capture.
-/

/-- Convert a history to a function on Fin (historySteps h) → Step.
    This maps the history [act₀, per₀, ..., actₙ, perₙ] to a function
    that returns the Step at each index. -/
noncomputable def historyToPrefix (h : History) (_hw : h.wellFormed) :
    Fin (historySteps h) → Step :=
  fun i =>
    -- Extract the (action, percept) pair at position i
    let actIdx := 2 * i.val
    let perIdx := actIdx + 1
    let act : Action := (h[actIdx]?).bind (fun e =>
      match e with
      | HistElem.act a => some a
      | _ => none) |>.getD default
    let per : Percept := (h[perIdx]?).bind (fun e =>
      match e with
      | HistElem.per p => some p
      | _ => none) |>.getD default
    Step.mk act per

/-- The singleton set containing exactly the prefix determined by history h.
    This is the target set S in Mathlib's cylinder (Iic t) S. -/
def historyPrefixSet (h : History) (hw : h.wellFormed) : Set (Fin (historySteps h) → Step) :=
  {historyToPrefix h hw}

/-- Our cylinderSetAt t h is a preimage under truncation.
    Specifically: cylinderSetAt t h = (truncate t)⁻¹' {p | prefixToHistory t p = h} -/
theorem cylinderSetAt_eq_preimage (t : ℕ) (h : History) :
    cylinderSetAt t h = truncate t ⁻¹' {p | prefixToHistory t p = h} := by
  ext traj
  simp only [cylinderSetAt, Set.mem_preimage, Set.mem_setOf_eq]
  rw [prefixToHistory_eq_trajectoryToHistory]

/-- For a well-formed history of length 2t, cylinderSetAt t h equals cylinderSet h.
    This is because a well-formed history determines a unique t. -/
theorem cylinderSet_eq_cylinderSetAt (h : History) (_hw : h.wellFormed) :
    cylinderSet h = cylinderSetAt (historySteps h) h := by
  ext traj
  simp only [cylinderSet, cylinderSetAt, Set.mem_setOf_eq]
  constructor
  · -- (→) If trajectoryToHistory traj t = h for some t, then t = historySteps h
    intro ⟨t, ht⟩
    -- trajectoryToHistory always produces well-formed histories of length 2t
    have h_len : h.length = 2 * t := by
      rw [← ht]
      exact trajectoryToHistory_length traj t
    simp only [historySteps]
    -- h.length = 2 * t implies h.length / 2 = t
    have : h.length / 2 = t := by
      rw [h_len]
      exact Nat.mul_div_cancel_left t (by norm_num : 0 < 2)
    exact this ▸ ht
  · -- (←) Direct
    intro ht
    exact ⟨historySteps h, ht⟩

/-- The measure of a cylinder set equals the history probability times action probability.

    **Key insight**: The environmentMeasure includes uniform action probabilities
    (uniformActionProb per step), while historyProbability only tracks percept
    probabilities given actions. The correction factor is uniformActionProb^n
    where n = historySteps h = h.length / 2.

    For likelihood ratios ν(h)/ν*(h), this factor cancels (same actions in both),
    so historyProbability suffices for Bayesian consistency proofs.

    The proof follows from the Ionescu-Tulcea construction:
    - environmentMeasure is built from transition probabilities via traj kernel
    - Each step contributes: uniformActionProb × μ.prob(percept|history,action)
    - cylinderSet h = {traj | ∃t, trajectoryToHistory traj t = h}
    - By Ionescu-Tulcea consistency:
      environmentMeasure(cylinderSet h) = uniformActionProb^n × historyProbability μ h

    **IMPORTANT**: This theorem requires `h` to be well-formed and have even length.
    - Well-formed: alternates [act, per, act, per, ...]
    - Even length: excludes incomplete histories like [act a]
    Histories violating these have mismatched values. -/
theorem historyProbability_eq_measure (μ : Environment) (h_stoch : isStochastic μ) (h : History)
    (h_wf : h.wellFormed) (h_complete : Even h.length) :
    uniformActionProb ^ (historySteps h) * historyProbability μ h =
      environmentMeasure μ h_stoch (cylinderSet h) := by
  -- **CLEAN PROOF USING CHAIN RULE**
  --
  -- The key observation is that h = [] ++ h, so we can apply cylinderSet_append_measure.
  -- This gives us the factorization directly without complex case analysis.
  --
  -- By cylinderSet_append_measure with pfx = []:
  --   environmentMeasure μ h_stoch (cylinderSet ([] ++ h))
  --   = environmentMeasure μ h_stoch (cylinderSet [])
  --     * uniformActionProb ^ (historySteps h)
  --     * historyProbabilityAux μ [] h
  --
  -- Since:
  --   - cylinderSet [] = Set.univ (by cylinderSet_empty)
  --   - environmentMeasure μ h_stoch Set.univ = 1 (by environmentMeasure_univ_eq_one)
  --   - historyProbabilityAux μ [] h = historyProbability μ h (by definition)
  --   - [] ++ h = h
  --
  -- We get: environmentMeasure(cylinderSet h) = uniformActionProb^n * historyProbability μ h
  --
  -- Converting to the form in our goal (LHS = RHS):
  have h_chain := cylinderSet_append_measure μ h_stoch [] h
      (by simp [History.wellFormed]) h_wf (by simp) h_complete
  simp only [List.nil_append, cylinderSet_empty, environmentMeasure_univ_eq_one, one_mul] at h_chain
  -- h_chain : environmentMeasure μ h_stoch (cylinderSet h) =
  --           uniformActionProb^(historySteps h) * historyProbabilityAux μ [] h
  --
  -- Goal: uniformActionProb^n * historyProbability μ h = environmentMeasure ...
  -- Since historyProbability μ h = historyProbabilityAux μ [] h by definition:
  simp only [historyProbability]
  -- Goal: uniformActionProb^n * historyProbabilityAux μ [] h = environmentMeasure ...
  -- This matches h_chain exactly (just reversed)
  exact h_chain.symm

/-! ## Conditional Expectation Structure

For martingale theory, we need to express conditional expectations
with respect to the filtration.
-/

/-- If two trajectories agree on first t steps, truncate gives equal results. -/
theorem truncate_eq_of_prefix_eq (traj₁ traj₂ : Trajectory) (t : ℕ)
    (h : ∀ i < t, traj₁ i = traj₂ i) : truncate t traj₁ = truncate t traj₂ := by
  funext i
  simp only [truncate]
  exact h i.val i.isLt

/-- A function on Trajectory is ℱ_t-measurable iff it depends only on first t steps.
    We use @Measurable to explicitly specify the MeasurableSpace.

    **Proof**:
    (→) If f is measurable w.r.t. comap (truncate t) m, then for any two trajectories
        with the same t-prefix, f gives the same value. This is because f⁻¹({r}) is
        a preimage under truncate, so membership depends only on the truncation.
    (←) If f depends only on first t steps, it factors through truncate t.
        Define T = {p | ∃ traj, truncate t traj = p ∧ f traj ∈ B}. Since (Fin t → Step)
        is a finite type, T is measurable, and f⁻¹(B) = (truncate t)⁻¹(T). -/
theorem measurable_wrt_filtration_iff (f : Trajectory → ℝ) (t : ℕ) :
    @Measurable Trajectory ℝ (sigmaAlgebraUpTo t) _ f ↔
    ∀ traj₁ traj₂, (∀ i < t, traj₁ i = traj₂ i) → f traj₁ = f traj₂ := by
  constructor
  · -- (→) If measurable w.r.t. ℱ_t = comap (truncate t) ⊤, then depends only on first t steps
    intro hf traj₁ traj₂ heq
    have h_trunc : truncate t traj₁ = truncate t traj₂ := truncate_eq_of_prefix_eq traj₁ traj₂ t heq
    -- Key insight: f being measurable w.r.t. comap means f⁻¹(B) is a preimage under truncate.
    -- For the singleton {f traj₁}, f⁻¹({f traj₁}) = (truncate t)⁻¹(T) for some T.
    -- Since traj₁ ∈ f⁻¹({f traj₁}), we have truncate t traj₁ ∈ T.
    -- By h_trunc, truncate t traj₂ ∈ T, so traj₂ ∈ f⁻¹({f traj₁}), so f traj₂ = f traj₁.
    have h_singleton : MeasurableSet ({f traj₁} : Set ℝ) := measurableSet_singleton _
    have h_preimage : @MeasurableSet Trajectory (sigmaAlgebraUpTo t) (f ⁻¹' {f traj₁}) := hf h_singleton
    -- Use measurableSet_comap: MeasurableSet[m.comap f] s ↔ ∃ s', MeasurableSet[m] s' ∧ f⁻¹' s' = s
    simp only [sigmaAlgebraUpTo, MeasurableSpace.measurableSet_comap] at h_preimage
    obtain ⟨T, _, hT_eq⟩ := h_preimage
    -- Now: truncate t ⁻¹' T = f⁻¹' {f traj₁}
    have h1 : traj₁ ∈ f ⁻¹' {f traj₁} := Set.mem_preimage.mpr (Set.mem_singleton _)
    rw [← hT_eq] at h1
    -- So traj₁ ∈ (truncate t)⁻¹' T, i.e., truncate t traj₁ ∈ T
    have h2 : truncate t traj₂ ∈ T := by rw [← h_trunc]; exact h1
    -- So traj₂ ∈ (truncate t)⁻¹' T = f⁻¹' {f traj₁}
    have h3 : traj₂ ∈ f ⁻¹' {f traj₁} := by rw [← hT_eq]; exact h2
    -- h3 says f traj₂ ∈ {f traj₁}, i.e., f traj₂ = f traj₁
    exact (Set.mem_singleton_iff.mp (Set.mem_preimage.mp h3)).symm

  · -- (←) If depends only on first t steps, then measurable w.r.t. ℱ_t
    intro hf
    -- Proof strategy: f factors through truncate t as f = g ∘ truncate t
    -- For any measurable B ⊆ ℝ, f⁻¹(B) = (truncate t)⁻¹(T) for some T, which is in comap.
    unfold Measurable
    intro B hB
    -- Need: f⁻¹(B) is in comap (truncate t) ⊤
    simp only [sigmaAlgebraUpTo, MeasurableSpace.measurableSet_comap]
    -- Define the target set T = {p | ∃ traj with truncate t traj = p and f traj ∈ B}
    let T := {p : Fin t → Step | ∃ traj, truncate t traj = p ∧ f traj ∈ B}
    use T
    constructor
    · -- T is measurable (finite type, so all sets are measurable)
      exact (Set.toFinite T).measurableSet
    · -- truncate t ⁻¹' T = f⁻¹' B
      ext traj
      simp only [Set.mem_preimage, T, Set.mem_setOf_eq]
      constructor
      · intro ⟨traj', h_trunc_eq, hfB'⟩
        -- f traj = f traj' because truncate t traj = truncate t traj'
        have h_eq : f traj = f traj' := by
          apply hf
          intro i hi
          have h := congrFun h_trunc_eq ⟨i, hi⟩
          simp only [truncate] at h
          exact h.symm
        rw [h_eq]
        exact hfB'
      · intro hfB
        exact ⟨traj, rfl, hfB⟩

/-- trajectoryToHistory at time t is ℱ_t-measurable.
    This means extracting history at time t depends only on the first t steps. -/
theorem trajectoryToHistory_adapted (t : ℕ) :
    ∀ traj₁ traj₂, (∀ i < t, traj₁ i = traj₂ i) →
      trajectoryToHistory traj₁ t = trajectoryToHistory traj₂ t :=
  fun traj₁ traj₂ => trajectoryToHistory_depends_on_prefix traj₁ traj₂ t

/-! ## Summary of Phase 1

We have established:
1. `Trajectory` - the sample space of infinite interaction sequences
2. `trajectoryFiltration` - the canonical filtration
3. `trajectoryToHistory` - conversion from trajectory to history
4. `environmentMeasure` - the probability measure induced by an environment

Key theorems:
- `trajectoryToHistory_depends_on_prefix` - history depends on finite prefix
- `trajectoryToHistory_adapted` - history is adapted to filtration
- `historyProbability_eq_measure` (axiom) - bridge between discrete and continuous

Remaining sorries (to be proved):
- `cylinderSet_measurable` - cylinder sets are measurable
- `measurable_wrt_filtration_iff` - characterization of ℱ_t-measurability

The axiom `historyProbability_eq_measure` encapsulates the Ionescu-Tulcea
construction. A full proof would require formalizing that theorem.
-/

end Mettapedia.UniversalAI.GrainOfTruth.MeasureTheory.HistoryFiltration
