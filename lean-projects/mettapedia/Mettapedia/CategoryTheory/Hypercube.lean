import Mettapedia.CategoryTheory.LambdaTheory
import Mettapedia.CategoryTheory.PLNInstance
import Mettapedia.CategoryTheory.NativeTypeTheory
import Mettapedia.CategoryTheory.PLNTerms
import Mettapedia.CategoryTheory.ModalTypes
import Mettapedia.Logic.EvidenceQuantale

/-!
# The Hypercube Construction H_Σ

This file implements the core construction from Stay & Wells' "Generating Hypercubes
of Type Systems" - the endofunctor H_Σ that generates modal type systems from
operational semantics.

## Overview

Given a lambda theory T with:
- Base types T_type including Pr (processes)
- Operations T_oper
- Propositions T_prop including reduction ⇝ ⊆ Pr × Pr
- Entailments T_ent including base rewrites

The H_Σ construction:
1. For each base rewrite L ⇝ R and subterm t_j ⊆ L with context C_j
2. Generates a modal type ⟨C_j⟩_{x_k::A_k} B

This gives PLN deduction as the Π type generated by composition context!

## The PLN Instance

For PLN, our key rewrite is:
  (A→B) ∧ (B→C) ⇝ (A→C)   [Deduction]

This generates the modal type:
  Π_{s_AB::Evidence} Π_{s_BC::Evidence} Evidence

which is exactly the PLN deduction formula!

## References

- Stay & Wells, "Generating Hypercubes of Type Systems" (hypercube.pdf)
- Section 3: Construction of the Modal Hypercube
- Section 3.5: Dependent Product as β-generated modality
-/


namespace Mettapedia.CategoryTheory.Hypercube

open Mettapedia.CategoryTheory.LambdaTheories
open Mettapedia.CategoryTheory.PLNInstance
open Mettapedia.CategoryTheory.NativeTypeTheory
open Mettapedia.CategoryTheory.PLNTerms
open Mettapedia.CategoryTheory.ModalTypes
open Mettapedia.Logic.EvidenceQuantale

/-! ## Section 3.1: Per-Object Enrichment

For each object X of T, freely add:
- ∗^X : X (the universe of types)
- □^X : X (the universe of kinds)
- Typing relation x ::^X y

With axiom: ∗^X ::^X □^X
-/

/-- HSort symbols: ∗ (types) and □ (kinds)
    Named HSort to avoid conflict with Lean's built-in Sort -/
inductive HSort where
  | star : HSort  -- ∗ = types
  | box : HSort   -- □ = kinds
  deriving Inhabited, DecidableEq, Repr

/-- A sort assignment assigns ∗ or □ to each slot -/
abbrev SortAssignment := List HSort

/-- The two sorts as Evidence values.
    ∗^Pr = ⊤ (maximal evidence - always inhabited)
    □^Pr = ⊥ (minimal evidence - kinds are uninhabited) -/
noncomputable def sortToEvidence : HSort → Evidence
  | HSort.star => ⊤  -- ∗ is inhabited
  | HSort.box => ⊥   -- □ is uninhabited (the kind level)

/-! ## Section 3.2: Modalities from Base Rewrites

Fix a base rewrite L ⇝ R. For each subterm t_j ⊆ L:
- Let Y_j be the carrier of t_j
- Let C_j be the context (C_j[t_j] = L)
- Let FV(C_j) be free variables in C_j

For each x_k ∈ FV(C_j), assume a type A_k : X_k.
Let B : Pr be the result type.

The modal type ⟨C_j⟩_{x_k::A_k} B is formed!
-/

/-- A base rewrite in PLN.
    Captures L ⇝ R with typing information. -/
structure BaseRewrite where
  /-- Name of the rewrite rule -/
  name : String
  /-- Left-hand side (redex) -/
  lhs : PLNTerm
  /-- Right-hand side (reduct) -/
  rhs : PLNTerm
  /-- Free variables and their carriers -/
  freeVars : List (String × PLNObj)

/-- A subterm position in a rewrite's LHS -/
structure SubtermPosition where
  /-- The subterm itself -/
  subterm : PLNTerm
  /-- The one-hole context C_j with C_j[subterm] = lhs -/
  context : Context
  /-- The carrier object Y_j -/
  carrier : PLNObj
  /-- Free variables of the context FV(C_j) -/
  contextFreeVars : List String
  deriving Inhabited

/-- The PLN deduction rewrite rule:
    (A→B) ∧ (B→C) ⇝ (A→C)

    Philosophy: "Forward chaining - extend cause→effect chains"
    Shared variable: B (the middle term)
    Weakness: ONE parallel path (see `PLNSemiringQuantale.twoEdge_gt_oneEdge`) -/
def deductionRewrite : BaseRewrite where
  name := "deduction"
  lhs := PLNTerm.conj
           (PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "B"))
           (PLNTerm.impl (PLNTerm.atom "B") (PLNTerm.atom "C"))
  rhs := PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "C")
  freeVars := [("A", PLNObj.Concept "Prop"),
               ("B", PLNObj.Concept "Prop"),
               ("C", PLNObj.Concept "Prop")]

/-- The PLN induction rewrite rule:
    (A→B) ∧ (A→C) ⇝ (B→C)

    Philosophy: "Generalization - infer connection from shared cause"
    Shared variable: A (the antecedent)
    Weakness: TWO parallel paths > deduction (see `PLNSemiringQuantale.twoEdge_gt_oneEdge`)

    Example: "Ravens are black" ∧ "Ravens are birds" ⇝ "Some black things are birds" -/
def inductionRewrite : BaseRewrite where
  name := "induction"
  lhs := PLNTerm.conj
           (PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "B"))
           (PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "C"))
  rhs := PLNTerm.impl (PLNTerm.atom "B") (PLNTerm.atom "C")
  freeVars := [("A", PLNObj.Concept "Prop"),
               ("B", PLNObj.Concept "Prop"),
               ("C", PLNObj.Concept "Prop")]

/-- The PLN abduction rewrite rule:
    (A→B) ∧ (C→B) ⇝ (A→C)

    Philosophy: "Backward chaining - infer connection from shared effect"
    Shared variable: B (the consequent)
    Weakness: TWO parallel paths > deduction (see `PLNSemiringQuantale.twoEdge_gt_oneEdge`)

    Example: "Rain → wet ground" ∧ "Sprinkler → wet ground" ⇝ "Rain ~ Sprinkler?" -/
def abductionRewrite : BaseRewrite where
  name := "abduction"
  lhs := PLNTerm.conj
           (PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "B"))
           (PLNTerm.impl (PLNTerm.atom "C") (PLNTerm.atom "B"))
  rhs := PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "C")
  freeVars := [("A", PLNObj.Concept "Prop"),
               ("B", PLNObj.Concept "Prop"),
               ("C", PLNObj.Concept "Prop")]

/-- All three PLN inference rewrites -/
def plnInferenceRewrites : List BaseRewrite :=
  [deductionRewrite, inductionRewrite, abductionRewrite]

/-- Subterm positions in the deduction rewrite.

    The LHS (A→B) ∧ (B→C) has these positions:
    1. The whole term: context = hole, subterm = lhs
    2. (A→B): context = [-] ∧ (B→C), subterm = (A→B)
    3. (B→C): context = (A→B) ∧ [-], subterm = (B→C)
    4. A: context = ([-]→B) ∧ (B→C), subterm = A
    ... etc
-/
noncomputable def deductionPositions : List SubtermPosition :=
  [
    -- Position 1: The whole conjunction (A→B) ∧ (B→C)
    { subterm := deductionRewrite.lhs,
      context := Context.hole,
      carrier := PLNLambdaTheory.Pr,
      contextFreeVars := [] },

    -- Position 2: The first implication (A→B)
    { subterm := PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "B"),
      context := Context.conjLeft Context.hole
                   (PLNTerm.impl (PLNTerm.atom "B") (PLNTerm.atom "C")),
      carrier := PLNObj.Statement (PLNObj.Concept "A") (PLNObj.Concept "B"),
      contextFreeVars := ["B", "C"] },

    -- Position 3: The second implication (B→C)
    { subterm := PLNTerm.impl (PLNTerm.atom "B") (PLNTerm.atom "C"),
      context := Context.conjRight
                   (PLNTerm.impl (PLNTerm.atom "A") (PLNTerm.atom "B"))
                   Context.hole,
      carrier := PLNObj.Statement (PLNObj.Concept "B") (PLNObj.Concept "C"),
      contextFreeVars := ["A", "B"] }
  ]

/-! ## Section 3.3: Modality-Local Sort Assignments

Each modality ⟨C_j⟩_{x_k::A_k} B carries its own slot family:

  Slots(C_j, B) := { s^{X_k}_k }_{k ∈ FV(C_j)} ∪ { s^{Pr}_B }

Each slot can be ∗ or □.
-/

/-- A slot in a modality's sort family -/
inductive Slot where
  /-- Parameter slot for variable x_k at carrier X_k -/
  | param : String → PLNObj → Slot
  /-- Result slot for B at carrier Pr -/
  | result : Slot
  deriving Inhabited, DecidableEq

/-- The slot family for a subterm position.

    Slots(C_j, B) = parameter slots for FV(C_j) + result slot -/
def slotFamily (pos : SubtermPosition) : List Slot :=
  -- Parameter slots from context free variables
  (pos.contextFreeVars.map fun v => Slot.param v (PLNObj.Concept v)) ++
  -- Result slot
  [Slot.result]

/-- A local sort assignment for a modality.
    Maps each slot to ∗ or □. -/
structure LocalSortAssignment where
  /-- The subterm position this assignment is for -/
  position : SubtermPosition
  /-- Sort choice for each slot -/
  assignment : Slot → HSort

/-! ## Section 3.4: Sort Gating and Modal Hypercubes

The product of local sort choices yields a hypercube of calculi.
Each vertex specifies which slots are boxed (□) vs starred (∗).

For PLN deduction with 3 positions × ~2-3 slots each ≈ 2^6 = 64 vertices!
-/

/-- A global sort assignment Σ assigns sorts to ALL slots across all modalities -/
structure GlobalSortAssignment where
  /-- Local assignments for each subterm position -/
  locals : List LocalSortAssignment

/-- Count the dimension of the local hypercube for a position -/
def localCubeDimension (pos : SubtermPosition) : Nat :=
  (slotFamily pos).length

/-- The full hypercube dimension for a rewrite rule -/
def hypercubeDimension (positions : List SubtermPosition) : Nat :=
  positions.foldl (fun acc pos => acc + localCubeDimension pos) 0

/-- Number of vertices in the hypercube = 2^dimension -/
def hypercubeVertices (positions : List SubtermPosition) : Nat :=
  2 ^ hypercubeDimension positions

-- Note: deductionPositions is noncomputable, so we use #reduce instead
-- #reduce hypercubeDimension deductionPositions
-- Expected: ~7 (1 + 3 + 3 slots)
-- #reduce hypercubeVertices deductionPositions
-- Expected: 2^7 = 128 vertices

/-! ## Section 3.5: Dependent Product as β-Generated Modality

The key insight: Π (dependent product) is the modality generated by β-reduction!

For λ-calculus: app(lam(f), x) ⇝ f(x)
- Take t₁ = lam(f), context C₁ = app([-], x)
- FV(C₁) = {x}

Then: Π_{x:A} B := ⟨C₁⟩_{x::A} B

For PLN deduction: (A→B) ∧ (B→C) ⇝ (A→C)
- The composition context generates a Π-like modality!
-/

/-- The modal type generated from a subterm position.

    ⟨C_j⟩_{x_k::A_k} B : Y_j

    This is the key construction from Section 3.2! -/
structure ModalType where
  /-- The generating subterm position -/
  position : SubtermPosition
  /-- Type assumptions A_k for free variables x_k -/
  relies : List (String × Evidence)
  /-- Result type B : Pr -/
  resultType : Evidence

/-- Generate the modal type for PLN deduction from position 2 (A→B).

    This gives us: ⟨[-] ∧ (B→C)⟩_{s_BC::Evidence} Evidence

    Which is essentially: Π_{s_BC : Evidence} Evidence
    (the type of functions from evidence to evidence!)
-/
noncomputable def deductionModalType_AB : ModalType where
  position := deductionPositions[1]!
  relies := [("s_BC", ⊤)]  -- rely on s_BC being valid evidence
  resultType := ⊤          -- result is evidence for A→C

/-- Generate the modal type for PLN deduction from position 3 (B→C).

    This gives us: ⟨(A→B) ∧ [-]⟩_{s_AB::Evidence} Evidence
-/
noncomputable def deductionModalType_BC : ModalType where
  position := deductionPositions[2]!
  relies := [("s_AB", ⊤)]  -- rely on s_AB being valid evidence
  resultType := ⊤          -- result is evidence for A→C

/-! ## The OSLF Connection: Rely-Possibly Semantics

From Meredith & Stay's OSLF paper, the modal type has semantics:

  t :: ⟨C_j⟩_{x_k::A_k} B  ⟺
    ∀(x_k : X_k)_{k∈FV(C_j)}.
      (∧_{k∈FV(C_j)} x_k :: ⟦A_k⟧) ⇒
        ∃p : Pr. ⟦C_j⟧(t, (x_k)) ⇝ p ∧ p :: ⟦B⟧

This is the RELY-POSSIBLY reading:
- We RELY on parameters x_k having types A_k
- It's POSSIBLE in one step to reach a reduct with type B
-/

/-- The rely-possibly formula for PLN deduction.

    For evidence E_AB (for A→B) and E_BC (for B→C):
    We RELY on: s_AB = toStrength(E_AB), s_BC = toStrength(E_BC)
    It's POSSIBLE: (A→B) ∧ (B→C) ⇝ (A→C) with evidence deductionEvidence

    This is EXACTLY the PLN deduction formula!
-/
noncomputable def deductionRelyPossibly
    (E_AB E_BC : Evidence)
    (pB pC : ENNReal)
    (hE_AB : E_AB.total ≠ 0)
    (hE_BC : E_BC.total ≠ 0)
    (hpB : pB ≠ 1) : Evidence :=
  Evidence.deductionEvidence E_AB E_BC pB pC hE_AB hE_BC hpB

/-! ## The Key Theorem: Modal Composition = Evidence Composition

We've already proved this in PLNDeductionComposition.lean!
The hypercube construction EXPLAINS why the formula works.
-/

/-- The PLN deduction formula IS the modal composition in the hypercube.

    This connects:
    - Operational semantics: (A→B) ∧ (B→C) ⇝ (A→C)
    - Type theory: Π_{s_AB} Π_{s_BC} Evidence
    - Algebra: Evidence tensor product with direct/indirect paths

    The hypercube construction shows this is SYSTEMATIC, not ad-hoc!
-/
theorem deduction_is_modal_composition :
    ∀ (s_AB s_BC pB pC : ENNReal),
    Evidence.deductionStrength s_AB s_BC pB pC =
    -- Direct path: s_AB * s_BC (tensor product)
    s_AB * s_BC +
    -- Indirect path: (1 - s_AB) * complement (Heyting implication)
    (1 - s_AB) * Evidence.complementStrength pB pC s_BC := by
  intros
  unfold Evidence.deductionStrength Evidence.directPathStrength Evidence.indirectPathStrength
  rfl

/-! ## Section 4: Spatial Types from Term Constructors

Beyond modal types, we have SPATIAL types that classify terms by AST structure.

For each constructor f : X₁ × ... × Xₙ → Y, add type former:
  f♯(A₁, ..., Aₙ) : Y

This classifies terms whose head is f!
-/

/-- Spatial type for PLN implication constructor.

    impl♯(A, B) = the type of terms that ARE implications P → Q
    where P :: A and Q :: B
-/
structure ImplSpatialType where
  /-- Type of the antecedent -/
  antecedentType : Evidence
  /-- Type of the consequent -/
  consequentType : Evidence

/-- Spatial type for PLN conjunction constructor.

    conj♯(A, B) = the type of terms that ARE conjunctions P ∧ Q
    where P :: A and Q :: B
-/
structure ConjSpatialType where
  /-- Type of the left conjunct -/
  leftType : Evidence
  /-- Type of the right conjunct -/
  rightType : Evidence

/-- The spatial type of the deduction redex.

    The LHS (A→B) ∧ (B→C) has spatial type:
    conj♯(impl♯(A, B), impl♯(B, C))
-/
noncomputable def deductionRedexSpatialType : ConjSpatialType where
  leftType := ⊤   -- (A→B) as Evidence
  rightType := ⊤  -- (B→C) as Evidence

/-! ## Section 5: Equational Center

When equations are present, not all sort assignments are valid.
The equational center Z is the set of admissible assignments.

For PLN, the key equation is associativity of conjunction:
  (P ∧ Q) ∧ R = P ∧ (Q ∧ R)

This constrains which sort assignments survive.
-/

/-- Equations in the PLN presentation used by hypercube admissibility. -/
structure TheoryEquation where
  lhs : PLNTerm
  rhs : PLNTerm

/-- PLN conjunction associativity equation. -/
def conjAssocEquation : TheoryEquation where
  lhs := PLNTerm.conj (PLNTerm.conj (PLNTerm.atom "P") (PLNTerm.atom "Q")) (PLNTerm.atom "R")
  rhs := PLNTerm.conj (PLNTerm.atom "P") (PLNTerm.conj (PLNTerm.atom "Q") (PLNTerm.atom "R"))

/-- PLN conjunction commutativity equation. -/
def conjCommEquation : TheoryEquation where
  lhs := PLNTerm.conj (PLNTerm.atom "P") (PLNTerm.atom "Q")
  rhs := PLNTerm.conj (PLNTerm.atom "Q") (PLNTerm.atom "P")

/-- The equation family tracked in this hypercube file. -/
def plnEquations : List TheoryEquation :=
  [conjAssocEquation, conjCommEquation]

/-- Variables occurring in a PLN term. -/
def termVars : PLNTerm → Finset String
  | .atom v => {v}
  | .impl a b => termVars a ∪ termVars b
  | .conj a b => termVars a ∪ termVars b
  | .disj a b => termVars a ∪ termVars b
  | .neg a => termVars a
  | .truth _ => ∅

/-- Variables shared between both sides of an equation. -/
def sharedVars (eq : TheoryEquation) : Finset String :=
  termVars eq.lhs ∩ termVars eq.rhs

/-- A sort assignment respects an equation when each shared variable slot
is typed at the term level (`∗`). -/
def respectsEquation (σ : Slot → HSort) (eq : TheoryEquation) : Prop :=
  ∀ v, v ∈ sharedVars eq → σ (Slot.param v (PLNObj.Concept v)) = HSort.star

/-- Equational admissibility for PLN hypercube slots.

`σ` is admissible when:
1. the rewrite result slot is term-level (`∗`), and
2. each tracked PLN equation is respected on shared variable slots.
-/
def isEquationallyAdmissible (σ : Slot → HSort) : Prop :=
  σ Slot.result = HSort.star ∧
  ∀ eq ∈ plnEquations, respectsEquation σ eq

/-- Any admissible assignment classifies the rewrite result as a term (`∗`). -/
theorem isEquationallyAdmissible_result_star
    {σ : Slot → HSort} (hσ : isEquationallyAdmissible σ) :
    σ Slot.result = HSort.star :=
  hσ.1

/-- The all-`∗` assignment is admissible for the tracked PLN equations. -/
theorem allStar_isEquationallyAdmissible :
    isEquationallyAdmissible (fun _ => HSort.star) := by
  constructor
  · rfl
  · intro eq heq v hv
    rfl

/-! ## The Full H_Σ Construction

The endofunctor H_Σ on lambda theories:
1. Takes a lambda theory T with rewrites
2. Generates modal types for each rewrite context
3. Adds spatial types for each constructor
4. Yields a hypercube of typed calculi parametrized by Σ
-/

/-- The H_Σ construction applied to PLN.

    Input: PLN as a lambda theory with deduction rewrite
    Output: A family of typed PLN calculi indexed by sort assignments

    Each vertex of the hypercube is a different "typed PLN"!
-/
structure HypercubePLN where
  /-- The sort assignment Σ -/
  sortAssignment : GlobalSortAssignment
  /-- Modal types generated from deduction -/
  modalTypes : List ModalType
  /-- Spatial types from constructors -/
  spatialTypes : List (ImplSpatialType ⊕ ConjSpatialType)

/-! ## Summary: What the Hypercube Gives Us

1. **Systematic Generation**: Modal types arise FROM rewrites, not ad-hoc
2. **PLN Deduction Justified**: The formula IS modal composition
3. **Type/Kind Distinction**: Sort slots give ∗/□ choices
4. **Spatial Classification**: Terms classified by AST structure
5. **Equational Constraints**: Only admissible Σ survive

The PLN hypercube has ~128 vertices (2^7 for 7 slots).
Each vertex is a different "typed PLN" with different ∗/□ choices!
-/

-- The number of distinct typed PLN systems:
-- hypercubeVertices deductionPositions = 2^7 = 128

end Mettapedia.CategoryTheory.Hypercube
