%% pi-rho-encoding: Verified Forward Simulation for the π→ρ Encoding
%%
%% Render with:
%%   pdflatex pi-rho-encoding.tex && bibtex pi-rho-encoding && pdflatex pi-rho-encoding.tex && pdflatex pi-rho-encoding.tex

\documentclass[]{article}
\usepackage{url}
\usepackage[hyperindex,breaklinks]{hyperref}
\usepackage{breakurl}
\usepackage{listings}
\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true,frame=single}
\usepackage{float}
\restylefloat{table}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\codepath}[1]{\path{#1}}
\newcommand{\rhocalc}{\ensuremath{\varrho}}
\newcommand{\picalc}{\ensuremath{\pi}}

\title{Verified Forward Simulation for the $\picalc \to \rhocalc$ Encoding\\
  in Lean~4\\[0.5em]
  \texttt{(DRAFT --- \today)}}
\author{Zar \and Oru\v{z}i (Claude Anthropic)}

\begin{document}
\maketitle

\begin{abstract}
We present a fully verified forward simulation theorem for the encoding of
the asynchronous $\picalc$-calculus into the reflective higher-order
$\rhocalc$-calculus, formalized in Lean~4.  The key challenge is the
\emph{structural congruence (SC) case}: full $\picalc$-SC includes the rule
$\nu x.\mathbf{0} \equiv \mathbf{0}$, which via symmetry and transitivity
can derive $P \equiv \nu x.P$ for arbitrary~$P$, breaking the
restriction-free (RF) invariant.  We resolve this by defining a
\emph{restriction-free structural congruence} (RFSC) that excludes all
$\nu$- and replication rules, yielding a self-contained RF fragment with a
clean inductive proof.  The formalization comprises ${\sim}1{,}160$ lines
of Lean~4 with \textbf{0~sorries}.
\end{abstract}

\section{Introduction}

Lybech~\cite{Lybech2022} defines an encoding
$\llbracket \cdot \rrbracket : \picalc \to \rhocalc$ from the asynchronous
$\picalc$-calculus into the reflective higher-order $\rhocalc$-calculus of
Meredith and Radestock~\cite{MeredithRadestock2005}, and proves five
correctness propositions:

\begin{enumerate}
\item[Prop 1.] Parameter independence (the namespace parameter is irrelevant).
\item[Prop 2.] Substitution invariance: $\llbracket P\{z/y\} \rrbracket = \llbracket P \rrbracket\{z/y\}$.
\item[Prop 3.] Barb preservation.
\item[Prop 4.] Operational correspondence (forward and backward simulation).
\item[Prop 5.] Divergence reflection.
\end{enumerate}

Our Lean~4 formalization~\cite{leanOSLF} proves Proposition~2 in full
generality (0~sorries), and the \emph{forward direction} of Proposition~4
for the \emph{restriction-free fragment} (0~sorries).  This paper describes
the forward simulation proof.

\section{The Encoding}
\label{sec:encoding}

The $\picalc$-calculus processes are built from six constructors:
\[
P, Q ::= \mathbf{0} \mid P \| Q \mid x(y).P \mid \bar{x}\langle z \rangle
  \mid \nu x.P \mid !x(y).P
\]
The encoding $\llbracket \cdot \rrbracket$ maps each to $\rhocalc$-calculus
patterns, using a locally nameless representation (de Bruijn indices for bound
variables, named free variables).

\begin{definition}[Restriction-Free Process]
A process~$P$ is \emph{restriction-free} (RF) if it contains no
$\nu$-binder and no replication~$!$.
\end{definition}

For RF processes, the encoding uses only $\rhocalc$-input, $\rhocalc$-output,
$\rhocalc$-nil, and $\rhocalc$-par.  Crucially, the namespace parameter~$n$
(used for restriction channels) becomes irrelevant:

\begin{lemma}[Namespace Independence for RF]
\label{lem:ns-independent}
If $P$ is restriction-free, then $\llbracket P \rrbracket_{n_1} = \llbracket P \rrbracket_{n_2}$
for any namespace strings $n_1, n_2$.
\end{lemma}

\section{The STRUCT Blocker}
\label{sec:struct-blocker}

The $\picalc$-calculus reduction relation includes a structural rule:
\[
\frac{P \equiv P' \quad P' \to Q' \quad Q' \equiv Q}{P \to Q}
  \quad (\text{STRUCT})
\]
where $\equiv$ is the full structural congruence.  The $\picalc$-SC includes
the rule $\nu x.\mathbf{0} \equiv \mathbf{0}$ (\code{nu\_nil}).  Via symmetry,
this gives $\mathbf{0} \equiv \nu x.\mathbf{0}$, and by transitivity with
congruence rules, one can derive:
\[
P \equiv P \| \mathbf{0} \equiv P \| \nu x.\mathbf{0}
  \equiv \nu x.(P \| \mathbf{0}) \equiv \nu x.P
\]
(using \code{par\_nil\_right}, \code{nu\_nil}${}^{-1}$, \code{nu\_par}).
This means the full SC can transport any RF process~$P$ to
$\nu x.P$, which is \emph{not} restriction-free.

\begin{proposition}[RF is not preserved by full SC]
There exist processes $P, Q$ with $P \equiv Q$, $P$ restriction-free,
and $Q$ not restriction-free.
\end{proposition}

This makes a proof of \code{encode\_preserves\_pi\_SC} by induction on the
full SC derivation impossible for the RF fragment, since the induction
hypothesis requires the intermediate process to be RF.

\section{Restriction-Free Structural Congruence}
\label{sec:rfsc}

Our solution, following a suggestion by GPT-5.2 Pro, is to define a
\emph{restriction-free structural congruence} (RFSC) that excludes all
rules involving $\nu$ and replication.

\begin{definition}[RFSC]
The relation $P \equiv_R Q$ is the smallest congruence on processes
generated by:
\begin{enumerate}
\item Reflexivity, symmetry, transitivity.
\item $\text{par\_cong}$: $P \equiv_R P' \wedge Q \equiv_R Q' \Rightarrow P\|Q \equiv_R P'\|Q'$.
\item $\text{par\_comm}$: $P \| Q \equiv_R Q \| P$.
\item $\text{par\_assoc}$: $(P \| Q) \| R \equiv_R P \| (Q \| R)$.
\item $\text{par\_nil\_left}$: $\mathbf{0} \| P \equiv_R P$.
\item $\text{par\_nil\_right}$: $P \| \mathbf{0} \equiv_R P$.
\end{enumerate}
Excluded: \code{input\_cong}, \code{nu\_cong}, \code{replicate\_cong},
\code{nu\_nil}, \code{nu\_par}, \code{nu\_swap}, all $\alpha$-conversion
rules, and \code{replicate\_unfold}.
\end{definition}

The key property that makes RFSC useful:

\begin{lemma}[RFSC preserves RF (iff)]
\label{lem:rfsc-preserves-rf}
$P \equiv_R Q$ implies $\text{RF}(P) \Leftrightarrow \text{RF}(Q)$.
\end{lemma}
\begin{proof}
By induction on the RFSC derivation.  Each case is straightforward:
\code{par\_comm} uses $A \wedge B \Leftrightarrow B \wedge A$,
\code{par\_assoc} uses associativity of $\wedge$,
\code{par\_nil\_left/right} use $\top \wedge A \Leftrightarrow A$.
The \code{nu\_nil} rule, which would break this property, is absent.
\end{proof}

\begin{definition}[RF Reduction]
The relation $P \to_R Q$ (\code{ReducesRF}) is defined by:
\begin{enumerate}
\item \code{comm}: $x(y).P \| \bar{x}\langle z \rangle \to_R P\{z/y\}$.
\item \code{par\_left}: $P \to_R P' \Rightarrow P\|Q \to_R P'\|Q$.
\item \code{par\_right}: $Q \to_R Q' \Rightarrow P\|Q \to_R P\|Q'$.
\item \code{struct}: $P \equiv_R P' \wedge P' \to_R Q' \wedge Q' \equiv_R Q \Rightarrow P \to_R Q$.
\end{enumerate}
No \code{res} rule (restriction has no reduction for RF processes).
\end{definition}

\section{Forward Simulation}
\label{sec:forward-sim}

\subsection{Infrastructure}

The proof builds on the following sorry-free infrastructure:

\begin{itemize}
\item \textbf{Substitution commutation} (\code{encode\_rf\_subst\_fvar}):
  the encoding commutes with substitution under a Barendregt convention.
\item \textbf{COMM case} (\code{forward\_comm\_rf}):
  the encoding of $x(y).P \| \bar{x}\langle z \rangle$ reduces in one step
  (via $\rhocalc$-COMM) to a pattern SC-equivalent to the encoding of $P\{z/y\}$.
  Uses the \code{quote\_drop} SC rule to bridge the NQuote/PDrop wrapper.
\item \textbf{PAR congruence} (\code{forward\_par\_left\_rf}, \code{forward\_par\_right\_rf}):
  reductions in components lift through \code{rhoPar} by bridging to
  two-element hashBag collections and reducing at the appropriate position.
\item \textbf{$\rhocalc$-SC lemmas for \code{rhoPar}}:
  commutativity, nil-absorption, and associativity of \code{rhoPar}
  under $\rhocalc$-SC, handling the 4-way case analysis of the \code{rhoPar}
  definition (both hashBag, left hashBag, right hashBag, neither).
\item \textbf{Encoding preserves RFSC} (\code{encode\_preserves\_rfsc}):
  if $P \equiv_R Q$ and $P$ is RF, then
  $\llbracket P \rrbracket \equiv_\rhocalc \llbracket Q \rrbracket$.
  Uses namespace independence (Lemma~\ref{lem:ns-independent}) to normalize
  all namespace parameters, then applies the \code{rhoPar} SC lemmas.
\end{itemize}

\subsection{The Main Theorem}

\begin{definition}[CommSafe]
A reduction derivation $P \to_R Q$ is \emph{CommSafe} if every COMM step
has $y \neq z$ and satisfies a Barendregt freshness condition on the body.
\end{definition}

\begin{theorem}[Single-Step Forward Simulation, 0 sorries]
\label{thm:forward-single}
If $P \to_R Q$ (via \code{ReducesRF}), $P$ is RF, and the derivation is
CommSafe, then there exists $T$ such that:
\[
\llbracket P \rrbracket \twoheadrightarrow T
\quad\text{and}\quad
T \equiv_\rhocalc \llbracket Q \rrbracket
\]
\end{theorem}
\begin{proof}
By induction on the \code{ReducesRF} derivation:
\begin{itemize}
\item \textbf{COMM}: Directly by \code{forward\_comm\_rf}.
\item \textbf{PAR\_LEFT/RIGHT}: By \code{forward\_par\_left\_rf} / \code{forward\_par\_right\_rf} with the induction hypothesis.
\item \textbf{STRUCT}: Let $P \equiv_R P'$, $P' \to_R Q'$, $Q' \equiv_R Q$.
  By \code{encode\_preserves\_rfsc}: $\llbracket P \rrbracket \equiv_\rhocalc \llbracket P' \rrbracket$.
  By IH: $\llbracket P' \rrbracket \twoheadrightarrow T$ with $T \equiv_\rhocalc \llbracket Q' \rrbracket$.
  By \code{encode\_preserves\_rfsc}: $\llbracket Q' \rrbracket \equiv_\rhocalc \llbracket Q \rrbracket$.
  Fold the pre-SC into the first reduction step via \code{ReducesStar\_equiv\_pre},
  then chain the post-SC.
\end{itemize}
\end{proof}

\begin{corollary}[Multi-Step Forward Simulation, 0 sorries]
\label{cor:forward-multi}
If $P \twoheadrightarrow_R Q$ (multi-step RF reduction) with $P$ RF and
all steps CommSafe, then $\llbracket P \rrbracket \twoheadrightarrow T$
with $T \equiv_\rhocalc \llbracket Q \rrbracket$.
\end{corollary}
\begin{proof}
By induction on the multi-step derivation, composing single-step results
using transitivity of \code{ReducesStar} and \code{ReducesStar\_equiv\_pre}.
\end{proof}

\section{Formalization Statistics}

\begin{center}
\begin{tabular}{lrl}
\textbf{Component} & \textbf{Lines} & \textbf{Sorries} \\
\hline
\code{ForwardSimulation.lean} & ${\sim}1{,}160$ & 0 \\
\code{RhoEncoding.lean} (encoding definition) & ${\sim}520$ & 0 \\
\code{Syntax.lean} ($\picalc$-calculus AST) & ${\sim}130$ & 0 \\
\code{StructuralCongruence.lean} ($\picalc$-SC) & ${\sim}85$ & 0 \\
\code{Reduction.lean} ($\picalc$-reduction) & ${\sim}200$ & 0 \\
\code{MultiStep.lean} ($\picalc$-multi-step) & ${\sim}90$ & 0 \\
\hline
\textbf{Forward simulation total} & ${\sim}2{,}185$ & \textbf{0} \\
\end{tabular}
\end{center}

The $\rhocalc$-calculus infrastructure (StructuralCongruence, Reduction,
MultiStep: ${\sim}3{,}900$ lines, 0~sorries) is shared with the OSLF
formalization and not counted here.

\subsection{Key Proof Techniques}

\begin{enumerate}
\item \textbf{Namespace normalization}: For RF processes, all namespace
  parameters are irrelevant (\code{encode\_rf\_ns\_independent}).  This
  collapses the 6~distinct namespace suffixes in nested \code{par}
  encodings to a single canonical value, dramatically simplifying SC proofs.

\item \textbf{HashBag bridging}: The $\rhocalc$-calculus parallel composition
  is modeled as hashBag collections.  The helper \code{rhoPar\_to\_two}
  bridges between \code{rhoPar A B} (which has 4~cases depending on
  whether $A$ or $B$ is already a hashBag) and the canonical form
  $\{|A, B|\}$, enabling uniform treatment.

\item \textbf{Trans disambiguation}: Lean's \code{Trans.trans} typeclass
  instance (2~arguments) conflicts with the opened $\rhocalc$-SC
  \code{trans} constructor (5~arguments).  All \code{trans} calls require
  explicit middle terms: \code{trans \_ M \_ h1 h2} rather than
  \code{trans \_ \_ \_ h1 h2}.

\item \textbf{Par\_cong list unification}: The \code{par\_cong} constructor
  requires explicit list arguments to prevent Lean from unifying both
  lists as identical when the length proof is \code{rfl}.
\end{enumerate}

\section{Remaining Work}

\begin{itemize}
\item \textbf{Backward simulation}: The encoding produces processes of a
  restricted syntactic form.  An inversion lemma classifying which
  $\rhocalc$-reductions are possible on encoded terms would give the
  backward direction.

\item \textbf{Full $\picalc$-calculus}: Extending from the RF fragment to
  handle $\nu$-restriction and replication requires either:
  (a)~proving the STRUCT case for the full SC (dealing with the namespace
  bridge when SC passes through non-RF intermediates), or
  (b)~showing that any full $\picalc$-reduction can be factored through an
  RF-equivalent derivation.

\item \textbf{Propositions 3 and 5}: Barb preservation and divergence
  reflection follow from forward + backward simulation.
\end{itemize}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
